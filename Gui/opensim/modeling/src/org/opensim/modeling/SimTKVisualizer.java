/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  Provide simple visualization of and interaction with a Simbody simulation,<br>
 * with real time control of the frame rate.\ There are several operating modes<br>
 * available, including real time operation permitting responsive user interaction<br>
 * with the simulation.<br>
 * <br>
 * Frames are sent to the renderer at a regular interval that is selectable, with<br>
 * a default rate of 30 frames/second. The various operating modes provide <br>
 * different methods of controlling which simulation frames are selected and how<br>
 * they are synchronized for display.<br>
 * <br>
 * <h3>Visualization modes</h3><br>
 * <br>
 * There are three operating modes for the Visualizer's display of simulation<br>
 * results, selectable via setMode():<br>
 * <br>
 * - <b>PassThrough</b>. This is the default mode. It sends through to the <br>
 * renderer <i>every</i> frame that is received from the simulation, slowing down the <br>
 * simulation if necessary so that the frames are presented at a selected frame <br>
 * rate. But note that the simulation time will not be synchronized to real time; <br>
 * because Simbody simulations generally proceed at a variable rate, the <br>
 * regularly-spaced output frames will represent different amounts of simulated <br>
 * time. If you want real time and simulation time synchronized, use the RealTime <br>
 * mode.<br>
 * <br>
 * - <b>Sampling</b>. This mode is useful for monitoring a simulation that is<br>
 * allowed to run at full speed. We send frames for display at a maximum rate <br>
 * given by the frame rate setting. After a frame is sent, all subsequent frames <br>
 * received from the simulation are ignored until the frame interval has passed; <br>
 * then the next received frame is displayed. This allows the simulation to <br>
 * proceed at the fastest rate possible but time will be irregular and not all <br>
 * frames generated by the simulation will be shown.<br>
 * <br>
 * - <b>RealTime</b>. Synchronize frame times with the simulated time, slowing<br>
 * down the simulation if it is running ahead of real time, as modifed by the<br>
 * time scale; see setRealTimeScale(). Frames are sent to the renderer at the<br>
 * selected frame rate. Smoothness is maintained by buffering up frames before <br>
 * sending them; interactivity is maintained by keeping the buffer length below <br>
 * human perception time (150-200ms). The presence and size of the buffer is <br>
 * selectable; see setDesiredBufferLengthInSec().<br>
 * <br>
 * <h3>User interaction</h3><br>
 * <br>
 * The Simbody visualizer provides some user interaction of its own, for<br>
 * example allowing the user to control the viewpoint and display options. User<br>
 * inputs that it does not interpret locally are passed on to the simulation,<br>
 * and can be intercepted by registering InputListeners with the Visualizer. The<br>
 * Visualizer provides a class Visualizer::InputSilo which is an InputListener<br>
 * that simply captures and queues all user input, with the intent that a running<br>
 * simulation will occasionally stop to poll the InputSilo to process any input<br>
 * that has been collected. <br>
 * <br>
 * <h3>Implementation notes</h3><br>
 * <br>
 * RealTime mode is worth some discussion. There is a simulation thread that<br>
 * produces frames at a variable rate, and a draw thread that consumes frames at a<br>
 * variable rate (by sending them to the renderer). We want to engineer things so <br>
 * that frames are sent to the renderer at a steady rate that is synchronized with<br>
 * simulation time (possibly after scaling). When a thread is running too fast, <br>
 * that is easily handled by blocking the speeding thread for a while. The "too <br>
 * slow" case takes careful handling.<br>
 * <br>
 * In normal operation, we expect the simulation to take varying amounts of<br>
 * real time to generate fixed amounts of simulation time, because we prefer<br>
 * to use variable time-step integrators that control errors by taking smaller<br>
 * steps in more difficult circumstances, and large steps through the easy<br>
 * parts of the simulation. For real time operation, the simulation must of<br>
 * course *average* real time performance; we use a frame buffer to smooth<br>
 * out variable delivery times. That is, frames go into the buffer at an<br>
 * irregular rate but are pulled off at a regular rate. A longer buffer can<br>
 * mask wider deviations in frame time, at the expense of interactive response.<br>
 * In most circumstances people cannot perceive delays below about 200ms, so<br>
 * for good response the total delay should be kept around that level.<br>
 * <br>
 * Despite the buffering, there will be occasions when the simulation can't<br>
 * keep up with real time. A common cause of that is that a user has paused<br>
 * either the simulation or the renderer, such as by hitting a breakpoint while<br>
 * debugging. In that case we deem the proper behavior to be that when we <br>
 * resume we should immediately resume real time behavior at a new start time, <br>
 * <i>not</i> attempt to catch up to the previous real time by running at high speed. <br>
 * As much as possible, we would like the simulation to behave just as it would <br>
 * have without the interruption, but with a long pause where interrupted. We<br>
 * deal with this situation by introducing a notion of "adjusted real time"<br>
 * (AdjRT). That is a clock that tracks the real time interval counter, but uses<br>
 * a variable base offset that is used to match it to the expected simulation <br>
 * time. When the simulation is long delayed, we modify the AdjRT base when we<br>
 * resume so that AdjRT once again matches the simulation time t. Adjustments<br>
 * to the AdjRT base occur at the time we deliver frames to the renderer; at that<br>
 * moment we compare the AdjRT reading to the frame's simulation time t and <br>
 * correct AdjRT for future frames.<br>
 * <br>
 * You can also run in RealTime mode without buffering. In that case frames are<br>
 * sent directly from the simulation thread to the renderer, but the above logic<br>
 * still applies. Simulation frames that arrive earlier than the corresponding<br>
 * AdjRT are delayed; frames that arrive later are drawn immediately but cause<br>
 * AdjRT to be readjusted to resynchronize. Overall performance can be better<br>
 * in unbuffered RealTime mode because the States provided by the simulation do<br>
 * not have to be copied before being drawn. However, intermittent slower-than-<br>
 * realtime frame times cannot be smoothed over; they will cause rendering delays.<br>
 * <br>
 * PassThrough and Sampling modes are much simpler because no synchronization<br>
 * is done to the simulation times. There is only a single thread and draw<br>
 * time scheduling works in real time without adjustment. <br>
 * <br>
 * With the above explanation, you may be able to figure out most of what comes<br>
 * out of the dumpStats() method which can be used to help diagnose performance<br>
 * problems. *
 */
public class SimTKVisualizer {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public SimTKVisualizer(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(SimTKVisualizer obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(SimTKVisualizer obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimbodyJNI.delete_SimTKVisualizer(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Construct a new %Visualizer for the indicated System, and launch the<br>
   * visualizer display executable from a default or specified location. The camera's<br>
   * "up" direction will initially be set to match the "up" direction hint that is <br>
   * stored with the supplied <i>system;</i> the default is that "up" is in the <br>
   * direction of the positive Y axis. The background will normally include a <br>
   * ground plane and sky, but if the <i>system</i> has been set to request a uniform <br>
   * background we'll use a plain white background instead. You can override the <br>
   * chosen defaults using %Visualizer methods setSystemUpDirection() and <br>
   * setBackgroundType(). <br>
   * <br>
   * Simbody is shipped with a separate executable program simbody-visualizer<br>
   * (simbody-visualizer_d if building as Debug) that provides the graphics display<br>
   * and collects user input. Normally that executable is installed in the "bin"<br>
   * subdirectory of the Simbody installation directory.  However, first we look in<br>
   * the same directory as the currently-running executable and, if found, we will<br>
   * use that visualizer. If no visualizer is found with the executable, we check if<br>
   * environment variables SIMBODY_HOME or SimTK_INSTALL_DIR exist, and look in<br>
   * their "bin" (or "libexec/simbody" on UNIX) subdirectories if so. Next, we<br>
   * attempt to use the relative path from the SimTKsimbody library to the<br>
   * simbody-visualizer (this helps if Simbody is relocated, but does not work on<br>
   * Windows, or if using static Simbody libraries). Then, we check the installed<br>
   * location of the visualizer, as specified when Simbody is compiled. If the<br>
   * visualizer is not there, we'll look in platform-specific default locations.<br>
   * The other constructor allows specification of a search path that will be<br>
   * checked before attempting to find the installation directory.<br>
   * <br>
   * If you want to override the name of the visualizer executable for which Simbody<br>
   * searches, set the environment variable SIMBODY_VISUALIZER_NAME<br>
   * to the desired executable name. For example, if you want to use the<br>
   * debug visualizer with release libraries, set SIMBODY_VISUALIZER_NAME<br>
   * to simbody-visualizer_d.<br>
   * <br>
   * The SimTK::Pathname class is used to process the supplied search path, which<br>
   * can consist of absolute, working directory-relative, or executable <br>
   * directory-relative path names.<br>
   * <br>
   * @see SimTK#Pathname *
   */
  public SimTKVisualizer(SWIGTYPE_p_SimTK__MultibodySystem system) {
    this(opensimSimbodyJNI.new_SimTKVisualizer__SWIG_0(SWIGTYPE_p_SimTK__MultibodySystem.getCPtr(system)), true);
  }

  /**
   *  Construct a new Visualizer for a given system, with a specified search<br>
   * path for locating the SimbodyVisualizer executable. The search path is<br>
   * checked <i>after</i> looking in the current executable directory, and <i>before</i> <br>
   * trying to locate the Simbody or SimTK installation directory. See the other<br>
   * constructor's documentation for more information. *
   */
  public SimTKVisualizer(SWIGTYPE_p_SimTK__MultibodySystem system, SWIGTYPE_p_SimTK__Array_T_String_unsigned_int_t searchPath) {
    this(opensimSimbodyJNI.new_SimTKVisualizer__SWIG_1(SWIGTYPE_p_SimTK__MultibodySystem.getCPtr(system), SWIGTYPE_p_SimTK__Array_T_String_unsigned_int_t.getCPtr(searchPath)), true);
  }

  /**
   *  Copy constructor has reference counted, shallow copy semantics;<br>
   * that is, the Visualizer copy is just another reference to the same<br>
   * Visualizer object. *
   */
  public SimTKVisualizer(SimTKVisualizer src) {
    this(opensimSimbodyJNI.new_SimTKVisualizer__SWIG_2(SimTKVisualizer.getCPtr(src), src), true);
  }

  /**
   *  Ask the visualizer to shut itself down immediately. This will cause the<br>
   * display window to close and the associated process to die. This method returns<br>
   * immediately but it may be some time later when the visualizer acts on the<br>
   * instruction; there is no way to wait for it to die. Normally the visualizer<br>
   * will persist even after the death of the simulator connection unless you have<br>
   * called setShutdownWhenDestructed() to make shutdown() get called automatically.<br>
   * @see setShutdownWhenDestructed() *
   */
  public void shutdown() {
    opensimSimbodyJNI.SimTKVisualizer_shutdown(swigCPtr, this);
  }

  /**
   *  Set the flag that determines whether we will automatically send a Shutdown<br>
   * message to the visualizer when this %Visualizer object is destructed. <br>
   * Normally we allow the GUI to persist even after death of the simulator<br>
   * connection, unless an explicit call to shutdown() is made. <br>
   * @see getShutdownWhenDestructed(), shutdown() *
   */
  public SimTKVisualizer setShutdownWhenDestructed(boolean shouldShutdown) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setShutdownWhenDestructed(swigCPtr, this, shouldShutdown), false);
  }

  /**
   *  Return the current setting of the "shutdown when destructed" flag. By <br>
   * default this is false.<br>
   * @see setShutdownWhenDestructed(), shutdown() *
   */
  public boolean getShutdownWhenDestructed() {
    return opensimSimbodyJNI.SimTKVisualizer_getShutdownWhenDestructed(swigCPtr, this);
  }

  /**
   * * Change the background mode currently in effect in the GUI.\ By default<br>
   * we take the desired background type from the System, which will usually be<br>
   * at its default value which is to show a ground plane and sky. You can override<br>
   * that default choice with this method.<br>
   * @param background   The background type to use.<br>
   * @return A reference to this Visualizer so that you can chain "set" calls. <br>
   * Note: Molmodel's CompoundSystem requests a solid background by default, since<br>
   * ground and sky is not the best way to display a molecule! *
   */
  public SimTKVisualizer setBackgroundType(SimTKVisualizer.BackgroundType background) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setBackgroundType(swigCPtr, this, background.swigValue()), false);
  }

  /**
   *  Set the background color.\ This will be used when the solid background<br>
   * mode is in effect but has no effect otherwise. This is a const method so you<br>
   * can call it from within a FrameController, for example if you want to flash<br>
   * the background color.<br>
   * @param color   The background color in r,g,b format with [0,1] range.<br>
   * @return A const reference to this Visualizer so that you can chain "set" <br>
   * calls, provided subsequent ones are also const. *
   */
  public SimTKVisualizer setBackgroundColor(Vec3 color) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setBackgroundColor(swigCPtr, this, Vec3.getCPtr(color), color), false);
  }

  /**
   *  Control whether shadows are generated when the GroundAndSky background<br>
   * type is in effect.\ This has no effect if the ground plane is not being <br>
   * displayed. The default if for shadows to be displayed. This is a const method<br>
   * so you can call it from within a FrameController.<br>
   * @param showShadows     Set true to have shadows generated; false for none.<br>
   * @see setBackgroundType()@return A const reference to this Visualizer so that you can chain "set" <br>
   * calls, provided subsequent ones are also const. *
   */
  public SimTKVisualizer setShowShadows(boolean showShadows) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setShowShadows(swigCPtr, this, showShadows), false);
  }

  /**
   *  Control whether frame rate is shown in the Visualizer.\ This is a const<br>
   * method so you can call it from within a FrameController.<br>
   * @param showFrameRate     Set true to show the frame rate; false for none.<br>
   * @return A const reference to this Visualizer so that you can chain "set" <br>
   * calls, provided subsequent ones are also const. *
   */
  public SimTKVisualizer setShowFrameRate(boolean showFrameRate) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setShowFrameRate(swigCPtr, this, showFrameRate), false);
  }

  /**
   *  Control whether simulation time is shown in the Visualizer.\ This is a const<br>
   * method so you can call it from within a FrameController.<br>
   * @param showSimTime     Set true to show the simulation time; false for none.<br>
   * @return A const reference to this Visualizer so that you can chain "set" <br>
   * calls, provided subsequent ones are also const. *
   */
  public SimTKVisualizer setShowSimTime(boolean showSimTime) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setShowSimTime(swigCPtr, this, showSimTime), false);
  }

  /**
   *  Control whether frame number is shown in the Visualizer.\ This is a const<br>
   * method so you can call it from within a FrameController.<br>
   * @param showFrameNumber     Set true to show the frame number; false for none.<br>
   * @return A const reference to this Visualizer so that you can chain "set" <br>
   * calls, provided subsequent ones are also const. *
   */
  public SimTKVisualizer setShowFrameNumber(boolean showFrameNumber) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setShowFrameNumber(swigCPtr, this, showFrameNumber), false);
  }

  /**
   *  Change the title on the main visualizer window.\ The default title<br>
   * is Simbody <i>version</i> : <i>exename</i>, where <i>version</i> is the current Simbody<br>
   * version number in major.minor.patch format and <i>exename</i> is the name of the <br>
   * executing simulation application's executable file (without suffix if any).<br>
   * @param title   <br>
   *     The new window title. The amount of room for the title varies; keep <br>
   *     it short.<br>
   * @return A const reference to this Visualizer so that you can chain "set" <br>
   * calls, provided subsequent ones are also const. <br>
   * @see SimTK_version_simbody(), Pathname::getThisExecutablePath(),Pathname::desconstructPathname() *
   */
  public SimTKVisualizer setWindowTitle(SWIGTYPE_p_String title) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setWindowTitle(swigCPtr, this, SWIGTYPE_p_String.getCPtr(title)), false);
  }

  /**
   * ** Set the coordinate direction that should be considered the System's "up"<br>
   * direction.\ When the ground and sky background is in use, this is the <br>
   * direction that serves as the ground plane normal, and is used as the initial<br>
   * orientation for the camera's up direction (which is subsequently under user<br>
   * or program control and can point anywhere). If you don't set this explicitly<br>
   * here, the Visualizer takes the default up direction from the System, which<br>
   * provides a method allowing the System's creator to specify it, with the +Y<br>
   * axis being the default. <br>
   * @param upDirection <br>
   *     This must be one of the CoordinateAxis constants XAxis, YAxis, or ZAxis,<br>
   *     or one of the opposite directions -XAxis, -YAxis, or -ZAxis.<br>
   * @return A writable reference to this Visualizer so that you can chain "set" <br>
   * calls in the manner of chained assignments. *
   */
  public SimTKVisualizer setSystemUpDirection(CoordinateDirection upDirection) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setSystemUpDirection(swigCPtr, this, CoordinateDirection.getCPtr(upDirection), upDirection), false);
  }

  /**
   *  Get the value the Visualizer is using as the System "up" direction (<br>
   * not to be confused with the camera "up" direction). *
   */
  public CoordinateDirection getSystemUpDirection() {
    return new CoordinateDirection(opensimSimbodyJNI.SimTKVisualizer_getSystemUpDirection(swigCPtr, this), true);
  }

  /**
   *  Set the height at which the ground plane should be displayed when the<br>
   * GroundAndSky background type is in effect.\ This is interpreted along the<br>
   * system "up" direction that was specified in the Visualizer's System or was<br>
   * overridden with the setSystemUpDirection() method. The default value is zero,<br>
   * meaning that the ground plane passes through the ground origin.<br>
   * @param height   <br>
   *     The position of the ground plane along the system "up" direction that <br>
   *     serves as the ground plane normal. Note that <i>height</i> is <i>along</i> the <br>
   *     up direction, meaning that if up is one of the negative coordinate axis<br>
   *     directions a positive <i>height</i> will move the ground plane to a more <br>
   *     negative position.<br>
   * @return A reference to this Visualizer so that you can chain "set" calls.<br>
   * @see setSystemUpDirection(), setBackgroundType() *
   */
  public SimTKVisualizer setGroundHeight(double height) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setGroundHeight(swigCPtr, this, height), false);
  }

  /**
   *  Get the value the Visualizer considers to be the height of the ground<br>
   * plane for this System.\ The value must be interpreted along the System's "up"<br>
   * direction. @see setSystemUpDirection() *
   */
  public double getGroundHeight() {
    return opensimSimbodyJNI.SimTKVisualizer_getGroundHeight(swigCPtr, this);
  }

  /**
   *  Set the operating mode for the Visualizer. See <a href="#Visualizer::Mode">Visualizer::Mode</a> for <br>
   * choices, and the discussion for the Visualizer class for meanings.<br>
   * @param mode    The new Mode to use.<br>
   * @return A reference to this Visualizer so that you can chain "set" calls. *
   */
  public SimTKVisualizer setMode(SimTKVisualizer.Mode mode) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setMode(swigCPtr, this, mode.swigValue()), false);
  }

  /**
   *  Get the current mode being used by the Visualizer. See <a href="#Visualizer::Mode">Visualizer::Mode</a><br>
   * for the choices, and the discussion for the Visualizer class for meanings. *
   */
  public SimTKVisualizer.Mode getMode() {
    return SimTKVisualizer.Mode.swigToEnum(opensimSimbodyJNI.SimTKVisualizer_getMode(swigCPtr, this));
  }

  /**
   *  Set the frame rate in frames/sec (of real time) that you want the <br>
   * Visualizer to attempt to achieve. This affects all modes. The default is 30 <br>
   * frames per second. Set the frame rate to zero to return to the default <br>
   * behavior. <br>
   * @param framesPerSec<br>
   *     The desired frame rate; specify as zero to get the default.<br>
   * @return A reference to this Visualizer so that you can chain "set" calls.
   */
  public SimTKVisualizer setDesiredFrameRate(double framesPerSec) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setDesiredFrameRate(swigCPtr, this, framesPerSec), false);
  }

  /**
   *  Get the current value of the frame rate the Visualizer has been asked to <br>
   * attempt; this is not necessarily the rate actually achieved. A return value of <br>
   * zero means the Visualizer is using its default frame rate, which may be<br>
   * dependent on the current operating mode. <br>
   * @see setDesiredFrameRate() for more information. *
   */
  public double getDesiredFrameRate() {
    return opensimSimbodyJNI.SimTKVisualizer_getDesiredFrameRate(swigCPtr, this);
  }

  /**
   *  In RealTime mode we normally assume that one unit of simulated time should<br>
   * map to one second of real time; however, in some cases the time units are not <br>
   * seconds, and in others you may want to run at some multiple or fraction of <br>
   * real time. Here you can say how much simulated time should equal one second of<br>
   * real time. For example, if your simulation runs in seconds, but you want to <br>
   * run twice as fast as real time, then call setRealTimeScale(2.0), meaning that <br>
   * two simulated seconds will pass for every one real second. This call will have <br>
   * no immediate effect if you are not in RealTime mode, but the value will be <br>
   * remembered.<br>
   * <br>
   * @param simTimePerRealSecond<br>
   * The number of units of simulation time that should be displayed in one second<br>
   * of real time. Zero or negative value will be interpeted as the default ratio <br>
   * of 1:1. <br>
   * @return A reference to this Visualizer so that you can chain "set" calls.
   */
  public SimTKVisualizer setRealTimeScale(double simTimePerRealSecond) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setRealTimeScale(swigCPtr, this, simTimePerRealSecond), false);
  }

  /**
   *  Return the current time scale, which will be 1 by default.<br>
   * @see setRealTimeScale() for more information. *
   */
  public double getRealTimeScale() {
    return opensimSimbodyJNI.SimTKVisualizer_getRealTimeScale(swigCPtr, this);
  }

  /**
   *  When running an interactive realtime simulation, you can smooth out changes<br>
   * in simulation run rate by buffering frames before sending them on for <br>
   * rendering. The length of the buffer introduces an intentional response time <br>
   * lag from when a user reacts to when he can see a response from the simulator. <br>
   * Under most circumstances a lag of 150-200ms is undetectable. The default <br>
   * buffer length is the time represented by the number of whole frames <br>
   * that comes closest to 150ms; 9 frames at 60fps, 5 at 30fps, 4 at 24fps, etc. <br>
   * To avoid frequent block/unblocking of the simulation thread, the buffer is<br>
   * not kept completely full; you can use dumpStats() if you want to see how the<br>
   * buffer was used during a simulation. Shorten the buffer to improve <br>
   * responsiveness at the possible expense of smoothness. Note that the total lag <br>
   * time includes not only the buffer length here, but also lag induced by the <br>
   * time stepper taking steps that are larger than the frame times. For maximum <br>
   * responsiveness you should keep the integrator step sizes limited to about <br>
   * 100ms, or reduce the buffer length so that worst-case lag doesn't go much over<br>
   * 200ms. <br>
   * @param bufferLengthInSec<br>
   * This is the target time length for the buffer. The actual length is the nearest<br>
   * integer number of frames whose frame times add up closest to the request. If<br>
   * you ask for a non-zero value, you will always get at least one frame in the<br>
   * buffer. If you ask for zero, you'll get no buffering at all. To restore the<br>
   * buffer length to its default value, pass in a negative number. <br>
   * @return A reference to this Visualizer so that you can chain "set" calls. *
   */
  public SimTKVisualizer setDesiredBufferLengthInSec(double bufferLengthInSec) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setDesiredBufferLengthInSec(swigCPtr, this, bufferLengthInSec), false);
  }

  /**
   *  Get the current value of the desired buffer time length the Visualizer <br>
   * has been asked to use for smoothing the frame rate, or the default value<br>
   * if none has been requested. The actual value will differ from this number<br>
   * because the buffer must contain an integer number of frames. <br>
   * @see getActualBufferTime() to see the frame-rounded buffer length *
   */
  public double getDesiredBufferLengthInSec() {
    return opensimSimbodyJNI.SimTKVisualizer_getDesiredBufferLengthInSec(swigCPtr, this);
  }

  /**
   *  Get the actual length of the real time frame buffer in seconds, which<br>
   * may differ from the requested time because the buffer contains an integer<br>
   * number of frames. *
   */
  public double getActualBufferLengthInSec() {
    return opensimSimbodyJNI.SimTKVisualizer_getActualBufferLengthInSec(swigCPtr, this);
  }

  /**
   *  Get the actual length of the real time frame buffer in number of frames. *
   */
  public int getActualBufferLengthInFrames() {
    return opensimSimbodyJNI.SimTKVisualizer_getActualBufferLengthInFrames(swigCPtr, this);
  }

  /**
   *  Add a new input listener to this Visualizer, methods of which will be<br>
   * called when the GUI detects user-driven events like key presses, menu picks, <br>
   * and slider or mouse moves. See Visualizer::InputListener for more <br>
   * information. The Visualizer takes over ownership of the supplied <i>listener</i> <br>
   * object and deletes it upon destruction of the Visualizer; don't delete it <br>
   * yourself.<br>
   * @return An integer index you can use to find this input listener again. *
   */
  public int addInputListener(SimTKVisualizerInputListener listener) {
    return opensimSimbodyJNI.SimTKVisualizer_addInputListener(swigCPtr, this, SimTKVisualizerInputListener.getCPtr(listener), listener);
  }

  /**
   *  Return the count of input listeners added with addInputListener(). *
   */
  public int getNumInputListeners() {
    return opensimSimbodyJNI.SimTKVisualizer_getNumInputListeners(swigCPtr, this);
  }

  /**
   *  Return a const reference to the i'th input listener. *
   */
  public SimTKVisualizerInputListener getInputListener(int i) {
    return new SimTKVisualizerInputListener(opensimSimbodyJNI.SimTKVisualizer_getInputListener(swigCPtr, this, i), false);
  }

  /**
   *  Return a writable reference to the i'th input listener. *
   */
  public SimTKVisualizerInputListener updInputListener(int i) {
    return new SimTKVisualizerInputListener(opensimSimbodyJNI.SimTKVisualizer_updInputListener(swigCPtr, this, i), false);
  }

  /**
   *  Add a new frame controller to this Visualizer, methods of which will be<br>
   * called just prior to rendering a frame for the purpose of simulation-controlled<br>
   * camera positioning and other frame-specific effects. <br>
   * See Visualizer::FrameController for more information. The Visualizer takes <br>
   * over ownership of the supplied <i>controller</i> object and deletes it upon <br>
   * destruction of the Visualizer; don't delete it yourself. <br>
   * @return An integer index you can use to find this frame controller again. *
   */
  public int addFrameController(SimTKVisualizer.FrameController controller) {
    return opensimSimbodyJNI.SimTKVisualizer_addFrameController(swigCPtr, this, SimTKVisualizer.FrameController.getCPtr(controller), controller);
  }

  /**
   *  Return the count of frame controllers added with addFrameController(). *
   */
  public int getNumFrameControllers() {
    return opensimSimbodyJNI.SimTKVisualizer_getNumFrameControllers(swigCPtr, this);
  }

  /**
   *  Return a const reference to the i'th frame controller. *
   */
  public SimTKVisualizer.FrameController getFrameController(int i) {
    return new SimTKVisualizer.FrameController(opensimSimbodyJNI.SimTKVisualizer_getFrameController(swigCPtr, this, i), false);
  }

  /**
   *  Return a writable reference to the i'th frame controller. *
   */
  public SimTKVisualizer.FrameController updFrameController(int i) {
    return new SimTKVisualizer.FrameController(opensimSimbodyJNI.SimTKVisualizer_updFrameController(swigCPtr, this, i), false);
  }

  /**
   * ** Report that a new simulation frame is available for rendering. Depending<br>
   * on the current Visualizer::Mode, handling of the frame will vary:<br>
   * <br>
   * <p alt="PassThrough"><br>
   * All frames will be rendered, but the calling thread (that is, the simulation) <br>
   * may be blocked if the next frame time has not yet been reached or if the <br>
   * renderer is unable to keep up with the rate at which frames are being supplied <br>
   * by the simulation.</p><br>
   * <br>
   * <p alt="Sampling "><br>
   * The frame will be rendered immediately if the next sample time has been reached<br>
   * or passed, otherwise the frame will be ignored and report() will return <br>
   * immediately.</p><br>
   * <br>
   * <p alt="RealTime"><br>
   * Frames are queued to smooth out the time stepper's variable time steps. The <br>
   * calling thread may be blocked if the buffer is full, or if the simulation time<br>
   * is too far ahead of real time. Frames will be dropped if they come too <br>
   * frequently; only the ones whose simulated times are at or near a frame time <br>
   * will be rendered. Frames that come too late will be queued for rendering as <br>
   * soon as possible, and also reset the expected times for subsequent frames so <br>
   * that real time operation is restored. *</p>
   */
  public void report(State state) {
    opensimSimbodyJNI.SimTKVisualizer_report(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   *  In RealTime mode there will typically be frames still in the buffer at<br>
   * the end of a simulation.\ This allows you to wait while the buffer empties. <br>
   * When this returns, all frames that had been supplied via report() will have<br>
   * been sent to the renderer and the buffer will be empty. Returns immediately<br>
   * if not in RealTime mode, if there is no buffer, or if the buffer is already<br>
   * empty. *
   */
  public void flushFrames() {
    opensimSimbodyJNI.SimTKVisualizer_flushFrames(swigCPtr, this);
  }

  /**
   *  This method draws a frame unconditionally without queuing or checking<br>
   * the frame rate. Typically you should use the report() method instead, and<br>
   * let the the internal queuing and timing system decide when to call <br>
   * drawFrameNow(). *
   */
  public void drawFrameNow(State state) {
    opensimSimbodyJNI.SimTKVisualizer_drawFrameNow(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   * * These methods are used to add permanent elements to the scene being displayed<br>
   * by the Visualizer. Once added, these elements will contribute to every frame.<br>
   * Calling one of these methods requires writable (non-const) access to the <br>
   * Visualizer object; you can't call them from within a FrameController object.<br>
   * Note that adding DecorationGenerators does allow different<br>
   * geometry to be produced for each frame; however, once added a <br>
   * DecorationGenerator will be called for <i>every</i> frame generated. ** Add a new pull-down menu to the visualizer's display. A label<br>
   * for the pull-down button is provided along with an integer identifying the<br>
   * particular menu. A list of (string,int) pairs defines the menu and submenu <br>
   * item labels and associated item numbers. The item numbers must be unique <br>
   * across the entire menu and all its submenus. The strings have a pathname-like <br>
   * syntax, like "submenu/item1", "submenu/item2", "submenu/lowermenu/item1", etc.<br>
   * that is used to define the pulldown menu layout. <br>
   * @param title    the title to display on the menu's pulldown button<br>
   * @param id       an integer value &gt;= 0 that uniquely identifies this menu<br>
   * @param items    item names, possibly with submenus as specified above, with<br>
   *                 associated item numbers <br>
   * When a user picks an item on a menu displayed in the visualizer, that <br>
   * selection is delievered to the simulation application via an InputListener<br>
   * associated with this Visualizer. The selection will be identified by<br>
   * (<i>id</i>, itemNumber) pair. <br>
   * @return A reference to this Visualizer so that you can chain "add" and<br>
   * "set" calls. *
   */
  public SimTKVisualizer addMenu(SWIGTYPE_p_String title, int id, SWIGTYPE_p_SimTK__Array_T_std__pairT_String_int_t_unsigned_int_t items) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_addMenu(swigCPtr, this, SWIGTYPE_p_String.getCPtr(title), id, SWIGTYPE_p_SimTK__Array_T_std__pairT_String_int_t_unsigned_int_t.getCPtr(items)), false);
  }

  /**
   *  Add a new slider to the visualizer's display.<br>
   * @param title    the title to display next to the slider<br>
   * @param id       an integer value that uniquely identifies this slider<br>
   * @param min      the minimum value the slider can have<br>
   * @param max      the maximum value the slider can have<br>
   * @param value    the initial value of the slider, which must be between <br>
   *                 min and max <br>
   * When a user moves a slider displayed in the visualizer, the new value <br>
   * is delievered to the simulation application via an InputListener associated <br>
   * with this Visualizer. The slider will be identified by the <i>id</i> supplied<br>
   * here. <br>
   * @return A reference to this Visualizer so that you can chain "add" and<br>
   * "set" calls. *
   */
  public SimTKVisualizer addSlider(SWIGTYPE_p_String title, int id, double min, double max, double value) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_addSlider(swigCPtr, this, SWIGTYPE_p_String.getCPtr(title), id, min, max, value), false);
  }

  /**
   *  Add an always-present, body-fixed piece of geometry like the one passed in,<br>
   * but attached to the indicated body. The supplied transform is applied on top of<br>
   * whatever transform is already contained in the supplied geometry, and any body <br>
   * index stored with the geometry is ignored. <br>
   * @return An integer index you can use to find this decoration again. *
   */
  public int addDecoration(int mobodIx, Transform X_BD, DecorativeGeometry geometry) {
    return opensimSimbodyJNI.SimTKVisualizer_addDecoration(swigCPtr, this, mobodIx, Transform.getCPtr(X_BD), X_BD, DecorativeGeometry.getCPtr(geometry), geometry);
  }

  /**
   *  Return the count of decorations added with addDecoration(). *
   */
  public int getNumDecorations() {
    return opensimSimbodyJNI.SimTKVisualizer_getNumDecorations(swigCPtr, this);
  }

  /**
   *  Return a const reference to the i'th decoration. *
   */
  public DecorativeGeometry getDecoration(int i) {
    return new DecorativeGeometry(opensimSimbodyJNI.SimTKVisualizer_getDecoration(swigCPtr, this, i), false);
  }

  /**
   *  Return a writable reference to the i'th decoration. This is allowed for<br>
   * a const %Visualizer since it is just a decoration. *
   */
  public DecorativeGeometry updDecoration(int i) {
    return new DecorativeGeometry(opensimSimbodyJNI.SimTKVisualizer_updDecoration(swigCPtr, this, i), false);
  }

  /**
   *  Add an always-present rubber band line, modeled after the DecorativeLine <br>
   * supplied here. The end points of the supplied line are ignored, however: at <br>
   * run time the spatial locations of the two supplied stations are calculated and <br>
   * used as end points. <br>
   * @return An integer index you can use to find this rubber band line again. *
   */
  public int addRubberBandLine(int b1, Vec3 station1, int b2, Vec3 station2, DecorativeLine line) {
    return opensimSimbodyJNI.SimTKVisualizer_addRubberBandLine(swigCPtr, this, b1, Vec3.getCPtr(station1), station1, b2, Vec3.getCPtr(station2), station2, DecorativeLine.getCPtr(line), line);
  }

  /**
   *  Return the count of rubber band lines added with addRubberBandLine(). *
   */
  public int getNumRubberBandLines() {
    return opensimSimbodyJNI.SimTKVisualizer_getNumRubberBandLines(swigCPtr, this);
  }

  /**
   *  Return a const reference to the i'th rubber band line. *
   */
  public DecorativeLine getRubberBandLine(int i) {
    return new DecorativeLine(opensimSimbodyJNI.SimTKVisualizer_getRubberBandLine(swigCPtr, this, i), false);
  }

  /**
   *  Return a writable reference to the i'th rubber band line. This is allowed<br>
   * for a const %Visualizer since it is just a decoration. *
   */
  public DecorativeLine updRubberBandLine(int i) {
    return new DecorativeLine(opensimSimbodyJNI.SimTKVisualizer_updRubberBandLine(swigCPtr, this, i), false);
  }

  /**
   *  Add a DecorationGenerator that will be invoked to add dynamically generated<br>
   * geometry to each frame of the the scene. The Visualizer assumes ownership of the <br>
   * object passed to this method, and will delete it when the Visualizer is <br>
   * deleted. <br>
   * @return An integer index you can use to find this decoration generator <br>
   * again. *
   */
  public int addDecorationGenerator(SWIGTYPE_p_SimTK__DecorationGenerator generator) {
    return opensimSimbodyJNI.SimTKVisualizer_addDecorationGenerator(swigCPtr, this, SWIGTYPE_p_SimTK__DecorationGenerator.getCPtr(generator));
  }

  /**
   *  Return the count of decoration generators added with <br>
   * addDecorationGenerator(). *
   */
  public int getNumDecorationGenerators() {
    return opensimSimbodyJNI.SimTKVisualizer_getNumDecorationGenerators(swigCPtr, this);
  }

  /**
   *  Return a const reference to the i'th decoration generator. *
   */
  public SWIGTYPE_p_SimTK__DecorationGenerator getDecorationGenerator(int i) {
    return new SWIGTYPE_p_SimTK__DecorationGenerator(opensimSimbodyJNI.SimTKVisualizer_getDecorationGenerator(swigCPtr, this, i), false);
  }

  /**
   *  Return a writable reference to the i'th decoration generator. *
   */
  public SWIGTYPE_p_SimTK__DecorationGenerator updDecorationGenerator(int i) {
    return new SWIGTYPE_p_SimTK__DecorationGenerator(opensimSimbodyJNI.SimTKVisualizer_updDecorationGenerator(swigCPtr, this, i), false);
  }

  /**
   * ** Set the transform defining the position and orientation of the camera.<br>
   * <br>
   * @param X_GC   This is the transform giving the pose of the camera's <br>
   *                     frame C in the ground frame G; see below for a precise<br>
   *                     description.<br>
   * <br>
   * Our camera uses a right-handed frame with origin at the image location,<br>
   * with axes oriented as follows: the x axis is to the right, the y axis is the <br>
   * "up" direction, and the z axis is the "back" direction; that is, the camera is <br>
   * looking in the -z direction. If your simulation coordinate system is different,<br>
   * such as the common "virtual world" system where ground is the x-y plane <br>
   * (x right and y "in") and z is up, be careful to account for that when <br>
   * positioning the camera. <br>
   * <br>
   * For example, in the virtual world coordinate system, setting <i>X_GC</i> to <br>
   * identity would put the camera at the ground origin with the x axis as expected,<br>
   * but the camera would be looking down (your -z) with the camera's "up" direction<br>
   * aligned with your y. In this case to make the camera look in the y direction <br>
   * with up in z, you would need to rotate it +90 degrees about the x axis:<br>
   * {@code 
  Visualizer viz;
  ...
  
  Point camera along Ground's y axis with z up, by rotating the camera
  frame's z axis to align with Ground's -y.
  viz.setCameraTransform(Rotation(Pi/2, XAxis));
  } *
   */
  public SimTKVisualizer setCameraTransform(Transform X_GC) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setCameraTransform(swigCPtr, this, Transform.getCPtr(X_GC), X_GC), false);
  }

  /**
   *  Move the camera forward or backward so that all geometry in the scene is <br>
   * visible. *
   */
  public SimTKVisualizer zoomCameraToShowAllGeometry() {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_zoomCameraToShowAllGeometry(swigCPtr, this), false);
  }

  /**
   *  Rotate the camera so that it looks at a specified point.<br>
   * @param point        the point to look at<br>
   * @param upDirection  a direction which should point upward as seen by the camera
   */
  public SimTKVisualizer pointCameraAt(Vec3 point, Vec3 upDirection) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_pointCameraAt(swigCPtr, this, Vec3.getCPtr(point), point, Vec3.getCPtr(upDirection), upDirection), false);
  }

  /**
   *  Set the camera's vertical field of view, measured in radians. *
   */
  public SimTKVisualizer setCameraFieldOfView(double fov) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setCameraFieldOfView(swigCPtr, this, fov), false);
  }

  /**
   *  Set the distance from the camera to the near and far clipping planes. *
   */
  public SimTKVisualizer setCameraClippingPlanes(double nearPlane, double farPlane) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setCameraClippingPlanes(swigCPtr, this, nearPlane, farPlane), false);
  }

  /**
   *  Change the value currently shown on one of the sliders. <br>
   * @param slider       the id given to the slider when created<br>
   * @param value        a new value for the slider; if out of range it will <br>
   *                     be at one of the extremes *
   */
  public SimTKVisualizer setSliderValue(int slider, double value) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setSliderValue(swigCPtr, this, slider, value), false);
  }

  /**
   *  Change the allowed range for one of the sliders. <br>
   * @param slider   the id given to the slider when created<br>
   * @param newMin   the new lower limit on the slider range, &lt;= newMax   <br>
   * @param newMax   the new upper limit on the slider range, &gt;= newMin<br>
   * The slider's current value remains unchanged if it still fits in the<br>
   * new range, otherwise it is moved to the nearest limit. *
   */
  public SimTKVisualizer setSliderRange(int slider, double newMin, double newMax) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setSliderRange(swigCPtr, this, slider, newMin, newMax), false);
  }

  /**
   * ** Dump statistics to the given ostream (for example, std::cout). *
   */
  public void dumpStats(SWIGTYPE_p_std__ostream o) {
    opensimSimbodyJNI.SimTKVisualizer_dumpStats(swigCPtr, this, SWIGTYPE_p_std__ostream.getCPtr(o));
  }

  /**
   *  Reset all statistics to zero. *
   */
  public void clearStats() {
    opensimSimbodyJNI.SimTKVisualizer_clearStats(swigCPtr, this);
  }

  /**
   * **
   */
  public SWIGTYPE_p_SimTK__Array_T_SimTK__Visualizer__InputListener_p_unsigned_int_t getInputListeners() {
    return new SWIGTYPE_p_SimTK__Array_T_SimTK__Visualizer__InputListener_p_unsigned_int_t(opensimSimbodyJNI.SimTKVisualizer_getInputListeners(swigCPtr, this), false);
  }

  public SWIGTYPE_p_SimTK__Array_T_SimTK__Visualizer__FrameController_p_unsigned_int_t getFrameControllers() {
    return new SWIGTYPE_p_SimTK__Array_T_SimTK__Visualizer__FrameController_p_unsigned_int_t(opensimSimbodyJNI.SimTKVisualizer_getFrameControllers(swigCPtr, this), false);
  }

  public SWIGTYPE_p_SimTK__MultibodySystem getSystem() {
    return new SWIGTYPE_p_SimTK__MultibodySystem(opensimSimbodyJNI.SimTKVisualizer_getSystem(swigCPtr, this), false);
  }

  public int getRefCount() {
    return opensimSimbodyJNI.SimTKVisualizer_getRefCount(swigCPtr, this);
  }

  static public class FrameController {
    private transient long swigCPtr;
    protected transient boolean swigCMemOwn;
  
    public FrameController(long cPtr, boolean cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = cPtr;
    }
  
    public static long getCPtr(FrameController obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    public static long swigRelease(FrameController obj) {
      long ptr = 0;
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new RuntimeException("Cannot release ownership as memory is not owned");
        ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.delete();
      }
      return ptr;
    }
  
    @SuppressWarnings("deprecation")
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          opensimSimbodyJNI.delete_SimTKVisualizer_FrameController(swigCPtr);
        }
        swigCPtr = 0;
      }
    }
  
    /**
     *  The Visualizer is just about to generate and render a frame <br>
     *     corresponding to the given State. <br>
     *     @param viz     <br>
     *         The Visualizer that is doing the rendering.<br>
     *     @param state   <br>
     *         The State that is being used to generate the frame about to be<br>
     *         rendered by <i>viz</i>.<br>
     *     @param geometry <br>
     *         DecorativeGeometry being accumulated for rendering in this frame;<br>
     *         be sure to <i>append</i> if you have anything to add.
     */
    public void generateControls(SimTKVisualizer viz, State state, ArrayDecorativeGeometry geometry) {
      opensimSimbodyJNI.SimTKVisualizer_FrameController_generateControls(swigCPtr, this, SimTKVisualizer.getCPtr(viz), viz, State.getCPtr(state), state, ArrayDecorativeGeometry.getCPtr(geometry), geometry);
    }
  
  }

  static public class BodyFollower extends SimTKVisualizer.FrameController {
    private transient long swigCPtr;
  
    public BodyFollower(long cPtr, boolean cMemoryOwn) {
      super(opensimSimbodyJNI.SimTKVisualizer_BodyFollower_SWIGUpcast(cPtr), cMemoryOwn);
      swigCPtr = cPtr;
    }
  
    public static long getCPtr(BodyFollower obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    public static long swigRelease(BodyFollower obj) {
      long ptr = 0;
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new RuntimeException("Cannot release ownership as memory is not owned");
        ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.delete();
      }
      return ptr;
    }
  
    @SuppressWarnings("deprecation")
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          opensimSimbodyJNI.delete_SimTKVisualizer_BodyFollower(swigCPtr);
        }
        swigCPtr = 0;
      }
      super.delete();
    }
  
    /**
     *     @param mobodB<br>
     *        The MobilizedBody to follow, designated as B.<br>
     *     @param stationPinB<br>
     *        The location of the station P on the body to follow, expressed in B. By<br>
     *        default, P is the origin of the MobilizedBody.<br>
     *     @param offset<br>
     *        Position of the camera from P, expressed in ground. Cannot be the zero<br>
     *        vector. By default, this is (1, 1, 1) + h * u, where h is<br>
     *        Visualizer::getGroundHeight() and u is<br>
     *        Visualizer::getSystemUpDirection().<br>
     *     @param upDirection<br>
     *        Controls the rotation of the camera about the offset vector. The<br>
     *        camera's up (+y) direction will be aligned with this vector as best as<br>
     *        is possible. Expressed in ground. By default, this is<br>
     *        Visualizer::getSystemUpDirection(); it's unlikely that you want<br>
     *        something other than the default.
     */
    public BodyFollower(SWIGTYPE_p_SimTK__MobilizedBody mobodB, Vec3 stationPinB, Vec3 offset, UnitVec3 upDirection) {
      this(opensimSimbodyJNI.new_SimTKVisualizer_BodyFollower__SWIG_0(SWIGTYPE_p_SimTK__MobilizedBody.getCPtr(mobodB), Vec3.getCPtr(stationPinB), stationPinB, Vec3.getCPtr(offset), offset, UnitVec3.getCPtr(upDirection), upDirection), true);
    }
  
    /**
     *     @param mobodB<br>
     *        The MobilizedBody to follow, designated as B.<br>
     *     @param stationPinB<br>
     *        The location of the station P on the body to follow, expressed in B. By<br>
     *        default, P is the origin of the MobilizedBody.<br>
     *     @param offset<br>
     *        Position of the camera from P, expressed in ground. Cannot be the zero<br>
     *        vector. By default, this is (1, 1, 1) + h * u, where h is<br>
     *        Visualizer::getGroundHeight() and u is<br>
     *        Visualizer::getSystemUpDirection().<br>
     *     
     */
    public BodyFollower(SWIGTYPE_p_SimTK__MobilizedBody mobodB, Vec3 stationPinB, Vec3 offset) {
      this(opensimSimbodyJNI.new_SimTKVisualizer_BodyFollower__SWIG_1(SWIGTYPE_p_SimTK__MobilizedBody.getCPtr(mobodB), Vec3.getCPtr(stationPinB), stationPinB, Vec3.getCPtr(offset), offset), true);
    }
  
    /**
     *     @param mobodB<br>
     *        The MobilizedBody to follow, designated as B.<br>
     *     @param stationPinB<br>
     *        The location of the station P on the body to follow, expressed in B. By<br>
     *        default, P is the origin of the MobilizedBody.<br>
     *     
     */
    public BodyFollower(SWIGTYPE_p_SimTK__MobilizedBody mobodB, Vec3 stationPinB) {
      this(opensimSimbodyJNI.new_SimTKVisualizer_BodyFollower__SWIG_2(SWIGTYPE_p_SimTK__MobilizedBody.getCPtr(mobodB), Vec3.getCPtr(stationPinB), stationPinB), true);
    }
  
    /**
     *     @param mobodB<br>
     *        The MobilizedBody to follow, designated as B.<br>
     *     
     */
    public BodyFollower(SWIGTYPE_p_SimTK__MobilizedBody mobodB) {
      this(opensimSimbodyJNI.new_SimTKVisualizer_BodyFollower__SWIG_3(SWIGTYPE_p_SimTK__MobilizedBody.getCPtr(mobodB)), true);
    }
  
    public void generateControls(SimTKVisualizer viz, State state, ArrayDecorativeGeometry geometry) {
      opensimSimbodyJNI.SimTKVisualizer_BodyFollower_generateControls(swigCPtr, this, SimTKVisualizer.getCPtr(viz), viz, State.getCPtr(state), state, ArrayDecorativeGeometry.getCPtr(geometry), geometry);
    }
  
  }

  public SimTKVisualizer setBackgroundTypeByInt(int index) {
    return new SimTKVisualizer(opensimSimbodyJNI.SimTKVisualizer_setBackgroundTypeByInt(swigCPtr, this, index), false);
  }

  /**
   *  These are the operating modes for the Visualizer, with PassThrough the <br>
   * default mode. See the documentation for the Visualizer class for more<br>
   * information about the modes. *
   */
  public final static class Mode {
    /**
     *  Send through to the renderer every frame that is received from the<br>
     *     simulator (default mode). *
     */
    public final static SimTKVisualizer.Mode PassThrough = new SimTKVisualizer.Mode("PassThrough", opensimSimbodyJNI.SimTKVisualizer_PassThrough_get());
    /**
     *  Sample the results from the simulation at fixed real time intervals<br>
     *     given by the frame rate. *
     */
    public final static SimTKVisualizer.Mode Sampling = new SimTKVisualizer.Mode("Sampling", opensimSimbodyJNI.SimTKVisualizer_Sampling_get());
    /**
     *  Synchronize real frame display times with the simulated time. *
     */
    public final static SimTKVisualizer.Mode RealTime = new SimTKVisualizer.Mode("RealTime", opensimSimbodyJNI.SimTKVisualizer_RealTime_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static Mode swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + Mode.class + " with value " + swigValue);
    }

    private Mode(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private Mode(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private Mode(String swigName, Mode swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static Mode[] swigValues = { PassThrough, Sampling, RealTime };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  /**
   *  These are the types of backgrounds the visualizer currently supports.<br>
   * You can choose what type to use programmatically, and users can override that<br>
   * choice in the GUI. Each of these types may use additional data (such as the<br>
   * background color) when the type is selected. *
   */
  public final static class BackgroundType {
    /**
     *  Show a ground plane on which shadows may be cast, as well as a sky<br>
     *     in the far background. *
     */
    public final static SimTKVisualizer.BackgroundType GroundAndSky = new SimTKVisualizer.BackgroundType("GroundAndSky", opensimSimbodyJNI.SimTKVisualizer_GroundAndSky_get());
    /**
     *  Display a solid background color that has been provided elsewhere. *
     */
    public final static SimTKVisualizer.BackgroundType SolidColor = new SimTKVisualizer.BackgroundType("SolidColor", opensimSimbodyJNI.SimTKVisualizer_SolidColor_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static BackgroundType swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + BackgroundType.class + " with value " + swigValue);
    }

    private BackgroundType(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private BackgroundType(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private BackgroundType(String swigName, BackgroundType swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static BackgroundType[] swigValues = { GroundAndSky, SolidColor };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

  /**
   *  The visualizer may predefine some menus; if you need to refer to one<br>
   * of those use its menu Id as defined here. Note that the id numbers here<br>
   * are negative numbers, which are not allowed for user-defined menu ids. *
   */
  public final static class PredefinedMenuIds {
    /**
     *  The id of the predefined View pull-down. *
     */
    public final static SimTKVisualizer.PredefinedMenuIds ViewMenuId = new SimTKVisualizer.PredefinedMenuIds("ViewMenuId", opensimSimbodyJNI.SimTKVisualizer_ViewMenuId_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static PredefinedMenuIds swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + PredefinedMenuIds.class + " with value " + swigValue);
    }

    private PredefinedMenuIds(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private PredefinedMenuIds(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private PredefinedMenuIds(String swigName, PredefinedMenuIds swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static PredefinedMenuIds[] swigValues = { ViewMenuId };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

}
