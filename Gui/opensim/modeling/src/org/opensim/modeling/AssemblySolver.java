/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * Solve for the coordinates (degrees-of-freedom) of the model that satisfy the<br>
 * set of constraints imposed on the model as well as set of desired coordinate<br>
 * values.  The AssembleSolver provides the option to convert the problem to an <br>
 * approximate one where the constraint violations are treated as penalties to<br>
 * to be minimized rather than strictly enforced. This can speed up the time<br>
 * solution and can be used to seed the constrained problem near to a solution.<br>
 * <br>
 * The assembly objective: min A = sum(Wq_i*(q_i-qd_i)^2)) + [Wc*sum(c_err)^2]<br>
 * iff Wc == Infinity, second term is not included, but<br>
 *  A is subject to the constraint equations:  G(q)-Go = 0<br>
 * <br>
 * When the model (and the number of goals) is guaranteed not to change and the <br>
 * the initial state is close to the assembly solution (from initial assembly(),<br>
 * then track() is a efficient method for updating the configuration to track<br>
 * the small change to the desired coordinate value.<br>
 * <br>
 * See SimTK::Assembler for more algorithmic details of the underlying solver.<br>
 * <br>
 * @author Ajay Seth<br>
 * @version 1.0
 */
public class AssemblySolver extends Solver {
  private transient long swigCPtr;

  public AssemblySolver(long cPtr, boolean cMemoryOwn) {
    super(opensimSimulationJNI.AssemblySolver_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(AssemblySolver obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(AssemblySolver obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_AssemblySolver(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static AssemblySolver safeDownCast(OpenSimObject obj) {
    long cPtr = opensimSimulationJNI.AssemblySolver_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new AssemblySolver(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimSimulationJNI.AssemblySolver_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimSimulationJNI.AssemblySolver_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.AssemblySolver_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new AssemblySolver(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.AssemblySolver_getConcreteClassName(swigCPtr, this);
  }

  /**
   *  Construct an Assembly solver with the coordinate references as the goal<br>
   *         of the assembly and (optional)constraint weight. Default is infinity<br>
   *         constraint weighting (i.e. rigidly enforced) during assembly. 
   */
  public AssemblySolver(Model model, SimTKArrayCoordinateReference coordinateReferences, double constraintWeight) {
    this(opensimSimulationJNI.new_AssemblySolver__SWIG_0(Model.getCPtr(model), model, SimTKArrayCoordinateReference.getCPtr(coordinateReferences), coordinateReferences, constraintWeight), true);
  }

  /**
   *  Construct an Assembly solver with the coordinate references as the goal<br>
   *         of the assembly and (optional)constraint weight. Default is infinity<br>
   *         constraint weighting (i.e. rigidly enforced) during assembly. 
   */
  public AssemblySolver(Model model, SimTKArrayCoordinateReference coordinateReferences) {
    this(opensimSimulationJNI.new_AssemblySolver__SWIG_1(Model.getCPtr(model), model, SimTKArrayCoordinateReference.getCPtr(coordinateReferences), coordinateReferences), true);
  }

  /**
   *  %Set the unitless accuracy of the assembly solution, which dictates<br>
   *         the number of significant digits the solution should be resolved to.<br>
   *         Note, setting the accuracy will invalidate the AssemblySolver and one<br>
   *         must call assemble() before being able to track().
   */
  public void setAccuracy(double accuracy) {
    opensimSimulationJNI.AssemblySolver_setAccuracy(swigCPtr, this, accuracy);
  }

  /**
   *  %Set the relative weighting for constraints. Use Infinity to identify the <br>
   *         strict enforcement of constraints, otherwise any positive weighting will<br>
   *         append the constraint errors to the assembly cost which the solver will<br>
   *         minimize.
   */
  public void setConstraintWeight(double weight) {
    opensimSimulationJNI.AssemblySolver_setConstraintWeight(swigCPtr, this, weight);
  }

  /**
   *  Specify which coordinates to match, each with a desired value and a<br>
   *         relative weighting. 
   */
  public SimTKArrayCoordinateReference getCoordinateReferences() {
    return new SimTKArrayCoordinateReference(opensimSimulationJNI.AssemblySolver_getCoordinateReferences(swigCPtr, this), false);
  }

  /**
   *  Once a set of coordinates has been specified its reference value and <br>
   *         weight can be updated directly 
   */
  public void updateCoordinateReference(String coordName, double value, double weight) {
    opensimSimulationJNI.AssemblySolver_updateCoordinateReference__SWIG_0(swigCPtr, this, coordName, value, weight);
  }

  /**
   *  Once a set of coordinates has been specified its reference value and <br>
   *         weight can be updated directly 
   */
  public void updateCoordinateReference(String coordName, double value) {
    opensimSimulationJNI.AssemblySolver_updateCoordinateReference__SWIG_1(swigCPtr, this, coordName, value);
  }

  /**
   *  Assemble a model configuration that meets the assembly conditions <br>
   *         (desired values and constraints) and accuracy, starting from an initial<br>
   *         state that does not have to satisfy the constraints. 
   */
  public void assemble(State s) {
    opensimSimulationJNI.AssemblySolver_assemble(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Obtain a model configuration that meets the assembly conditions <br>
   *         (desired values and constraints) given a state that satisfies or<br>
   *         is close to satisfying the constraints. Note there can be no change<br>
   *         in the number of constraints or desired coordinates. Desired<br>
   *         coordinate values can and should be updated between repeated calls<br>
   *         to track a desired trajectory of coordinate values. Use assemble()<br>
   *         first to obtain the first solution and use track() to efficiently<br>
   *         find a nearby solution due to a small change in the desired value.
   */
  public void track(State s) {
    opensimSimulationJNI.AssemblySolver_track(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Read access to the underlying SimTK::Assembler. 
   */
  public SWIGTYPE_p_SimTK__Assembler getAssembler() {
    return new SWIGTYPE_p_SimTK__Assembler(opensimSimulationJNI.AssemblySolver_getAssembler(swigCPtr, this), false);
  }

}
