/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

public class TableUtilities {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public TableUtilities(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(TableUtilities obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(TableUtilities obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimCommonJNI.delete_TableUtilities(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Throws an exception if the same label appears more than once in the list<br>
   *  of labels.<br>
   *  @throws NonUniqueLabels
   */
  public static void checkNonUniqueLabels(StdVectorString labels) {
    opensimCommonJNI.TableUtilities_checkNonUniqueLabels(StdVectorString.getCPtr(labels), labels);
  }

  /**
   *  Returns true if the table contains 'inDegrees' metadata set to 'yes',<br>
   *  and returns false if the table contains 'inDegrees' metadata set to<br>
   *  'no'.<br>
   *  @throws Exception if table does not have 'inDegrees' table metadata.<br>
   *  @throws Exception if the 'inDegrees' metadata is neither 'yes' or 'no'.
   */
  public static boolean isInDegrees(TimeSeriesTable table) {
    return opensimCommonJNI.TableUtilities_isInDegrees(TimeSeriesTable.getCPtr(table), table);
  }

  /**
   *  Get the index in the provided array of labels that corresponds to the<br>
   *  desired label. This function attempts to handle the change in<br>
   *  state variable names that occurred in OpenSim version 4.0; for example,<br>
   *  if you search for `&lt;coord-name&gt;/speed` and it is not found, then this<br>
   *  function looks for `&lt;coord-name&gt;_u`. If you search for<br>
   *  `&lt;muscle&gt;/activation` and it is not found, then this function looks for<br>
   *  `&lt;muscle&gt;.activation`. This function returns -1 if the desired label is<br>
   *  not found.
   */
  public static int findStateLabelIndex(ArrayStr labels, String desired) {
    return opensimCommonJNI.TableUtilities_findStateLabelIndex__SWIG_0(ArrayStr.getCPtr(labels), labels, desired);
  }

  /**
   *  
   */
  public static int findStateLabelIndex(StdVectorString labels, String desired) {
    return opensimCommonJNI.TableUtilities_findStateLabelIndex__SWIG_1(StdVectorString.getCPtr(labels), labels, desired);
  }

  /**
   * Applies a lowpass filter to the data in a TimeSeriesTable at a<br>
   * specified cutoff frequency.<br>
   * <br>
   * This function first checks if the provided cutoff frequency is<br>
   * non-negative. If the `padData` parameter is set to true, the data is<br>
   * mirror padded using the `pad()` function.<br>
   * The amount of padding is half the number of rows in the table on each side.<br>
   * In other words, using numRowsToPrependAndAppend = table.getNumRows() / 2.<br>
   * This will make the resulting data twice as long as the original and may <br>
   * include "negative" time if the original independent (time) column began at 0.<br>
   * <br>
   * The function then verifies that the number of rows in the table is at<br>
   * least 4, as filtering requires a minimum amount of data. It retrieves the<br>
   * independent time column and checks if the time samples are uniformly<br>
   * spaced. If the time intervals are not uniform, the data is resampled to<br>
   * ensure consistent sampling before applying the lowpass filter. <br>
   * See `CommonUtilities.h` for more information on how the uniform sampling <br>
   * is calculated to determine if the data should be resampled.<br>
   * <br>
   * The filtering is performed using the `Signal::LowpassIIR()` method, which<br>
   * processes each dependent column of the table with the specified cutoff<br>
   * frequency and the determined sampling interval.<br>
   * <br>
   * @param table A reference to the TimeSeriesTable containing the data to be<br>
   * filtered.<br>
   * @param cutoffFreq The cutoff frequency for the lowpass filter. Must be<br>
   * non-negative.<br>
   * @param padData A boolean indicating whether to pad the data before<br>
   * filtering.<br>
   * <br>
   * @throws Exception if the cutoff frequency is negative, if the number of<br>
   * rows is less than 4, or if the time intervals are not suitable for<br>
   * resampling.
   */
  public static void filterLowpass(TimeSeriesTable table, double cutoffFreq, boolean padData) {
    opensimCommonJNI.TableUtilities_filterLowpass__SWIG_0(TimeSeriesTable.getCPtr(table), table, cutoffFreq, padData);
  }

  /**
   * Applies a lowpass filter to the data in a TimeSeriesTable at a<br>
   * specified cutoff frequency.<br>
   * <br>
   * This function first checks if the provided cutoff frequency is<br>
   * non-negative. If the `padData` parameter is set to true, the data is<br>
   * mirror padded using the `pad()` function.<br>
   * The amount of padding is half the number of rows in the table on each side.<br>
   * In other words, using numRowsToPrependAndAppend = table.getNumRows() / 2.<br>
   * This will make the resulting data twice as long as the original and may <br>
   * include "negative" time if the original independent (time) column began at 0.<br>
   * <br>
   * The function then verifies that the number of rows in the table is at<br>
   * least 4, as filtering requires a minimum amount of data. It retrieves the<br>
   * independent time column and checks if the time samples are uniformly<br>
   * spaced. If the time intervals are not uniform, the data is resampled to<br>
   * ensure consistent sampling before applying the lowpass filter. <br>
   * See `CommonUtilities.h` for more information on how the uniform sampling <br>
   * is calculated to determine if the data should be resampled.<br>
   * <br>
   * The filtering is performed using the `Signal::LowpassIIR()` method, which<br>
   * processes each dependent column of the table with the specified cutoff<br>
   * frequency and the determined sampling interval.<br>
   * <br>
   * @param table A reference to the TimeSeriesTable containing the data to be<br>
   * filtered.<br>
   * @param cutoffFreq The cutoff frequency for the lowpass filter. Must be<br>
   * non-negative.<br>
   * <br>
   * <br>
   * @throws Exception if the cutoff frequency is negative, if the number of<br>
   * rows is less than 4, or if the time intervals are not suitable for<br>
   * resampling.
   */
  public static void filterLowpass(TimeSeriesTable table, double cutoffFreq) {
    opensimCommonJNI.TableUtilities_filterLowpass__SWIG_1(TimeSeriesTable.getCPtr(table), table, cutoffFreq);
  }

  /**
   *  Pad each column by the number of rows specified. The padded data is<br>
   *  obtained by reflecting and negating the data in the table.<br>
   *  Postcondition: the number of rows is table.getNumRows() + 2 *<br>
   *  numRowsToPrependAndAppend.
   */
  public static void pad(TimeSeriesTable table, int numRowsToPrependAndAppend) {
    opensimCommonJNI.TableUtilities_pad(TimeSeriesTable.getCPtr(table), table, numRowsToPrependAndAppend);
  }

  public static TimeSeriesTableVec3 convertRotationsToEulerAngles(SWIGTYPE_p_OpenSim__TimeSeriesTable_T_SimTK__Rotation_T_SimTK__Real_t_t rotTable) {
    return new TimeSeriesTableVec3(opensimCommonJNI.TableUtilities_convertRotationsToEulerAngles(SWIGTYPE_p_OpenSim__TimeSeriesTable_T_SimTK__Rotation_T_SimTK__Real_t_t.getCPtr(rotTable)), true);
  }

  public TableUtilities() {
    this(opensimCommonJNI.new_TableUtilities(), true);
  }

}
