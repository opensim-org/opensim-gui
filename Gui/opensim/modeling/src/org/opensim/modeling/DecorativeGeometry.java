/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  This is the client-side interface to an implementation-independent<br>
 * representation of "Decorations" suitable for visualization, annotation,<br>
 * logging, or debugging but which cannot have any effect on the behavior of<br>
 * a System or the evolution of a Study. DO NOT confuse this with real geometry <br>
 * (like contact geometry) which can represent physically meaningful objects that <br>
 * may interact and change the behavior of a System. However, all geometry objects<br>
 * can generate %DecorativeGeometry for their visualization.<br>
 * <br>
 * Why is there a %DecorativeGeometry facility at the System level at all, so far <br>
 * away from any application program? That's because for crude visualization and <br>
 * debugging purposes, the Subsystems themselves are best able to produce some <br>
 * illustrative geometry. Otherwise, you need a special purpose visualization <br>
 * tool which understands what's going on inside each subsystem. If you don't mind<br>
 * taking what you get, just ask each subsystem to generate what it thinks would <br>
 * be helpful visualization. To do that, the subysystems need a way to talk about <br>
 * geometry without knowing anything about how that geometry will eventually get <br>
 * onto someone's screen. And that's why we're here!<br>
 * <br>
 * Each %DecorativeGeometry object has its own local coordinate system and is <br>
 * defined self-consistently but independent of anything else. Clients can <br>
 * associate these with a reference frame (e.g. a body), and place the local frame<br>
 * of the geometry objects on the reference frame, or at a fixed transform from <br>
 * the reference frame. That places the %DecorativeGeometry objects in a scene. We<br>
 * support both 3D objects which are attached to actors in the scene, and 2D <br>
 * "screen" objects like titles which are attached to the display rather than the <br>
 * actors. The classes here deal only with the local-frame definitions of the <br>
 * geometric objects, not their placement in the scene. <br>
 * <br>
 * This is an abstract handle class using the PIMPL design pattern to hide the<br>
 * private implementation. This is effectively an abstract class although the <br>
 * virtual function table is hidden in the private part. *
 */
public class DecorativeGeometry {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public DecorativeGeometry(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(DecorativeGeometry obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(DecorativeGeometry obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimbodyJNI.delete_DecorativeGeometry(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Default constructor creates an empty handle. *
   */
  public DecorativeGeometry() {
    this(opensimSimbodyJNI.new_DecorativeGeometry__SWIG_0(), true);
  }

  /**
   *  Copy construction is deep; the source object will be cloned to create an<br>
   * independent copy. *
   */
  public DecorativeGeometry(DecorativeGeometry source) {
    this(opensimSimbodyJNI.new_DecorativeGeometry__SWIG_1(DecorativeGeometry.getCPtr(source), source), true);
  }

  /**
   *  By default the geometry should be placed relative to the Ground frame. If <br>
   * you want it attached to another reference frame (body), say so here. The <br>
   * geometry should be rendered with respect to the indicated body frame; however, <br>
   * the interpretation of this integer Id is left to the implementation. If you <br>
   * don't set the <i>bodyId</i> yourself it will be zero. For use in Simbody, the <br>
   * <i>bodyId</i> is interpreted as a MobilizedBodyIndex that can be mapped to a <br>
   * MobilizedBody that carries a reference frame. <br>
   * <br>
   * The <i>bodyId</i> is copied if you copy the %DecorativeGeometry object. If you are<br>
   * copying to a different body you'll need to change the bodyId afterwards. *
   */
  public DecorativeGeometry setBodyId(int bodyId) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setBodyId(swigCPtr, this, bodyId), false);
  }

  /**
   *  For selection or other purposes, you may want to use this method to store<br>
   * an index that can identify this particular piece of geometry. As an alternative,<br>
   * or addition, see setUserRef(). In any case the <i>index</i> is simply stored with <br>
   * the object and returned if you ask for it. If you don't set it the value <br>
   * is -1. The <i>index</i> is copied if you copy the %DecorativeGeometry object. Be<br>
   * sure to change it afterwards if that is not the correct index for the copy. <br>
   * Simbody sets this index when %DecorativeGeometry is added to a Body. *
   */
  public DecorativeGeometry setIndexOnBody(int index) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setIndexOnBody(swigCPtr, this, index), false);
  }

  /**
   *  Use this method to store an arbitrary reference pointer with this <br>
   * %DecorativeGeometry object. This is particularly useful in selection operations<br>
   * where the rendering of this object has been picked by a user and you want to<br>
   * map it back to some meaningful object in your model. You can also use the<br>
   * setIndexOnBody() method to store some additional identifying information. <br>
   * If you don't set this pointer it will be set to zero (nullptr). This value<br>
   * is stored and returned only; no interpretation is done and the pointed-to<br>
   * object will not be deleted when the %DecorativeGeometry object is deleted. <br>
   * <br>
   * Warning: The value of the <i>userRef</i> pointer is copied if you make a copy of the <br>
   * %DecorativeGeometry object. That is likely to be incorrect in many <br>
   * circumstances, depending on how you are using this value. Be sure to clear or <br>
   * change the pointer if necessary after you make a copy. *
   */
  public DecorativeGeometry setUserRef(SWIGTYPE_p_void userRef) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setUserRef(swigCPtr, this, SWIGTYPE_p_void.getCPtr(userRef)), false);
  }

  /**
   *  This transform shifts the generated polygons with respect to this object's<br>
   * local frame. Subsequent calls with other transforms simply replace the earlier<br>
   * one; they do not accumulate. The default transform is identity and you can call<br>
   * setTransform(Transform()) to put the transform back into its original state.<br>
   * This value affects the generated polygonal data. *
   */
  public DecorativeGeometry setTransform(Transform X_BG) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setTransform(swigCPtr, this, Transform.getCPtr(X_BG), X_BG), false);
  }

  /**
   *  Each concrete %DecorativeGeometry object is expected to have a default <br>
   * resolution that gets the point across but is cheap to draw and hence probably <br>
   * somewhat "chunky". The resolution parameter here scales that default up or <br>
   * down. The face density in the displayed representation is roughly <br>
   * proportional to this value. 1.0 means to use the default resolution. Values <br>
   * less than 1.0 are lower resolution, and values greater than 1.0 are higher <br>
   * resolution. A value less than or equal to zero here is interpreted as an <br>
   * instruction to "use the default". *
   */
  public DecorativeGeometry setResolution(double arg0) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setResolution(swigCPtr, this, arg0), false);
  }

  /**
   *  Each concrete DecorativeGeometry object is expected to have a default size<br>
   * around "1", whatever that means for a particular object, and most objects also<br>
   * allow a user-specified size on construction. The x,y,z scale factors here are<br>
   * given in the object's coordinate frame, and apply to the object as the user <br>
   * built it, or to the default if the user didn't specify a size. The default <br>
   * scaling is 1,1,1 and any value less than or equal to zero here is interpreted <br>
   * as a request to "use the default" in that direction. *
   */
  public DecorativeGeometry setScaleFactors(Vec3 scale) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setScaleFactors(swigCPtr, this, Vec3.getCPtr(scale), scale), false);
  }

  /**
   *  Convenience method to set all three scale factors to the same value. *
   */
  public DecorativeGeometry setScale(double scale) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setScale(swigCPtr, this, scale), false);
  }

  /**
   *  Return the <i>bodyId</i> that was supplied to the most recent setBodyId() <br>
   * call for this %DecorativeGeometry object, or zero if that method has not been<br>
   * called. Copy construction and copy assignment copy the <i>bodyId</i>. This is<br>
   * intended to identify the body frame to which this geometry's placement should be<br>
   * relative; with the default zero value meaning the Ground or World frame. *
   */
  public int getBodyId() {
    return opensimSimbodyJNI.DecorativeGeometry_getBodyId(swigCPtr, this);
  }

  /**
   *  Return the <i>index</i> that was supplied to the most recent setIndexOnBody() <br>
   * call for this %DecorativeGeometry object, or -1 if that method has not been<br>
   * called. Copy construction and copy assignment copy the <i>index</i>. Interpretation <br>
   * of this integer is up to the caller. *
   */
  public int getIndexOnBody() {
    return opensimSimbodyJNI.DecorativeGeometry_getIndexOnBody(swigCPtr, this);
  }

  /**
   *  Return the pointer value that was supplied to the most recent setUserRef()<br>
   * call for this %DecorativeGeometry object, or zero (nullptr) if that method has<br>
   * not been called. Copy construction and copy assignment copy the pointer. <br>
   * Interpretation of this value is up to the caller. *
   */
  public SWIGTYPE_p_void getUserRef() {
    long cPtr = opensimSimbodyJNI.DecorativeGeometry_getUserRef(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_void(cPtr, false);
  }

  /**
   *  Return the current setting of the "resolution" factor. A return value of<br>
   * -1 means "use the default". *
   */
  public double getResolution() {
    return opensimSimbodyJNI.DecorativeGeometry_getResolution(swigCPtr, this);
  }

  /**
   *  Return the current value of the object's transform. If none has been set <br>
   * this will be the identity transform. Note that this transform specifies how the<br>
   * polygons are placed with respect to the object's local frame. *
   */
  public Transform getTransform() {
    return new Transform(opensimSimbodyJNI.DecorativeGeometry_getTransform(swigCPtr, this), false);
  }

  /**
   *  Return the current setting of the "scale" factors. A return value of -1 <br>
   * in one of the factors means to "use the default" (which is typically 1) in<br>
   * that direction. *
   */
  public Vec3 getScaleFactors() {
    return new Vec3(opensimSimbodyJNI.DecorativeGeometry_getScaleFactors(swigCPtr, this), false);
  }

  /**
   *  Request a specific color for this DecorativeGeometry object. The default <br>
   * is that the color is determined elsewhere. To explicitly request the default,<br>
   * set the color to Vec3(-1). The implementation will check the 0'th element<br>
   * (that is, the "R" element) and if it is less than zero will ignore the other<br>
   * two elements and use the default for all three. *
   */
  public DecorativeGeometry setColor(Vec3 rgb) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setColor(swigCPtr, this, Vec3.getCPtr(rgb), rgb), false);
  }

  /**
   *  Request a level of transparency for this DecorativeGeometry. This does NOT<br>
   * affect the generated geometry here. The default is that opacity is <br>
   * determined elsewhere. *
   */
  public DecorativeGeometry setOpacity(double arg0) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setOpacity(swigCPtr, this, arg0), false);
  }

  /**
   *  Request an adjustment to the default rendering of lines and curves. This <br>
   * does NOT affect geometry generated here; it is a request passed on to the<br>
   * renderer which will probably pass it on to the hardware. A value less<br>
   * than or equal to zero here is interpreted as "use the default". *
   */
  public DecorativeGeometry setLineThickness(double arg0) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setLineThickness(swigCPtr, this, arg0), false);
  }

  /**
   *  Return the color specified for this object, if any, otherwise Vec3(-1)<br>
   * indicating that the default color will be used. *
   */
  public Vec3 getColor() {
    return new Vec3(opensimSimbodyJNI.DecorativeGeometry_getColor(swigCPtr, this), false);
  }

  /**
   *  Return the opacity specified for this object. *
   */
  public double getOpacity() {
    return opensimSimbodyJNI.DecorativeGeometry_getOpacity(swigCPtr, this);
  }

  /**
   *  Return the line thickness specified for this object, if any, otherwise<br>
   * return -1 to indicate that the default line thickness should be used. *
   */
  public double getLineThickness() {
    return opensimSimbodyJNI.DecorativeGeometry_getLineThickness(swigCPtr, this);
  }

  /**
   *  Set whether the geometry acts as a billboard, always rotating to face the <br>
   * camera. The default is typically no except for text. If you want 3D text that<br>
   * moves with your model, set this to false. Here 0 means false, 1 means true,<br>
   * and -1 means "use default". *
   */
  public DecorativeGeometry setFaceCamera(int shouldFace) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setFaceCamera(swigCPtr, this, shouldFace), false);
  }

  /**
   *  Get whether the geometry acts as a billboard, always rotating to face the <br>
   * camera. Returns 0 for no, 1 for yes, -1 for "is using default". *
   */
  public int getFaceCamera() {
    return opensimSimbodyJNI.DecorativeGeometry_getFaceCamera(swigCPtr, this);
  }

  /**
   *  Request a particular rendering representation of this DecorativeGeometry<br>
   * object. The default is that the rendering representation choice is made <br>
   * elsewhere. *
   */
  public DecorativeGeometry setRepresentation(DecorativeGeometry.Representation arg0) {
    return new DecorativeGeometry(opensimSimbodyJNI.DecorativeGeometry_setRepresentation(swigCPtr, this, arg0.swigValue()), false);
  }

  /**
   *  Returns drawing mode: -1 means "use default"; see above for others. *
   */
  public DecorativeGeometry.Representation getRepresentation() {
    return DecorativeGeometry.Representation.swigToEnum(opensimSimbodyJNI.DecorativeGeometry_getRepresentation(swigCPtr, this));
  }

  public void implementGeometry(DecorativeGeometryImplementation arg0) {
    opensimSimbodyJNI.DecorativeGeometry_implementGeometry(swigCPtr, this, DecorativeGeometryImplementation.getCPtr(arg0), arg0);
  }

  public boolean isOwnerHandle() {
    return opensimSimbodyJNI.DecorativeGeometry_isOwnerHandle(swigCPtr, this);
  }

  public boolean isEmptyHandle() {
    return opensimSimbodyJNI.DecorativeGeometry_isEmptyHandle(swigCPtr, this);
  }

  public DecorativeGeometry(SWIGTYPE_p_DecorativeGeometryRep r) {
    this(opensimSimbodyJNI.new_DecorativeGeometry__SWIG_2(SWIGTYPE_p_DecorativeGeometryRep.getCPtr(r)), true);
  }

  public boolean hasRep() {
    return opensimSimbodyJNI.DecorativeGeometry_hasRep(swigCPtr, this);
  }

  public SWIGTYPE_p_DecorativeGeometryRep getRep() {
    return new SWIGTYPE_p_DecorativeGeometryRep(opensimSimbodyJNI.DecorativeGeometry_getRep(swigCPtr, this), false);
  }

  public SWIGTYPE_p_DecorativeGeometryRep updRep() {
    return new SWIGTYPE_p_DecorativeGeometryRep(opensimSimbodyJNI.DecorativeGeometry_updRep(swigCPtr, this), false);
  }

  public boolean hasUserRef() {
    return opensimSimbodyJNI.DecorativeGeometry_hasUserRef(swigCPtr, this);
  }

  public SWIGTYPE_p_OpenSim__Object getUserRefAsObject() {
    return new SWIGTYPE_p_OpenSim__Object(opensimSimbodyJNI.DecorativeGeometry_getUserRefAsObject(swigCPtr, this), false);
  }

  /**
   *  Drawing modes. *
   */
  public final static class Representation {
    /**
     *  hide geometry for now to display later
     */
    public final static DecorativeGeometry.Representation Hide = new DecorativeGeometry.Representation("Hide", opensimSimbodyJNI.DecorativeGeometry_Hide_get());
    /**
     *  Use a cloud of points.
     */
    public final static DecorativeGeometry.Representation DrawPoints = new DecorativeGeometry.Representation("DrawPoints", opensimSimbodyJNI.DecorativeGeometry_DrawPoints_get());
    /**
     *  Use a line drawing.
     */
    public final static DecorativeGeometry.Representation DrawWireframe = new DecorativeGeometry.Representation("DrawWireframe", opensimSimbodyJNI.DecorativeGeometry_DrawWireframe_get());
    /**
     *  Use a shaded surface.
     */
    public final static DecorativeGeometry.Representation DrawSurface = new DecorativeGeometry.Representation("DrawSurface", opensimSimbodyJNI.DecorativeGeometry_DrawSurface_get());
    /**
     *  Let someone else decide.
     */
    public final static DecorativeGeometry.Representation DrawDefault = new DecorativeGeometry.Representation("DrawDefault", opensimSimbodyJNI.DecorativeGeometry_DrawDefault_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static Representation swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + Representation.class + " with value " + swigValue);
    }

    private Representation(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private Representation(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private Representation(String swigName, Representation swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static Representation[] swigValues = { Hide, DrawPoints, DrawWireframe, DrawSurface, DrawDefault };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

}
