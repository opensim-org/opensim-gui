/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for <br>
 * the C++ standard template library (STL) std::vector&lt;T&gt; class, but with some<br>
 * important advantages in performance, and functionality, and binary <br>
 * compatibility.<br>
 * <br>
 * <br>
 * <br>
 * <p alt="Performance:"><br>
 * There are several performance and memory footprint problems with the C++ <br>
 * standard STL design in general, and with Microsoft's implementation in <br>
 * particular, that are addressed here. Microsoft in its wisdom decided that STL <br>
 * containers should still do runtime range checks in Release builds for safety, <br>
 * but that makes them too slow for use in some high-performance contexts (and <br>
 * also breaks the promise of generic programming but that's another rant). In <br>
 * practice, VC++9 std::vector runs about half speed for simple operations like <br>
 * indexing and push_back. Attempting to disable these runtime checks with <br>
 * _SECURE_SCL breaks binary compatibility. In contrast the performance of this <br>
 * Array_&lt;T&gt; class on any platform is indistinguishable from what you would get <br>
 * by managing your own heap-allocated arrays.</p><br>
 * <br>
 * <p alt="">Regarding memory footprint, the typical implementation of std::vector uses<br>
 * three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines.<br>
 * Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit<br>
 * machine -- I don't know what they do on a 64 bit machine but I'm not <br>
 * optimistic! Array_ instead uses one pointer and two lengths for a total size <br>
 * as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details.</p><br>
 * <br>
 * <p alt="">Some nuts and bolts:</p><br>
 * <br>
 * - We promise that no heap allocation occurs when an empty Array_&lt;T&gt; object <br>
 *   is declared (that is, when an Array_&lt;T&gt; is default-constructed); in<br>
 *   that case both begin() and end() are null.<br>
 * - Array_&lt;T&gt; methods are extremely fast in Release builds with zero overhead, <br>
 *   inline, unchecked methods. The implementations of inline methods are kept<br>
 *   small to ensure that they are actually inlined in practice; and generated <br>
 *   assembly code was examined to make sure.<br>
 * - There are some dangerous extensions provided that permit the expert user<br>
 *   to construct objects directly into the array without having to copy them,<br>
 *   a big win for complicated objects and even bigger for those that don't<br>
 *   have copy constructors!<br>
 * - There is a constant-time eraseFast() method you can use if you don't mind the<br>
 *   array being reordered after the erase. This avoids the extremely expensive<br>
 *   "compress" activity required by the standard erase() method.<br>
 * - The optional index-type template parameter can be used to reduce the memory<br>
 *   footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit <br>
 *   pointer and two shorts).<br>
 * - The default size_type for an Array_&lt;T&gt; is a 32-bit unsigned integer rather <br>
 *   than a size_t. On a 64-bit machine that keeps the overhead down substantially<br>
 *   since the structure is then one 64-bit pointer and two 32-bit integers, <br>
 *   fitting tightly into a cleanly alignable 16 bytes.<br>
 * <br>
 * <br>
 * <p alt="Functionality:"><br>
 * For the most part Array_&lt;T&gt; is a plug-compatible replacement for std::vector&lt;T&gt;,<br>
 * and everything that both classes can do is done with an identical API. However,<br>
 * there are a few additions and subtractions:</p><br>
 * <br>
 * - This class always uses the default new/delete allocator; there is no option<br>
 *   to specify your own as there is in std::vector.<br>
 * - Instead of an allocator, the second template argument X to Array_&lt;T,X&gt; is an <br>
 *   optional index type which can be used to provide type-safe indexing (i.e. the<br>
 *   array can only be indexed by indices of a particular type, like <br>
 *   MobilizedBodyIndex). This has zero performance cost if the index is an <br>
 *   integral type or class consisting of only an integral value such as those<br>
 *   produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.<br>
 * - You can create uninitialized slots in the array and construct directly into<br>
 *   them rather than having to construct a temporary object which must then be<br>
 *   copied into the array.<br>
 * - You can create Array_&lt;T&gt; objects that reference existing data, including<br>
 *   the contents of std::vectors.<br>
 * - Where possible this class implements the new std::vector features proposed<br>
 *   for the C++0x standard (see below).<br>
 * <br>
 * <p alt="Compatibility:"><br>
 * Included here are binary compatibility issues and compatibility with the C++<br>
 * standard STL objects.</p><br>
 * <br>
 * - Most important, it is safe to pass an Array_&lt;T&gt; through an API to a binary <br>
 *   library without worrying about compiler version or Release/Debug compatibility<br>
 *   issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit<br>
 *   vs. 32 bit), Array_&lt;T&gt; has an extremely stable memory layout that is preserved <br>
 *   across compiler versions, and between Release and Debug builds. This allows us<br>
 *   to use Array_&lt;T&gt; in the SimTK API where use of std::vector&lt;T&gt; would be <br>
 *   desirable but problematic.<br>
 * - It supports all standard types, methods, iterators, and operators of the <br>
 *   C++98 standard std::vector and the C++0x proposed improvements other than<br>
 *   those requiring rvalue references, so it works smoothly with all STL <br>
 *   containers and algorithms.<br>
 * - It is convertible to and from std::vector, usually without copying the <br>
 *   elements. It is easy to provide APIs that accept either Array_&lt;T&gt; or <br>
 *   std::vector&lt;T&gt;; the std::vector's data is referenced by an Array_ handle<br>
 *   that is used to convey the data across the API without binary compatibility<br>
 *   problems.<br>
 * <br>
 * @see Array_, ArrayViewConst_, ArrayIndexTraits *
 */
public class SimTKArrayInt {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public SimTKArrayInt(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(SimTKArrayInt obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimbodyJNI.delete_SimTKArrayInt(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Default constructor allocates no heap space and is very fast. *
   */
  public SimTKArrayInt() {
    this(opensimSimbodyJNI.new_SimTKArrayInt__SWIG_0(), true);
  }

  /**
   *  Construct an array containing <i>n</i> default-constructed elements. T's default <br>
   * constructor (if any) is called exactly <i>n</i> times. If <i>n</i> is zero no heap space <br>
   * will be allocated; although in that case it is preferable to use the default <br>
   * constructor if you can since that will be somewhat faster. *
   */
  public SimTKArrayInt(long n) {
    this(opensimSimbodyJNI.new_SimTKArrayInt__SWIG_1(n), true);
  }

  /**
   *  Construct an array containing <i>n</i> elements each set to a copy of the given <br>
   * initial value. T's copy constructor will be called exactly <i>n</i> times. If <i>n</i><br>
   * is zero no space will be allocated. *
   */
  public SimTKArrayInt(long n, int initVal) {
    this(opensimSimbodyJNI.new_SimTKArrayInt__SWIG_2(n, initVal), true);
  }

  /**
   *  Copy constructor allocates exactly as much memory as is in use in the <br>
   * source (not its capacity) and copy constructs the elements so that T's copy <br>
   * constructor will be called exactly src.size() times. If the source is empty, <br>
   * no heap space will be allocated. *
   */
  public SimTKArrayInt(SimTKArrayInt src) {
    this(opensimSimbodyJNI.new_SimTKArrayInt__SWIG_3(SimTKArrayInt.getCPtr(src), src), true);
  }

  /**
   *  Construct an Array_&lt;T&gt; by referencing (sharing) a given range of data<br>
   * [first,last1), without copying that data; better to use the corresponding<br>
   * ArrayView_&lt;T&gt; constructor if you can. This is very fast but can be <br>
   * dangerous -- it is most useful for argument passing where the array handle <br>
   * will be discarded immediately after use. Note that this is available only if <br>
   * you have write access to the data because there is no way to construct <br>
   * a non-writable array. This will work as long as the size of the data does <br>
   * not exceed the array's max_size. The resulting array object is not resizeable<br>
   * but can be used to read and write elements of the original data. The<br>
   * array is invalid if the original data is destructed or resized, but there is<br>
   * no way for the array class to detect that.<br>
   * <br>
   * Remarks: <br>
   *   - If the source data is empty, the resulting array will also <br>
   *     be empty and will look just like a default-constructed array. It will<br>
   *     therefore not have any connection to the source and will be an<br>
   *     ordinary resizable array.<br>
   *   - This is quite dangerous to use since the connection between the array and<br>
   *     the data is tenuous and subject to the data remaining untouched during<br>
   *     the lifetime of the array handle. There is no reference counting;<br>
   *     destructing the original data would leave the array referring to garbage. <br>
   *     Be careful!<br>
   *   - You can break the connection between the array and the data it was <br>
   *     constructed from by calling deallocate().<br>
   * <br>
   * <p alt="Complexity:"><br>
   *     Dirt cheap. There will be no construction, destruction, or heap allocation<br>
   *     performed.<br>
   * </p>@see deallocate() *
   */
  public SimTKArrayInt(SWIGTYPE_p_int first, SWIGTYPE_p_int last1, DontCopy arg2) {
    this(opensimSimbodyJNI.new_SimTKArrayInt__SWIG_4(SWIGTYPE_p_int.getCPtr(first), SWIGTYPE_p_int.getCPtr(last1), DontCopy.getCPtr(arg2), arg2), true);
  }

  /**
   *  Empty this array of its contents, returning the array to its <br>
   * default-constructed, all-zero state. If this array is the owner of its data,<br>
   * the destructor (if any) is called for each data element and the array's<br>
   * allocated heap space is freed. If it is a non-owner the array handle is<br>
   * cleaned out using disconnect() but the referenced data is untouched.<br>
   * Note: There is no equivalent to this method for std::vector.<br>
   * @return A reference to the now-empty, default-constructed array, ready for<br>
   * reassignment. *
   */
  public SimTKArrayInt deallocate() {
    return new SimTKArrayInt(opensimSimbodyJNI.SimTKArrayInt_deallocate(swigCPtr, this), false);
  }

  /**
   *  <br>
   * These methods put new data values in an existing array, but the meaning of<br>
   * assignment is subtly different for resizeable (owner) arrays and fixed <br>
   * (non-owner) arrays. The standard std::vector type is always an owner so the<br>
   * non-owner description here is an extension applying only to Array_.<br>
   * <br>
   * For the normal case of resizeable arrays, assignment does not have an <br>
   * elementwise definition because the source will typically have a different <br>
   * number of elements than the array's current size. So regardless of the actual <br>
   * numbers, assignment in the resizeable case is defined as it is for std::vector:<br>
   * first clear the array by erasing (destructing) all the current elements in the<br>
   * array, then reserve sufficient heap space to hold a copy of the source, then <br>
   * use appropriate constructors of type T (most commonly T's copy constructor <br>
   * T(T)) to initialize each element to be a copy of the corresponding source <br>
   * element. T's assignment operators are never used in this case.<br>
   * <br>
   * For fixed arrays, the source must have the same number of elments as are <br>
   * currently in the array and the meaning is conventional elementwise assignment;<br>
   * that is, an appropriate assignment operator of type T (most commonly T's copy <br>
   * assignment operator T=T) is used to change the value of each existing element. <br>
   * <br>
   * So there are different requirements on the value type T for owner and non-owner<br>
   * assignments to type T2: for owner assignment T must have a constructor T(T2)<br>
   * available; for non-owner assignment, T must have an assignment operator T=T2 <br>
   * available; .<br>
   * <br>
   * Remarks: <br>
   * - When reallocating the destination array, we may reuse the existing heap <br>
   * allocation if it is sufficient and not <i>too</i> big; otherwise we'll reallocate <br>
   * before copying. <br>
   * - The fill() method here has elementwise assignment semantics regardless of<br>
   * whether the array is an owner or non-owner. * Set this array to be <i>n</i> copies of the supplied <i>fillValue</i>. Note that <br>
   * this serves to allow fill from an object whose type T2 is different from T, as<br>
   * long as there is a constructor T(T2) that works since that can be invoked <br>
   * (implicitly or explicitly) to convert the T2 object to type T prior to the<br>
   * call. If this is a non-owner array then <i>n</i> must be the same as the current<br>
   * size(); consider using the fill() method instead.<br>
   * @param n            The number of elements to be in the result.<br>
   * @param fillValue    The value to which to initialize each element.<br>
   * <br>
   * <p alt="Complexity:"><br>
   * For a non-owner with <i>n==size()</i>, there will be exactly <i>n</i> calls to T's<br>
   * copy assignment operator. For an owner, there will be size() calls to T's<br>
   * destructor (if it has one), possibly a heap reallocation (but with no element<br>
   * copying), followed by <i>n</i> calls to T's copy constructor. <br>
   * </p>@see fill() *
   */
  public void assign(long n, int fillValue) {
    opensimSimbodyJNI.SimTKArrayInt_assign(swigCPtr, this, n, fillValue);
  }

  /**
   *  Assign all current elements of the array to the same <i>fillValue</i>. This is<br>
   * similar to assign(size(),fillValue) but the semantics are subtly different.<br>
   * Here we use repeated application of T's copy assignment operator T=fillValue,<br>
   * whereas the assign() semantics are to first destruct all the existing elements,<br>
   * then allocate if necessary, then use the copy constructor to initialize the<br>
   * new elements. Note that you can use this to fill from a source type T2 that<br>
   * is different from T as long as there exists a suitable constructor T(T2) that<br>
   * can be used to create the type T <i>fillValue</i> from the original T2 source.<br>
   * Note: Unlike other assignment methods, the behavior of fill() is identical for<br>
   * owner and non-owner arrays.<br>
   * <br>
   * @param fillValue    The value to which all existing elements are set.<br>
   * <p alt="Complexity:"><br>
   * Just size() calls to T's copy assignment operator. *</p>
   */
  public void fill(int fillValue) {
    opensimSimbodyJNI.SimTKArrayInt_fill(swigCPtr, this, fillValue);
  }

  /**
   *  This is a specialized algorithm providing constant time exchange of data <br>
   * with another array that has identical element and index types. This is <i>much</i> <br>
   * faster than using the std::swap() algorithm on the arrays since that would<br>
   * involve O(n) copying operations. This method makes no calls to any constructors<br>
   * or destructors. This is allowable even for non-owner arrays; the non-owner<br>
   * attribute will follow the non-owned data. *
   */
  public void swap(SimTKArrayInt other) {
    opensimSimbodyJNI.SimTKArrayInt_swap(swigCPtr, this, SimTKArrayInt.getCPtr(other), other);
  }

  /**
   *  This dangerous extension allows you to supply your own already-allocated<br>
   * heap space for use by this array, which then becomes the owner of the supplied<br>
   * heap space. Any memory currently associated with the array is deallocated; <br>
   * see deallocate() for more information. <br>
   * @see deallocate(), shareData() *
   */
  public SimTKArrayInt adoptData(SWIGTYPE_p_int newData, long dataSize, long dataCapacity) {
    return new SimTKArrayInt(opensimSimbodyJNI.SimTKArrayInt_adoptData__SWIG_0(swigCPtr, this, SWIGTYPE_p_int.getCPtr(newData), dataSize, dataCapacity), false);
  }

  /**
   *  A variant of adoptData() that assumes the capacity is the same as the<br>
   * current size. @see adoptData(SWIGTYPE_p_data,SWIGTYPE_p_size,SWIGTYPE_p_capacity) *
   */
  public SimTKArrayInt adoptData(SWIGTYPE_p_int newData, long dataSize) {
    return new SimTKArrayInt(opensimSimbodyJNI.SimTKArrayInt_adoptData__SWIG_1(swigCPtr, this, SWIGTYPE_p_int.getCPtr(newData), dataSize), false);
  }

  /**
   *  This dangerous extension allows you to make this array handle refer to<br>
   * someone else's data without copying it. Any memory currently associated<br>
   * with the array is deallocated; see deallocate() for more information. This<br>
   * method makes the array a fixed-size, non-owner array that cannot be <br>
   * reallocated, and no element destruction nor heap deallocation will occur when<br>
   * the handle is subsequently destructed or deallocated.<br>
   * Note: <br>
   *   - A null (0) pointer is allowed for the pointer as long as <i>dataSize==0</i>,<br>
   *     however in that case the array handle ends up deallocated (that is, <br>
   *     indistinguishable from a default-constructed array) so is resizeable.<br>
   *   - This is implemented by setting the nAllocated data member to zero while<br>
   *     the nUsed data member is set to the given <i>dataSize</i>.<br>
   * @see deallocate(), adoptData() *
   */
  public SimTKArrayInt shareData(SWIGTYPE_p_int newData, long dataSize) {
    return new SimTKArrayInt(opensimSimbodyJNI.SimTKArrayInt_shareData__SWIG_0(swigCPtr, this, SWIGTYPE_p_int.getCPtr(newData), dataSize), false);
  }

  /**
   *  Same as shareData(data,size) but uses a pointer range [first,last1) to<br>
   * identify the data to be referenced. *
   */
  public SimTKArrayInt shareData(SWIGTYPE_p_int first, SWIGTYPE_p_int last1) {
    return new SimTKArrayInt(opensimSimbodyJNI.SimTKArrayInt_shareData__SWIG_1(swigCPtr, this, SWIGTYPE_p_int.getCPtr(first), SWIGTYPE_p_int.getCPtr(last1)), false);
  }

  /**
   *  Return the current number of elements stored in this array. *
   */
  public long size() {
    return opensimSimbodyJNI.SimTKArrayInt_size(swigCPtr, this);
  }

  /**
   *  Return the maximum allowable size for this array. *
   */
  public long max_size() {
    return opensimSimbodyJNI.SimTKArrayInt_max_size(swigCPtr, this);
  }

  /**
   *  Return true if there are no elements currently stored in this array. This<br>
   * is equivalent to the tests begin() == end() or size()==0. *
   */
  public boolean empty() {
    return opensimSimbodyJNI.SimTKArrayInt_empty(swigCPtr, this);
  }

  /**
   *  Return the number of elements this array can currently hold without<br>
   * requiring reallocation. The value returned by capacity() is always greater <br>
   * than or equal to size(), even if the data is not owned by this array in<br>
   * which case we have capacity() == size() and the array is not reallocatable. *
   */
  public long capacity() {
    return opensimSimbodyJNI.SimTKArrayInt_capacity(swigCPtr, this);
  }

  /**
   *  Change the size of this Array, preserving all the elements that will still <br>
   * fit, and default constructing any new elements that are added. This is not<br>
   * allowed for non-owner arrays unless the requested size is the same as the <br>
   * current size. *
   */
  public void resize(long n) {
    opensimSimbodyJNI.SimTKArrayInt_resize__SWIG_0(swigCPtr, this, n);
  }

  /**
   *  Change the size of this array, preserving all the elements that will still <br>
   * fit, and initializing any new elements that are added by repeatedly copy-<br>
   * constructing from the supplied value. This is not allowed for non-owner arrays<br>
   * unless the requested size is the same as the current size. *
   */
  public void resize(long n, int initVal) {
    opensimSimbodyJNI.SimTKArrayInt_resize__SWIG_1(swigCPtr, this, n, initVal);
  }

  /**
   *  Ensure that this array has enough allocated capacity to hold the indicated <br>
   * number of elements. No heap reallocation will occur after this until the array<br>
   * is grown beyond this capacity, meaning that adding elements will not invalidate<br>
   * any iterators or element addresses until that point. This method will never <br>
   * reduce the capacity of the array. It is OK to call this on a non-owner array<br>
   * as long as you are not asking for an increase in capacity. *
   */
  public void reserve(long n) {
    opensimSimbodyJNI.SimTKArrayInt_reserve(swigCPtr, this, n);
  }

  /**
   *  Request that the capacity of this array be reduced to the minimum necessary<br>
   * to hold the number of elements currently in use. In practice no shrinkage will <br>
   * occur if the current size is just slightly too big, unless the current size is<br>
   * exactly zero in which case we guarantee to deallocate all heap space associated<br>
   * with this array leaving a null data pointer and begin()==end()==0, exactly as<br>
   * though the array had just been default-constructed. Otherwise you can check<br>
   * capacity() afterwards to see what happened. If the capacity() is reduced by <br>
   * this method, then all the elements will have been moved to new locations so <br>
   * existing iterators and references into the array will become invalid.<br>
   * <br>
   * Note: <br>
   *   - This method is from the proposed C++0x standard for std::vector, except for<br>
   *     the guaranteed behavior for a zero-size container.<br>
   *   - It is OK to call this on a non-owner array but it has no effect since<br>
   *     capacity()==size() already in that case.<br>
   * <br>
   * <p alt="Complexity:"><br>
   *     If the capacity is reduced, there will be one call to T's copy constructor <br>
   *     and destructor (if any) for each element currently in the array. Otherwise<br>
   *     this is very fast. *</p>
   */
  public void shrink_to_fit() {
    opensimSimbodyJNI.SimTKArrayInt_shrink_to_fit(swigCPtr, this);
  }

  /**
   *  Return the amount of heap space owned by this array; this is the same<br>
   * as capacity() for owner arrays but is zero for non-owners. <br>
   * Note: There is no equivalent of this method for std::vector. *
   */
  public long allocated() {
    return opensimSimbodyJNI.SimTKArrayInt_allocated(swigCPtr, this);
  }

  /**
   *  Does this array own the data to which it refers? If not, it can't be<br>
   * resized, and the destructor will not free any heap space nor call any element<br>
   * destructors. If the array does not refer to <i>any</i> data it is considered to be<br>
   * an owner and it is resizeable. <br>
   * Note: There is no equivalent of this method for std::vector. *
   */
  public boolean isOwner() {
    return opensimSimbodyJNI.SimTKArrayInt_isOwner(swigCPtr, this);
  }

  /**
   *  Return a const pointer to the first element of this array if any, otherwise<br>
   * cend(), which may be null (0) in that case but does not have to be. This method<br>
   * is from the proposed C++0x standard; there is also an overloaded begin() from<br>
   * the original standard that returns a const pointer. *
   */
  public SWIGTYPE_p_int cbegin() {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_cbegin(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  The const version of begin() is the same as cbegin(). *
   */
  public SWIGTYPE_p_int begin() {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_begin__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  Return a const pointer to what would be the element just after the last one<br>
   * in the array; this may be null (0) if there are no elements but doesn't have to<br>
   * be. This method is from the proposed C++0x standard; there is also an <br>
   * overloaded end() from the original standard that returns a const pointer. *
   */
  public SWIGTYPE_p_int cend() {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_cend(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  The const version of end() is the same as cend(). *
   */
  public SWIGTYPE_p_int end() {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_end__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  Return a const reverse iterator pointing to the last element in the array <br>
   * or crend() if the array is empty. *
   */
  public SWIGTYPE_p_std__reverse_iteratorT_int_const_p_t crbegin() {
    return new SWIGTYPE_p_std__reverse_iteratorT_int_const_p_t(opensimSimbodyJNI.SimTKArrayInt_crbegin(swigCPtr, this), true);
  }

  /**
   *  The const version of rbegin() is the same as crbegin(). *
   */
  public SWIGTYPE_p_std__reverse_iteratorT_int_const_p_t rbegin() {
    return new SWIGTYPE_p_std__reverse_iteratorT_int_const_p_t(opensimSimbodyJNI.SimTKArrayInt_rbegin__SWIG_0(swigCPtr, this), true);
  }

  /**
   *  Return the past-the-end reverse iterator that tests equal to a reverse<br>
   * iterator that has been incremented past the front of the array. You cannot <br>
   * dereference this iterator. *
   */
  public SWIGTYPE_p_std__reverse_iteratorT_int_const_p_t crend() {
    return new SWIGTYPE_p_std__reverse_iteratorT_int_const_p_t(opensimSimbodyJNI.SimTKArrayInt_crend(swigCPtr, this), true);
  }

  /**
   *  The const version of rend() is the same as crend(). *
   */
  public SWIGTYPE_p_std__reverse_iteratorT_int_const_p_t rend() {
    return new SWIGTYPE_p_std__reverse_iteratorT_int_const_p_t(opensimSimbodyJNI.SimTKArrayInt_rend__SWIG_0(swigCPtr, this), true);
  }

  /**
   *  Return a const pointer to the first element of the array, or possibly<br>
   * (but not necessarily) null (0) if the array is empty.<br>
   * Note: <br>
   *     cdata() does not appear to be in the C++0x standard although it would seem<br>
   *     obvious in view of the cbegin() and cend() methods that had to be added. <br>
   *     The C++0x overloaded const data() method is also available. *
   */
  public SWIGTYPE_p_int cdata() {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_cdata(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  The const version of the data() method is identical to cdata().<br>
   * Note: This method is from the proposed C++0x std::vector. *
   */
  public SWIGTYPE_p_int data() {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_data__SWIG_0(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  Same as operator[] but always range-checked, even in a Release build.  <br>
   * <p alt="Complexity:"><br>
   *     Constant time. *</p>
   */
  public int at(long i) {
    return opensimSimbodyJNI.SimTKArrayInt_at__SWIG_0(swigCPtr, this, i);
  }

  /**
   *  Same as the const form of operator[]; exists to provide a non-operator<br>
   * method for element access in case that's needed. *
   */
  public int getElt(long i) {
    return opensimSimbodyJNI.SimTKArrayInt_getElt(swigCPtr, this, i);
  }

  /**
   *  Same as the non-const form of operator[]; exists to provide a non-operator<br>
   * method for element access in case that's needed. *
   */
  public SWIGTYPE_p_int updElt(long i) {
    return new SWIGTYPE_p_int(opensimSimbodyJNI.SimTKArrayInt_updElt(swigCPtr, this, i), false);
  }

  /**
   *  Return a const reference to the first element in this array, which must<br>
   * not be empty.<br>
   * <p alt="Complexity:"><br>
   *     Constant time. *</p>
   */
  public int front() {
    return opensimSimbodyJNI.SimTKArrayInt_front__SWIG_0(swigCPtr, this);
  }

  /**
   *  Return a const reference to the last element in this array, which must<br>
   * not be empty.<br>
   * <p alt="Complexity:"><br>
   *     Constant time. *</p>
   */
  public int back() {
    return opensimSimbodyJNI.SimTKArrayInt_back__SWIG_0(swigCPtr, this);
  }

  /**
   *  This method increases the size of the Array by one element at the end and <br>
   * initializes that element by copy constructing it from the given value. If <br>
   * capacity() &gt; size(), that's all that will happen. If capacity()==size(), there<br>
   * is no room for another element so we'll allocate more space and move all the <br>
   * elements there. A reference to the just-inserted element can be obtained using<br>
   * the back() method after the call to push_back().<br>
   * @param value<br>
   *     An object of type T from which the new element is copy-constructed.<br>
   * <br>
   * Remarks: <br>
   *   - If you are appending a default-constructed object of type T, consider using<br>
   *     the alternate non-standard but safe push_back() method rather than <br>
   *     push_back(T()). The non-standard method default-constructs the new element <br>
   *     internally. That avoids a call to the copy constructor which can be <br>
   *     expensive for some objects, and nonexistent for others.<br>
   *   - If you are constructing the source object with a non-default constructor,<br>
   *     and the object is expensive or impossible to default-construct and/or <br>
   *     copy-construct, consider using the non-standard and dangerous method <br>
   *     raw_push_back() which enables you to construct the new element in place. <br>
   * <br>
   * <p alt="Complexity:"><br>
   *     Constant time if no reallocation is required; otherwise the current <br>
   *     contents of the array must be copied to new space, costing one call to T's<br>
   *     copy constructor and destructor (if any) for each element currently in the<br>
   *     array. Either way there is also one call to T's copy constructor to <br>
   *     construct the new element from the supplied value. *</p>
   */
  public void push_back(int value) {
    opensimSimbodyJNI.SimTKArrayInt_push_back__SWIG_0(swigCPtr, this, value);
  }

  /**
   *  This is a non-standard version of push_back() that increases the size of the<br>
   * array by one default-constructed element at the end. This avoids having to <br>
   * default-construct the argument to the standard push_back(value) method which <br>
   * then has to copy-construct it into the array. By carefully avoiding <br>
   * reallocation and using this form of push_back() you can use the Array_&lt;T&gt; class<br>
   * to hold objects of type T even if T has no copy constructor, which is <br>
   * prohibited by the standard std::vector&lt;T&gt; definition. <br>
   * <br>
   * <p alt="Complexity:"><br>
   *     Same as the standard push_back(value) method except without the final<br>
   *     call to T's copy constructor.<br>
   * </p>@see push_back(SWIGTYPE_p_value) 
   */
  public void push_back() {
    opensimSimbodyJNI.SimTKArrayInt_push_back__SWIG_1(swigCPtr, this);
  }

  /**
   *  This dangerous method increases the Array's size by one element at the end <br>
   * but doesn't perform any construction so the memory is filled with garbage. You <br>
   * must immediately construct into this space, using code like:<br>
   * {@code 
      new(a.raw_push_back()) MyConstructor(...args...);       
  }<br>
   * This is a substantial performance improvement when the element type is something<br>
   * complicated since the constructor is called once and not copied; it can also be<br>
   * used for objects that have neither default nor copy constructors.<br>
   * @return <br>
   *     An iterator (pointer) pointing at the unconstructed element. <br>
   * <p alt="Complexity:"><br>
   *     Same as ordinary push_back().<br>
   * </p>@see push_back(SWIGTYPE_p_value), push_back() 
   */
  public SWIGTYPE_p_int raw_push_back() {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_raw_push_back(swigCPtr, this);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  Remove the last element from this array, which must not be empty. The <br>
   * element is destructed, not returned. The array's size() is reduced by one. *
   */
  public void pop_back() {
    opensimSimbodyJNI.SimTKArrayInt_pop_back(swigCPtr, this);
  }

  /**
   *  Erase elements in range [first,last1), packing in any later elements into <br>
   * the newly-available space and reducing the array's size by the number of <br>
   * elements erased. Capacity is unchanged. If the range is empty nothing happens.<br>
   * <br>
   * @param first<br>
   *     Points to the first element that will be erased.<br>
   * @param last1<br>
   *     Points one element past the last element to be erased.<br>
   * @return <br>
   *     An iterator pointing to the new location of the element immediately<br>
   *     following the erased ones, or end() if there are none. Either way, this is <br>
   *     the same memory address as the passed-in <i>first</i> argument since there can<br>
   *     be no reallocation here.<br>
   * <p alt="Complexity:"><br>
   *     Calls T's destructor once for each erased element and calls T's copy <br>
   *     constructor and destructor once for each element that has to be moved. *</p>
   */
  public SWIGTYPE_p_int erase(SWIGTYPE_p_int first, SWIGTYPE_p_int last1) {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_erase__SWIG_0(swigCPtr, this, SWIGTYPE_p_int.getCPtr(first), SWIGTYPE_p_int.getCPtr(last1));
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  Erase just one element, moving all subsequent elements down one slot and<br>
   * reducing the array's size by one. This is equivalent to erase(p,p+1) but faster;<br>
   * that means <i>p</i> cannot be end() because end()+1 is not defined. Capacity is <br>
   * unchanged.<br>
   * <br>
   * Note: If you don't mind the elements being reordered, you can erase an element<br>
   * in constant time using the non-standard extension eraseFast().<br>
   * <br>
   * @param p<br>
   *     Points to the element that will be erased; <i>p</i> cannot be end().<br>
   * @return <br>
   *     A pointer to the element that replaced the one at <i>p</i>, or end() if <i>p</i> <br>
   *     was the last element. Either way, this is the same memory address as the <br>
   *     erased element had since there can be no reallocation here.<br>
   * <p alt="Complexity:"><br>
   *     Calls T's destructor once for the erased element and calls T's copy <br>
   *     constructor and destructor once for each element that has to be moved. <br>
   * </p>@see eraseFast() *
   */
  public SWIGTYPE_p_int erase(SWIGTYPE_p_int p) {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_erase__SWIG_1(swigCPtr, this, SWIGTYPE_p_int.getCPtr(p));
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  Be careful with this non-standard extension; it erases one element and <br>
   * then moves the last one in its place which changes the element order<br>
   * from what it was before (unlike the standard erase() method). This avoids<br>
   * having to compress the elements so this runs in constant time:<br>
   * the element is destructed; then if it wasn't the last element the<br>
   * copy constructor is used to copy the last element into the vacated<br>
   * space, and the destructor is called to clear the last element. The<br>
   * size is reduced by 1 but the capacity does not change. <br>
   * <br>
   * @param p<br>
   *     Points to the element that will be erased; <i>p</i> cannot be end().<br>
   * @return <br>
   *     A pointer to the element that replaced the one at <i>p</i>, or end() if <i>p</i> <br>
   *     was the last element. Either way, this is the same memory address as the <br>
   *     erased element had since there can be no reallocation here.<br>
   * <p alt="Complexity:"><br>
   *     Calls T's destructor once for the erased element and calls T's copy <br>
   *     constructor and destructor once for each element that has to be moved.<br>
   * </p>@see erase() *
   */
  public SWIGTYPE_p_int eraseFast(SWIGTYPE_p_int p) {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_eraseFast(swigCPtr, this, SWIGTYPE_p_int.getCPtr(p));
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  Erase all the elements currently in this array without changing the <br>
   * capacity; equivalent to erase(begin(),end()) but a little faster. Size is <br>
   * zero after this call. T's destructor is called exactly once for each element <br>
   * in the array.<br>
   * <br>
   * <p alt="Complexity:"><br>
   *     O(n) if T has a destructor; constant time otherwise. *</p>
   */
  public void clear() {
    opensimSimbodyJNI.SimTKArrayInt_clear(swigCPtr, this);
  }

  /**
   *  Insert <i>n</i> copies of a given value at a particular location within this <br>
   * array, moving all following elements up by <i>n</i> positions.<br>
   * <br>
   * @param p        <br>
   *     Where to insert the new elements. This must be an iterator (pointer) that <br>
   *     is valid for this array, that is, begin() &lt;= <i>p</i> &lt;= end().<br>
   * @param n<br>
   *     How many copies of the given <i>value</i> to insert. Nothing happens if <br>
   *     <i>n</i> is zero.<br>
   * @param value    <br>
   *     A value of the element type that is copied into the newly-created elements<br>
   *     using T's copy constructor.<br>
   * @return <br>
   *     A pointer to the first of the newly-created elements in the array. This <br>
   *     will be different from <i>p</i> if reallocation occurred, otherwise it is the<br>
   *     same as <i>p</i> was on entry.<br>
   * <br>
   * <p alt="Complexity:"><br>
   *     If size() + <i>n</i> &gt; capacity() then the array must be reallocated, resulting<br>
   *     in size() copy constructor/destructor call pairs to move the old data to <br>
   *     the new location. Otherwise, the m=(end()-<i>p)</i> elements above the insertion <br>
   *     point must be moved up <i>n</i> positions resulting in m copy/destruct pairs.<br>
   *     Then there are n additional copy constructor calls to construct the new <br>
   *     elements from the given value. </p>
   */
  public SWIGTYPE_p_int insert(SWIGTYPE_p_int p, long n, int value) {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_insert__SWIG_0(swigCPtr, this, SWIGTYPE_p_int.getCPtr(p), n, value);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

  /**
   *  Insert a new element at a given location within this array, initializing <br>
   * it to a copy of a given value and moving all following elements up one <br>
   * position. This is identical to insert(<i>p,1</i>,<i>value)</i> but slightly faster; see<br>
   * that method for full documentation. *
   */
  public SWIGTYPE_p_int insert(SWIGTYPE_p_int p, int value) {
    long cPtr = opensimSimbodyJNI.SimTKArrayInt_insert__SWIG_1(swigCPtr, this, SWIGTYPE_p_int.getCPtr(p), value);
    return (cPtr == 0) ? null : new SWIGTYPE_p_int(cPtr, false);
  }

}
