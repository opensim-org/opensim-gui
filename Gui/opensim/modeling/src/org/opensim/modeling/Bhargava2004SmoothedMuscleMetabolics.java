/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  This class implements the metabolic energy model of Bhargava et al (2004)<br>
 * and provides an option to use smooth (i.e., twice continuously<br>
 * differentiable) approximations. These approximations might be better suited<br>
 * for gradient-based optimization algorithms.<br>
 * <br>
 * We propose two smooth implementations.<br>
 * <br>
 * In the first implementation, conditional if statements were approximated by<br>
 * using hyperbolic tangent functions (tanh). For example, the following if<br>
 * statement:<br>
 * <pre>     y = a, if x &lt;= d </pre><br>
 * <pre>     y = b, if x &gt; d </pre><br>
 * can be approximated by:<br>
 * <pre>     f = 0.5 + 0.5 tanh(b(x-d)) </pre><br>
 * <pre>     y = a + (-a + b) f </pre><br>
 * where b is a parameter that determines the smoothness of the transition.<br>
 * <br>
 * In the second implementation, conditional if statements were approximated<br>
 * by using Huber loss functions, which have the following form:<br>
 * <pre>     L(f(x)) = 0.5 f(x)^2, if f(x) &lt;= delta </pre><br>
 * <pre>     L(f(x)) = delta(f(x) - 0.5 delta), otherwise. </pre><br>
 * The Huber loss function is quadratic for f(x) &lt;= delta and linear<br>
 * otherwise, with equal value and slopes of the different sections at the<br>
 * points where f(x) = delta (https://en.wikipedia.org/wiki/Huber_loss). In<br>
 * our implementation, we scaled this function with a parameter b that<br>
 * determines the smootheness of the transition between the quadratic and<br>
 * linear parts. Note that this approximation is piecewise but still<br>
 * continuous.<br>
 * <br>
 * The metabolic energy model includes components for activation heat rate,<br>
 * maintenance heat rate, shortening heat rate, and mechanical work rate.<br>
 * <br>
 * The shortening heat rate model differs between concentric contractions and<br>
 * eccentric contractions. We smoothed the transition between both contraction<br>
 * types using our smoothing functions. Note that when using the force<br>
 * dependent shortening proportional constant, we only provide the tanh<br>
 * smoothing option for approximating the shortening heat rate. This is<br>
 * motivated by the fact that the shortening heat rate is defined by linear<br>
 * functions but with different non-zero constants of proportionality for<br>
 * concentric and eccentric contractions. It is therefore easier to smooth the<br>
 * transition between both contraction types with a tanh function than with a<br>
 * Huber loss function. The difference between the original (non-smooth) and the<br>
 * smooth implementations is illustrated in the following figure:<br>
 * <br>
 *  <style>div.image img[src="SmoothShorteningHeatRate.png"]{width:750px;}</style> <br>
 * <img src="SmoothShorteningHeatRate.png" alt="Curves produced using isometricTotalActiveForce=350, fiberForceTotal=250, velocity_smoothing=10"/><br>
 * <br>
 * The mechanical work rate model includes negative mechanical work rate<br>
 * (i.e., work rate resulting from eccentric contraction) by default. However,<br>
 * if specified by the user, the model only takes positive mechanical work<br>
 * rate (i.e., work rate resulting from concentric contraction) into account.<br>
 * In such case, we smoothed the transition between positive rate and zero<br>
 * using our smoothing functions. The difference between the original<br>
 * (non-smooth) and the smooth implementations is illustrated in the following<br>
 * figure:<br>
 * <br>
 *  <style>div.image img[src="SmoothMechanicalWorkRate.png"]{width:750px;}</style> <br>
 * <img src="SmoothMechanicalWorkRate.png" alt="Curves produced using fiber_force_active=250, velocity_smoothing=10"/><br>
 * <br>
 * The metabolic energy model implementation includes an optional clamping<br>
 * that prevents the total metabolic rate (i.e., total metabolic power) to be<br>
 * negative. This clamping is done by increasing the shortening heat rate. We<br>
 * smoothed the transition between positive and negative total metabolic rate<br>
 * using our smoothing functions. The difference between the original<br>
 * (non-smooth) and the smooth implementations is illustrated in the following<br>
 * figure:<br>
 * <br>
 *  <style>div.image img[src="ClampingTotalMetabolicRate.png"]{width:750px;}</style> <br>
 * <img src="ClampingTotalMetabolicRate.png" alt="Curves produced using shorteningHeatRate=totalRate/4, power_smoothing=10"/><br>
 * <br>
 * The metabolic energy model implementation includes an optional clamping<br>
 * (see Umberger et al (2003), page 104) that prevents the total heat rate<br>
 * (i.e., activation heat rate + maintenance heat rate + shortening heat rate)<br>
 * for a given muscle to fall below 1.0 W/kg. Note that, if active, this<br>
 * clamping will cause the sum of the reported individual heat rates and work<br>
 * rate to differ from the reported metabolic rate. We smoothed the transition<br>
 * between total heat rate higher and lower than 1.0 W/kg using our smoothing<br>
 * functions. The difference between the original (non-smooth) and the smooth<br>
 * implementations is illustrated in the following figure:<br>
 * <br>
 *  <style>div.image img[src="ClampingTotalHeatRate.png"]{width:750px;}</style> <br>
 * <img src="ClampingTotalHeatRate.png" alt="Curves produced using muscle_mass=0.4, heat_rate_smoothing=10"/><br>
 * <br>
 * Note that the maintenance heat rate implementation relies on a<br>
 * PiecewiseLinearFunction. The first and second order derivatives of this<br>
 * function can be evaluated but they are discontinuous. This might cause<br>
 * issues with gradient-based optimization algorithms. Problems using this<br>
 * discontinuous function have successfully converged; therefore, we have<br>
 * included it in this implementation of the model.<br>
 * <br>
 * You can enable smoothing via the `use_smoothing` property. The smoothing type<br>
 * ('tanh' or 'huber') can be chosen via the `smoothing_type` property, and the<br>
 * level of smoothing can be controlled by the `velocity_smoothing`,<br>
 * `power_smoothing`, and `heat_rate_smoothing` properties.<br>
 * <br>
 * Muscles to be included when computing the total metabolic rate should be<br>
 * specified using one of the three `addMuscle()` function overloads. See the<br>
 * properties of `Bhargava2004SmoothedMuscleMetabolics_MuscleParameters()` for the<br>
 * default parameter values used when not specified via the second or third<br>
 * `addMuscle()` overload.<br>
 * <br>
 * {@code 
Bhargava2004SmoothedMuscleMetabolics* metabolics =
    new Bhargava2004SmoothedMuscleMetabolics();
metabolics->setName("metabolics");
metabolics->set_use_smoothing(true);

The simplest way to add the muscle to the metabolics model: just provide the
name of the muscle and a reference to Muscle component.
metabolics->addMuscle("soleus_r", model.getComponent<Muscle>("soleus_r"));

Provide the ratio of slow to fast twitch fibers and the specific tension of
muscle when adding it to the metabolics model. The values shown are also the 
default values.
double ratio_slow_twitch_fibers = 0.5;
double specific_tension = 0.25e6;
metabolics->addMuscle("gastroc_r", model.getComponent<Muscle>("gastroc_r"), 
        ratio_slow_twitch_fibers, specific_tension);

Provide the slow and fast twitch fiber constants used to compute the 
activation and maintenance heat rates. The values shown are also the default
values.
double activation_constant_slow_twitch = 40.0;
double activation_constant_fast_twitch = 133.0;
double maintenance_constant_slow_twitch = 74.0;
double maintenance_constant_fast_twitch = 111.0;
metabolics->addMuscle("tibant_r", model.getComponent<Muscle>("tibant_r"),
        ratio_slow_twitch_fibers, specific_tension,
        activation_constant_slow_twitch, activation_constant_fast_twitch,
        maintenance_constant_slow_twitch, maintenance_constant_fast_twitch);

model.addComponent(metabolics);
model.finalizeConnections();
}<br>
 * <br>
 * The total metabolic rate output can be obtained using `getTotalMetabolicRate()`,<br>
 * which takes a SimTK::State as a argument. You can similarly obtain the<br>
 * individual heat rate and mechanical work rate components of the total metabolic<br>
 * cost via `getTotalActivationRate()`, `getTotalMaintenanceRate()`,<br>
 * `getTotalShorteningRate()`, and `getTotalMechanicalWorkRate()`. All outputs<br>
 * require realizing the passed SimTK::State to SimTK::Stage::Dynamics.<br>
 * <br>
 * {@code 
const auto& metabolics = 
    model.getComponent<Bhargava2004SmoothedMuscleMetabolics>("metabolics");
model.realizeDynamics(state);
double totalMetabolicRate = metabolics.getTotalMetabolicRate(state);
double activationHeatRate = metabolics.getTotalActivationRate(state);
}<br>
 * <br>
 * Bhargava et al. 2004: https://doi.org/10.1016/s0021-9290(03)00239-2 
 */
public class Bhargava2004SmoothedMuscleMetabolics extends ModelComponent {
  private transient long swigCPtr;

  public Bhargava2004SmoothedMuscleMetabolics(long cPtr, boolean cMemoryOwn) {
    super(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(Bhargava2004SmoothedMuscleMetabolics obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(Bhargava2004SmoothedMuscleMetabolics obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_Bhargava2004SmoothedMuscleMetabolics(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static Bhargava2004SmoothedMuscleMetabolics safeDownCast(OpenSimObject obj) {
    long cPtr = opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new Bhargava2004SmoothedMuscleMetabolics(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Bhargava2004SmoothedMuscleMetabolics(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getConcreteClassName(swigCPtr, this);
  }

  public void copyProperty_enforce_minimum_heat_rate_per_muscle(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_enforce_minimum_heat_rate_per_muscle(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public boolean get_enforce_minimum_heat_rate_per_muscle(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_enforce_minimum_heat_rate_per_muscle__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_enforce_minimum_heat_rate_per_muscle(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_enforce_minimum_heat_rate_per_muscle__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_enforce_minimum_heat_rate_per_muscle(int i, boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_enforce_minimum_heat_rate_per_muscle__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_enforce_minimum_heat_rate_per_muscle(boolean value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_enforce_minimum_heat_rate_per_muscle(swigCPtr, this, value);
  }

  public void constructProperty_enforce_minimum_heat_rate_per_muscle(boolean initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_enforce_minimum_heat_rate_per_muscle(swigCPtr, this, initValue);
  }

  public boolean get_enforce_minimum_heat_rate_per_muscle() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_enforce_minimum_heat_rate_per_muscle__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_enforce_minimum_heat_rate_per_muscle() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_enforce_minimum_heat_rate_per_muscle__SWIG_1(swigCPtr, this), false);
  }

  public void set_enforce_minimum_heat_rate_per_muscle(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_enforce_minimum_heat_rate_per_muscle__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_use_force_dependent_shortening_prop_constant(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_use_force_dependent_shortening_prop_constant(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public boolean get_use_force_dependent_shortening_prop_constant(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_use_force_dependent_shortening_prop_constant__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_use_force_dependent_shortening_prop_constant(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_use_force_dependent_shortening_prop_constant__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_use_force_dependent_shortening_prop_constant(int i, boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_use_force_dependent_shortening_prop_constant__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_use_force_dependent_shortening_prop_constant(boolean value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_use_force_dependent_shortening_prop_constant(swigCPtr, this, value);
  }

  public void constructProperty_use_force_dependent_shortening_prop_constant(boolean initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_use_force_dependent_shortening_prop_constant(swigCPtr, this, initValue);
  }

  public boolean get_use_force_dependent_shortening_prop_constant() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_use_force_dependent_shortening_prop_constant__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_use_force_dependent_shortening_prop_constant() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_use_force_dependent_shortening_prop_constant__SWIG_1(swigCPtr, this), false);
  }

  public void set_use_force_dependent_shortening_prop_constant(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_use_force_dependent_shortening_prop_constant__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_basal_coefficient(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_basal_coefficient(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public double get_basal_coefficient(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_basal_coefficient__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_basal_coefficient(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_basal_coefficient__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_basal_coefficient(int i, double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_basal_coefficient__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_basal_coefficient(double value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_basal_coefficient(swigCPtr, this, value);
  }

  public void constructProperty_basal_coefficient(double initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_basal_coefficient(swigCPtr, this, initValue);
  }

  public double get_basal_coefficient() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_basal_coefficient__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_basal_coefficient() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_basal_coefficient__SWIG_1(swigCPtr, this), false);
  }

  public void set_basal_coefficient(double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_basal_coefficient__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_basal_exponent(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_basal_exponent(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public double get_basal_exponent(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_basal_exponent__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_basal_exponent(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_basal_exponent__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_basal_exponent(int i, double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_basal_exponent__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_basal_exponent(double value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_basal_exponent(swigCPtr, this, value);
  }

  public void constructProperty_basal_exponent(double initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_basal_exponent(swigCPtr, this, initValue);
  }

  public double get_basal_exponent() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_basal_exponent__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_basal_exponent() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_basal_exponent__SWIG_1(swigCPtr, this), false);
  }

  public void set_basal_exponent(double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_basal_exponent__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_muscle_effort_scaling_factor(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_muscle_effort_scaling_factor(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public double get_muscle_effort_scaling_factor(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_muscle_effort_scaling_factor__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_muscle_effort_scaling_factor(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_muscle_effort_scaling_factor__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_muscle_effort_scaling_factor(int i, double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_muscle_effort_scaling_factor__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_muscle_effort_scaling_factor(double value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_muscle_effort_scaling_factor(swigCPtr, this, value);
  }

  public void constructProperty_muscle_effort_scaling_factor(double initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_muscle_effort_scaling_factor(swigCPtr, this, initValue);
  }

  public double get_muscle_effort_scaling_factor() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_muscle_effort_scaling_factor__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_muscle_effort_scaling_factor() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_muscle_effort_scaling_factor__SWIG_1(swigCPtr, this), false);
  }

  public void set_muscle_effort_scaling_factor(double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_muscle_effort_scaling_factor__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_include_negative_mechanical_work(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_include_negative_mechanical_work(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public boolean get_include_negative_mechanical_work(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_include_negative_mechanical_work__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_include_negative_mechanical_work(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_include_negative_mechanical_work__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_include_negative_mechanical_work(int i, boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_include_negative_mechanical_work__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_include_negative_mechanical_work(boolean value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_include_negative_mechanical_work(swigCPtr, this, value);
  }

  public void constructProperty_include_negative_mechanical_work(boolean initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_include_negative_mechanical_work(swigCPtr, this, initValue);
  }

  public boolean get_include_negative_mechanical_work() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_include_negative_mechanical_work__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_include_negative_mechanical_work() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_include_negative_mechanical_work__SWIG_1(swigCPtr, this), false);
  }

  public void set_include_negative_mechanical_work(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_include_negative_mechanical_work__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_forbid_negative_total_power(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_forbid_negative_total_power(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public boolean get_forbid_negative_total_power(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_forbid_negative_total_power__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_forbid_negative_total_power(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_forbid_negative_total_power__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_forbid_negative_total_power(int i, boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_forbid_negative_total_power__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_forbid_negative_total_power(boolean value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_forbid_negative_total_power(swigCPtr, this, value);
  }

  public void constructProperty_forbid_negative_total_power(boolean initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_forbid_negative_total_power(swigCPtr, this, initValue);
  }

  public boolean get_forbid_negative_total_power() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_forbid_negative_total_power__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_forbid_negative_total_power() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_forbid_negative_total_power__SWIG_1(swigCPtr, this), false);
  }

  public void set_forbid_negative_total_power(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_forbid_negative_total_power__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_use_smoothing(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_use_smoothing(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public boolean get_use_smoothing(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_use_smoothing__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_use_smoothing(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_use_smoothing__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_use_smoothing(int i, boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_use_smoothing__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_use_smoothing(boolean value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_use_smoothing(swigCPtr, this, value);
  }

  public void constructProperty_use_smoothing() {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_use_smoothing__SWIG_0(swigCPtr, this);
  }

  public void constructProperty_use_smoothing(boolean initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_use_smoothing__SWIG_1(swigCPtr, this, initValue);
  }

  public boolean get_use_smoothing() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_use_smoothing__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_use_smoothing() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_use_smoothing__SWIG_1(swigCPtr, this), false);
  }

  public void set_use_smoothing(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_use_smoothing__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_smoothing_type(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_smoothing_type(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public String get_smoothing_type(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_smoothing_type__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_std__string upd_smoothing_type(int i) {
    return new SWIGTYPE_p_std__string(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_smoothing_type__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_smoothing_type(int i, String value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_smoothing_type__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_smoothing_type(String value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_smoothing_type(swigCPtr, this, value);
  }

  public void constructProperty_smoothing_type() {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_smoothing_type__SWIG_0(swigCPtr, this);
  }

  public void constructProperty_smoothing_type(String initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_smoothing_type__SWIG_1(swigCPtr, this, initValue);
  }

  public String get_smoothing_type() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_smoothing_type__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_std__string upd_smoothing_type() {
    return new SWIGTYPE_p_std__string(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_smoothing_type__SWIG_1(swigCPtr, this), false);
  }

  public void set_smoothing_type(String value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_smoothing_type__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_velocity_smoothing(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_velocity_smoothing(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public double get_velocity_smoothing(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_velocity_smoothing__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_velocity_smoothing(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_velocity_smoothing__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_velocity_smoothing(int i, double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_velocity_smoothing__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_velocity_smoothing(double value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_velocity_smoothing(swigCPtr, this, value);
  }

  public void constructProperty_velocity_smoothing() {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_velocity_smoothing__SWIG_0(swigCPtr, this);
  }

  public void constructProperty_velocity_smoothing(double initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_velocity_smoothing__SWIG_1(swigCPtr, this, initValue);
  }

  public double get_velocity_smoothing() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_velocity_smoothing__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_velocity_smoothing() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_velocity_smoothing__SWIG_1(swigCPtr, this), false);
  }

  public void set_velocity_smoothing(double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_velocity_smoothing__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_power_smoothing(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_power_smoothing(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public double get_power_smoothing(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_power_smoothing__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_power_smoothing(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_power_smoothing__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_power_smoothing(int i, double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_power_smoothing__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_power_smoothing(double value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_power_smoothing(swigCPtr, this, value);
  }

  public void constructProperty_power_smoothing() {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_power_smoothing__SWIG_0(swigCPtr, this);
  }

  public void constructProperty_power_smoothing(double initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_power_smoothing__SWIG_1(swigCPtr, this, initValue);
  }

  public double get_power_smoothing() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_power_smoothing__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_power_smoothing() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_power_smoothing__SWIG_1(swigCPtr, this), false);
  }

  public void set_power_smoothing(double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_power_smoothing__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_heat_rate_smoothing(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_heat_rate_smoothing(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public double get_heat_rate_smoothing(int i) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_heat_rate_smoothing__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_heat_rate_smoothing(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_heat_rate_smoothing__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_heat_rate_smoothing(int i, double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_heat_rate_smoothing__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_heat_rate_smoothing(double value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_heat_rate_smoothing(swigCPtr, this, value);
  }

  public void constructProperty_heat_rate_smoothing() {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_heat_rate_smoothing__SWIG_0(swigCPtr, this);
  }

  public void constructProperty_heat_rate_smoothing(double initValue) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_heat_rate_smoothing__SWIG_1(swigCPtr, this, initValue);
  }

  public double get_heat_rate_smoothing() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_heat_rate_smoothing__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_heat_rate_smoothing() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_heat_rate_smoothing__SWIG_1(swigCPtr, this), false);
  }

  public void set_heat_rate_smoothing(double value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_heat_rate_smoothing__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_muscle_parameters(Bhargava2004SmoothedMuscleMetabolics source) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_copyProperty_muscle_parameters(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics.getCPtr(source), source);
  }

  public Bhargava2004SmoothedMuscleMetabolics_MuscleParameters get_muscle_parameters(int i) {
    return new Bhargava2004SmoothedMuscleMetabolics_MuscleParameters(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_get_muscle_parameters(swigCPtr, this, i), false);
  }

  public Bhargava2004SmoothedMuscleMetabolics_MuscleParameters upd_muscle_parameters(int i) {
    return new Bhargava2004SmoothedMuscleMetabolics_MuscleParameters(opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_upd_muscle_parameters(swigCPtr, this, i), false);
  }

  public void set_muscle_parameters(int i, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_set_muscle_parameters(swigCPtr, this, i, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters.getCPtr(value), value);
  }

  public int append_muscle_parameters(Bhargava2004SmoothedMuscleMetabolics_MuscleParameters value) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_append_muscle_parameters(swigCPtr, this, Bhargava2004SmoothedMuscleMetabolics_MuscleParameters.getCPtr(value), value);
  }

  public void constructProperty_muscle_parameters() {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_constructProperty_muscle_parameters(swigCPtr, this);
  }

  public void set_has_output_total_metabolic_rate(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_metabolic_rate_set(swigCPtr, this, value);
  }

  public boolean get_has_output_total_metabolic_rate() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_metabolic_rate_get(swigCPtr, this);
  }

  public void set_has_output_total_activation_rate(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_activation_rate_set(swigCPtr, this, value);
  }

  public boolean get_has_output_total_activation_rate() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_activation_rate_get(swigCPtr, this);
  }

  public void set_has_output_total_maintenance_rate(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_maintenance_rate_set(swigCPtr, this, value);
  }

  public boolean get_has_output_total_maintenance_rate() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_maintenance_rate_get(swigCPtr, this);
  }

  public void set_has_output_total_shortening_rate(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_shortening_rate_set(swigCPtr, this, value);
  }

  public boolean get_has_output_total_shortening_rate() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_shortening_rate_get(swigCPtr, this);
  }

  public void set_has_output_total_mechanical_work_rate(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_mechanical_work_rate_set(swigCPtr, this, value);
  }

  public boolean get_has_output_total_mechanical_work_rate() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_total_mechanical_work_rate_get(swigCPtr, this);
  }

  public void set_has_output_muscle_metabolic_rate(boolean value) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_muscle_metabolic_rate_set(swigCPtr, this, value);
  }

  public boolean get_has_output_muscle_metabolic_rate() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics__has_output_muscle_metabolic_rate_get(swigCPtr, this);
  }

  public Bhargava2004SmoothedMuscleMetabolics() {
    this(opensimSimulationJNI.new_Bhargava2004SmoothedMuscleMetabolics(), true);
  }

  /**
   *  Get the number of muscles added to the metabolics model by one of the<br>
   *     `addMuscle()` overloads. 
   */
  public int getNumMetabolicMuscles() {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getNumMetabolicMuscles(swigCPtr, this);
  }

  /**
   *  Specify a muscle that should be included when computing the total<br>
   *     metabolic rate. If the `muscle_mass` argument is not provided, it is<br>
   *     estimated based on the max isometric force, specific tension,<br>
   *     muscle density, and optimal fiber length. 
   */
  public void addMuscle(String name, Muscle muscle, double muscle_mass) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_addMuscle__SWIG_0(swigCPtr, this, name, Muscle.getCPtr(muscle), muscle, muscle_mass);
  }

  /**
   *  Specify a muscle that should be included when computing the total<br>
   *     metabolic rate. If the `muscle_mass` argument is not provided, it is<br>
   *     estimated based on the max isometric force, specific tension,<br>
   *     muscle density, and optimal fiber length. 
   */
  public void addMuscle(String name, Muscle muscle) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_addMuscle__SWIG_1(swigCPtr, this, name, Muscle.getCPtr(muscle), muscle);
  }

  /**
   *  Specify a muscle that should be included when computing the total<br>
   *     metabolic rate, as well as its ratio of slow to fast twitch fibers and<br>
   *     specific tension. If the `muscle_mass` argument is not provided, it is<br>
   *     estimated based on the max isometric force, specific tension,<br>
   *     muscle density, and optimal fiber length. 
   */
  public void addMuscle(String name, Muscle muscle, double ratio_slow_twitch_fibers, double specific_tension, double muscle_mass) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_addMuscle__SWIG_2(swigCPtr, this, name, Muscle.getCPtr(muscle), muscle, ratio_slow_twitch_fibers, specific_tension, muscle_mass);
  }

  /**
   *  Specify a muscle that should be included when computing the total<br>
   *     metabolic rate, as well as its ratio of slow to fast twitch fibers and<br>
   *     specific tension. If the `muscle_mass` argument is not provided, it is<br>
   *     estimated based on the max isometric force, specific tension,<br>
   *     muscle density, and optimal fiber length. 
   */
  public void addMuscle(String name, Muscle muscle, double ratio_slow_twitch_fibers, double specific_tension) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_addMuscle__SWIG_3(swigCPtr, this, name, Muscle.getCPtr(muscle), muscle, ratio_slow_twitch_fibers, specific_tension);
  }

  /**
   *  Specify a muscle that should be included when computing the total<br>
   *     metabolic rate, as well as its ratio of slow to fast twitch fibers and<br>
   *     specific tension. This overload also allows you to specify the slow and fast<br>
   *     twitch fiber constants used to compute the activation and maintenance heat<br>
   *     rates. If the `muscle_mass` argument is not provided, it is estimated based<br>
   *     on the max isometric force, specific tension, muscle density, and optimal<br>
   *     fiber length. 
   */
  public void addMuscle(String name, Muscle muscle, double ratio_slow_twitch_fibers, double specific_tension, double activation_constant_slow_twitch, double activation_constant_fast_twitch, double maintenance_constant_slow_twitch, double maintenance_constant_fast_twitch, double muscle_mass) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_addMuscle__SWIG_4(swigCPtr, this, name, Muscle.getCPtr(muscle), muscle, ratio_slow_twitch_fibers, specific_tension, activation_constant_slow_twitch, activation_constant_fast_twitch, maintenance_constant_slow_twitch, maintenance_constant_fast_twitch, muscle_mass);
  }

  /**
   *  Specify a muscle that should be included when computing the total<br>
   *     metabolic rate, as well as its ratio of slow to fast twitch fibers and<br>
   *     specific tension. This overload also allows you to specify the slow and fast<br>
   *     twitch fiber constants used to compute the activation and maintenance heat<br>
   *     rates. If the `muscle_mass` argument is not provided, it is estimated based<br>
   *     on the max isometric force, specific tension, muscle density, and optimal<br>
   *     fiber length. 
   */
  public void addMuscle(String name, Muscle muscle, double ratio_slow_twitch_fibers, double specific_tension, double activation_constant_slow_twitch, double activation_constant_fast_twitch, double maintenance_constant_slow_twitch, double maintenance_constant_fast_twitch) {
    opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_addMuscle__SWIG_5(swigCPtr, this, name, Muscle.getCPtr(muscle), muscle, ratio_slow_twitch_fibers, specific_tension, activation_constant_slow_twitch, activation_constant_fast_twitch, maintenance_constant_slow_twitch, maintenance_constant_fast_twitch);
  }

  public double getTotalMetabolicRate(State s) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getTotalMetabolicRate(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getTotalActivationRate(State s) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getTotalActivationRate(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getTotalMaintenanceRate(State s) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getTotalMaintenanceRate(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getTotalShorteningRate(State s) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getTotalShorteningRate(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getTotalMechanicalWorkRate(State s) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getTotalMechanicalWorkRate(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getMuscleMetabolicRate(State s, String channel) {
    return opensimSimulationJNI.Bhargava2004SmoothedMuscleMetabolics_getMuscleMetabolicRate(swigCPtr, this, State.getCPtr(s), s, channel);
  }

}
