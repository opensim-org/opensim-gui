/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  Minimize the error between a model's step time asymmetry and a specified<br>
 * target asymmetry value over a gait cycle.<br>
 * <br>
 * Step time is defined as the time between consecutive foot strikes. Step Time<br>
 * Asymmetry (STA) is a ratio and is calculated as follows:<br>
 *  - Right Step Time (RST) = Time from left foot-strike to right foot-strike<br>
 *  - Left Step Time (LST)  = Time from right foot-strike to left foot-strike<br>
 *  - STA = (RST - LST) / (RST + LST)<br>
 * <br>
 * In this goal, the step time asymmetry is computed by "counting" the number of<br>
 * nodes that each foot is in  contact with the ground (with respect to a specified<br>
 * contact force threshold). Since, in walking, there are double support phases<br>
 * where both feet are on the ground, the goal also detects which foot is in front<br>
 * and assigns the step time to the leading foot. Altogether, it estimates the time<br>
 * between consecutive heel strikes in order to infer the left and right step times.<br>
 * <br>
 * The contact elements for each foot must specified via 'setLeftContactGroup()'<br>
 * and 'setRightContactGroup()'. The force element and force threshold used to<br>
 * determine when a foot is in contact is set via 'setContactForceDirection()' and<br>
 * 'setContactForceThreshold()'.<br>
 * <br>
 * Users must provide the target asymmetry value via 'setTargetAsymmetry()'.<br>
 * Asymmetry values ranges from -1.0 to 1.0. For example, 0.20 is 20% positive<br>
 * step time asymmetry with greater right step times than left step times. A<br>
 * symmetric step times solution can be achieved by setting this property to zero.<br>
 * This goal can be used only in 'cost' mode, where the error between the target<br>
 * asymmetry and model asymmetry is squared. To make this goal suitable for<br>
 * gradient-based optimization, step time values are assigned via smoothing<br>
 * functions which can be controlled via 'setAsymmetrySmoothing()' and<br>
 * 'setContactDetectionSmoothing()'.<br>
 * <br>
 * Note: This goal is designed for simulations of bipedal gait.<br>
 * <br>
 * Note: The only contact element supported is SmoothSphereHalfSpaceForce.<br>
 * <br>
 * Note: Since this goal approximates step time asymmetry, users should calculate<br>
 * the true asymmetry value after running an optimization.<br>
 * <br>
 * 
 */
public class MocoStepTimeAsymmetryGoal extends MocoGoal {
  private transient long swigCPtr;

  public MocoStepTimeAsymmetryGoal(long cPtr, boolean cMemoryOwn) {
    super(opensimMocoJNI.MocoStepTimeAsymmetryGoal_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(MocoStepTimeAsymmetryGoal obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(MocoStepTimeAsymmetryGoal obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimMocoJNI.delete_MocoStepTimeAsymmetryGoal(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static MocoStepTimeAsymmetryGoal safeDownCast(OpenSimObject obj) {
    long cPtr = opensimMocoJNI.MocoStepTimeAsymmetryGoal_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new MocoStepTimeAsymmetryGoal(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimMocoJNI.MocoStepTimeAsymmetryGoal_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimMocoJNI.MocoStepTimeAsymmetryGoal_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new MocoStepTimeAsymmetryGoal(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimMocoJNI.MocoStepTimeAsymmetryGoal_getConcreteClassName(swigCPtr, this);
  }

  public MocoStepTimeAsymmetryGoal() {
    this(opensimMocoJNI.new_MocoStepTimeAsymmetryGoal__SWIG_0(), true);
  }

  public MocoStepTimeAsymmetryGoal(String name) {
    this(opensimMocoJNI.new_MocoStepTimeAsymmetryGoal__SWIG_1(name), true);
  }

  public MocoStepTimeAsymmetryGoal(String name, double weight) {
    this(opensimMocoJNI.new_MocoStepTimeAsymmetryGoal__SWIG_2(name, weight), true);
  }

  /**
   *  Add the group of contact forces that determine the position of the left<br>
   *  foot and when it is in contact with the ground.
   */
  public void setLeftContactGroup(StdVectorString contactForcePaths, String footPositionForcePath) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_setLeftContactGroup(swigCPtr, this, StdVectorString.getCPtr(contactForcePaths), contactForcePaths, footPositionForcePath);
  }

  /**
   *  Add the group of contact forces that determine the position of the right<br>
   *  foot and when it is in contact with the ground.
   */
  public void setRightContactGroup(StdVectorString contactForcePaths, String footPositionForcePath) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_setRightContactGroup(swigCPtr, this, StdVectorString.getCPtr(contactForcePaths), contactForcePaths, footPositionForcePath);
  }

  /**
   *  Set the asymmetry value targeted by this goal. If using 'cost' mode, the<br>
   *  error between the target asymmetry and the model asymmetry is squared.
   */
  public void setTargetAsymmetry(double asymmetry) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_setTargetAsymmetry(swigCPtr, this, asymmetry);
  }

  public double getTargetAsymmetry() {
    return opensimMocoJNI.MocoStepTimeAsymmetryGoal_getTargetAsymmetry(swigCPtr, this);
  }

  /**
   *  Set the threshold force value used to detect is a foot is in contact with<br>
   *  the ground.
   */
  public void setContactForceThreshold(double threshold) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_setContactForceThreshold(swigCPtr, this, threshold);
  }

  public double getContactForceThreshold() {
    return opensimMocoJNI.MocoStepTimeAsymmetryGoal_getContactForceThreshold(swigCPtr, this);
  }

  /**
   *  Set the direction in ground of the total contact force component used to<br>
   *  detect foot contact. When the contact force component for a foot exceeds<br>
   *  the force set by the 'contact_force_threshold' property, we register that<br>
   *  foot as in contact with the ground. Acceptable direction values include<br>
   *  "positive-x", "positive-y", "positive-z", "negative-x", "negative-y", and<br>
   *  "negative-z". Default: "positive-y".
   */
  public void setContactForceDirection(String direction) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_setContactForceDirection(swigCPtr, this, direction);
  }

  public String getContactForceDirection() {
    return opensimMocoJNI.MocoStepTimeAsymmetryGoal_getContactForceDirection(swigCPtr, this);
  }

  /**
   *  Set the walking direction of the model in the ground frame, which is used<br>
   *  to determine the leading foot during double support. Acceptable direction<br>
   *  values include "positive-x", "positive-y", "positive-z", "negative-x",<br>
   *  "negative-y", and "negative-z". Default: "positive-x".
   */
  public void setWalkingDirection(String direction) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_setWalkingDirection(swigCPtr, this, direction);
  }

  public String getWalkingDirection() {
    return opensimMocoJNI.MocoStepTimeAsymmetryGoal_getWalkingDirection(swigCPtr, this);
  }

  /**
   *  Set the values that determines the smoothing of the asymmetry<br>
   *  computation. This term is necessary since this computation is non-smooth<br>
   *  (i.e., either the left foot or right foot is in contact).
   */
  public void setAsymmetrySmoothing(double smoothing) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_setAsymmetrySmoothing(swigCPtr, this, smoothing);
  }

  public double getAsymmetrySmoothing() {
    return opensimMocoJNI.MocoStepTimeAsymmetryGoal_getAsymmetrySmoothing(swigCPtr, this);
  }

  /**
   *  Set the value that determins the smoothing of the contact force<br>
   *  detection. This term in necessary since foot contact is non-smooth,<br>
   *  (i.e., ether the foot is in contact or not).
   */
  public void setContactDetectionSmoothing(double smoothing) {
    opensimMocoJNI.MocoStepTimeAsymmetryGoal_setContactDetectionSmoothing(swigCPtr, this, smoothing);
  }

  public double getContactDetectionSmoothing() {
    return opensimMocoJNI.MocoStepTimeAsymmetryGoal_getContactDetectionSmoothing(swigCPtr, this);
  }

}
