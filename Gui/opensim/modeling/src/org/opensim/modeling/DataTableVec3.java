/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  DataTable_ is an in-memory storage container for data with support for <br>
 * holding metadata (using the base class AbstractDataTable). Data contains an <br>
 * independent column and a set of dependent columns. The type of the independent <br>
 * column can be configured using ETX (template param). The type of the dependent <br>
 * columns, which together form a matrix, can be configured using ETY (template <br>
 * param). Independent and dependent columns can contain metadata. DataTable_ as a <br>
 * whole can contain metadata.<br>
 * <br>
 * 
 */
public class DataTableVec3 extends AbstractDataTable {
  private transient long swigCPtr;
  private transient boolean swigCMemOwnDerived;

  protected DataTableVec3(long cPtr, boolean cMemoryOwn) {
    super(opensimCommonJNI.DataTableVec3_SWIGSmartPtrUpcast(cPtr), true);
    swigCMemOwnDerived = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(DataTableVec3 obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected void swigSetCMemOwn(boolean own) {
    swigCMemOwnDerived = own;
    super.swigSetCMemOwn(own);
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwnDerived) {
        swigCMemOwnDerived = false;
        opensimCommonJNI.delete_DataTableVec3(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public DataTableVec3() {
    this(opensimCommonJNI.new_DataTableVec3__SWIG_0(), true);
  }

  public DataTableVec3(DataTableVec3 arg0) {
    this(opensimCommonJNI.new_DataTableVec3__SWIG_1(DataTableVec3.getCPtr(arg0), arg0), true);
  }

  /**
   *  Construct DataTable_ from a file.                                     <br>
   * <br>
   *     @param filename Name of the file. File should contain only one table. For<br>
   *                     example, trc, csv &amp; sto files contain one table whereas a <br>
   *                     c3d file can contain more than.<br>
   *     @param tablename Name of the table in file to construct this DataTable_<br>
   *                      from. For example, a c3d file contains tables named<br>
   *                      'markers' and 'forces'.<br>
   * <br>
   *     @throws InvalidArgument If the input file contains more than one table and<br>
   *                             tablename was not specified.   <br>
   *     @throws InvalidArgument If the input file contains a table that is not of<br>
   *                             this DataTable_ type.                             
   */
  public DataTableVec3(String filename, String tablename) {
    this(opensimCommonJNI.new_DataTableVec3__SWIG_2(filename, tablename), true);
  }

  /**
   *  Flatten the columns of this table to create a <br>
   *     DataTable_&lt;double, double&gt;. Each column will be split into its <br>
   *     constituent components. For example, each column of a <br>
   *     DataTable_&lt;double, Vec3&gt; will be split into 3 columns. The column-labels of<br>
   *     the resulting columns will be suffixed "_1", "_2", "_3" and so on. See<br>
   *     documentation for constructor DataTable_::DataTable_().                   
   */
  public DataTable flatten() {
    return new DataTable(opensimCommonJNI.DataTableVec3_flatten__SWIG_0(swigCPtr, this), true);
  }

  /**
   *  Flatten the columns of this table to create a <br>
   *     DataTable_&lt;double, double&gt;. Each column will be split into its <br>
   *     constituent components. For example, each column of a <br>
   *     DataTable_&lt;double, Vec3&gt; will be split into 3 columns. The column-labels of<br>
   *     the resulting columns will be appended with 'suffixes' provided. See<br>
   *     documentation for constructor DataTable_::DataTable_().                   
   */
  public DataTable flatten(StdVectorString suffixes) {
    return new DataTable(opensimCommonJNI.DataTableVec3_flatten__SWIG_1(swigCPtr, this, StdVectorString.getCPtr(suffixes), suffixes), true);
  }

  /**
   *  Retrieve the number of components each element (of type ETY) of the <br>
   *     table is made of. Some examples:<br>
   * <br>
   *     Table Type                    | Element Type | Num of Components<br>
   *     ------------------------------|--------------|------------------<br>
   *     DataTable&lt;double, double&gt;     | double       | 1<br>
   *     DataTable&lt;double, Vec3&gt;       | Vec3         | 3<br>
   *     DataTable&lt;double, Quaternion&gt; | Quaternion   | 4                          
   */
  public long numComponentsPerElement() {
    return opensimCommonJNI.DataTableVec3_numComponentsPerElement(swigCPtr, this);
  }

  /**
   *  Append row to the DataTable_.<br>
   * <br>
   *     @param indRow Entry for the independent column corresponding to the row to<br>
   *                   be appended.<br>
   *     @param container std::initializer_list containing elements of the row to be<br>
   *                      appended.<br>
   * <br>
   *     @throws IncorrectNumColumns If the row added is invalid. Validity of the <br>
   *     row added is decided by the derived class.                                
   */
  public void appendRow(double indRow, SWIGTYPE_p_std__initializer_listT_SimTK__VecT_3_double_1_t_t container) {
    opensimCommonJNI.DataTableVec3_appendRow__SWIG_1(swigCPtr, this, indRow, SWIGTYPE_p_std__initializer_listT_SimTK__VecT_3_double_1_t_t.getCPtr(container));
  }

  /**
   *  Append row to the DataTable_.                                         <br>
   * <br>
   *     @throws IncorrectNumColumns If the row added is invalid. Validity of the <br>
   *     row added is decided by the derived class.                                
   */
  public void appendRow(double indRow, RowVectorVec3 depRow) {
    opensimCommonJNI.DataTableVec3_appendRow__SWIG_3(swigCPtr, this, indRow, RowVectorVec3.getCPtr(depRow), depRow);
  }

  /**
   *  Append row to the DataTable_.                                         <br>
   * <br>
   *     @throws IncorrectNumColumns If the row added is invalid. Validity of the <br>
   *     row added is decided by the derived class.                                
   */
  public void appendRow(double indRow, RowVectorViewVec3 depRow) {
    opensimCommonJNI.DataTableVec3_appendRow__SWIG_4(swigCPtr, this, indRow, RowVectorViewVec3.getCPtr(depRow), depRow);
  }

  /**
   *  Get row at index.                                                     <br>
   * <br>
   *     @throws RowIndexOutOfRange If index is out of range.                      
   */
  public RowVectorViewVec3 getRowAtIndex(long index) {
    return new RowVectorViewVec3(opensimCommonJNI.DataTableVec3_getRowAtIndex(swigCPtr, this, index), true);
  }

  /**
   *  Get row corresponding to the given entry in the independent column. This<br>
   *     function searches the independent column for exact equality, which may not<br>
   *     be appropriate if `ETX` is of type `double`. See <br>
   *     TimeSeriesTable_::getNearestRow().<br>
   * <br>
   *     @throws KeyNotFound If the independent column has no entry with given<br>
   *                         value.                                                
   */
  public RowVectorViewVec3 getRow(double ind) {
    return new RowVectorViewVec3(opensimCommonJNI.DataTableVec3_getRow(swigCPtr, this, ind), true);
  }

  /**
   *  Update row at index.                                                  <br>
   * <br>
   *     @throws RowIndexOutOfRange If the index is out of range.                  
   */
  public RowVectorViewVec3 updRowAtIndex(long index) {
    return new RowVectorViewVec3(opensimCommonJNI.DataTableVec3_updRowAtIndex(swigCPtr, this, index), true);
  }

  /**
   *  Update row corresponding to the given entry in the independent column.<br>
   *     This function searches the independent column for exact equality, which may <br>
   *     not be appropriate if `ETX` is of type `double`. See <br>
   *     TimeSeriesTable_::updNearestRow().<br>
   * <br>
   *     @throws KeyNotFound If the independent column has no entry with given<br>
   *                         value.                                                
   */
  public RowVectorViewVec3 updRow(double ind) {
    return new RowVectorViewVec3(opensimCommonJNI.DataTableVec3_updRow(swigCPtr, this, ind), true);
  }

  /**
   *  Set row at index. Equivalent to<br>
   *     ```<br>
   *     updRowAtIndex(index) = depRow;<br>
   *     ```<br>
   * <br>
   *     @throws RowIndexOutOfRange If the index is out of range.                  
   */
  public void setRowAtIndex(long index, RowVectorViewVec3 depRow) {
    opensimCommonJNI.DataTableVec3_setRowAtIndex__SWIG_0(swigCPtr, this, index, RowVectorViewVec3.getCPtr(depRow), depRow);
  }

  /**
   *  Set row at index. Equivalent to<br>
   *     ```<br>
   *     updRowAtIndex(index) = depRow;<br>
   *     ```<br>
   * <br>
   *     @throws RowIndexOutOfRange If the index is out of range.                  
   */
  public void setRowAtIndex(long index, RowVectorVec3 depRow) {
    opensimCommonJNI.DataTableVec3_setRowAtIndex__SWIG_1(swigCPtr, this, index, RowVectorVec3.getCPtr(depRow), depRow);
  }

  /**
   *  Set row corresponding to the given entry in the independent column.<br>
   *     This function searches the independent column for exact equality, which may <br>
   *     not be appropriate if `ETX` is of type `double`. See <br>
   *     TimeSeriesTable_::updNearestRow().<br>
   *     Equivalent to<br>
   *     ```<br>
   *     updRow(ind) = depRow;<br>
   *     ```<br>
   * <br>
   *     @throws KeyNotFound If the independent column has no entry with given<br>
   *                         value.                                                
   */
  public void setRow(double ind, RowVectorViewVec3 depRow) {
    opensimCommonJNI.DataTableVec3_setRow__SWIG_0(swigCPtr, this, ind, RowVectorViewVec3.getCPtr(depRow), depRow);
  }

  /**
   *  Set row corresponding to the given entry in the independent column.<br>
   *     This function searches the independent column for exact equality, which may <br>
   *     not be appropriate if `ETX` is of type `double`. See <br>
   *     TimeSeriesTable_::updNearestRow().<br>
   *     Equivalent to<br>
   *     ```<br>
   *     updRow(ind) = depRow;<br>
   *     ```<br>
   * <br>
   *     @throws KeyNotFound If the independent column has no entry with given<br>
   *                         value.                                                
   */
  public void setRow(double ind, RowVectorVec3 depRow) {
    opensimCommonJNI.DataTableVec3_setRow__SWIG_1(swigCPtr, this, ind, RowVectorVec3.getCPtr(depRow), depRow);
  }

  /**
   *  Remove row at index.<br>
   * <br>
   *     @throws RowIndexOutOfRange If the index is out of range.                  
   */
  public void removeRowAtIndex(long index) {
    opensimCommonJNI.DataTableVec3_removeRowAtIndex(swigCPtr, this, index);
  }

  /**
   *  Remove row corresponding to the given entry in the independent column.<br>
   * <br>
   *     @throws KeyNotFound If the independent column has no entry with the given<br>
   *                         value.                                                
   */
  public void removeRow(double ind) {
    opensimCommonJNI.DataTableVec3_removeRow(swigCPtr, this, ind);
  }

  /**
   *  End of Row accessors/mutators.<br>
   *  Get independent column.                                               
   */
  public StdVectorDouble getIndependentColumn() {
    return new StdVectorDouble(opensimCommonJNI.DataTableVec3_getIndependentColumn(swigCPtr, this), false);
  }

  /**
   *  Append column to the DataTable_ using an initializer list.<br>
   *     {@code 
      table.appendColumn("new-column", {1, 2, 3, 4});
      }<br>
   * <br>
   *     @param columnLabel Label of the column to be added. Must not be same as the<br>
   *                        label of an existing column.<br>
   *     @param container Sequence container holding the elements of the column to be<br>
   *                      appended.<br>
   *     @throws InvalidCall If DataTable_ contains no rows at the time of this call.<br>
   *     @throws InvalidArgument If columnLabel specified already exists in the<br>
   *                             DataTable_.<br>
   *     @throws InvalidColumn If the input column contains incorrect number of <br>
   *                           rows.                                               
   */
  public void appendColumn(String columnLabel, SWIGTYPE_p_std__initializer_listT_SimTK__VecT_3_double_1_t_t container) {
    opensimCommonJNI.DataTableVec3_appendColumn__SWIG_1(swigCPtr, this, columnLabel, SWIGTYPE_p_std__initializer_listT_SimTK__VecT_3_double_1_t_t.getCPtr(container));
  }

  /**
   *  Append column to the DataTable_ using a SimTK::Vector.<br>
   * <br>
   *     @param columnLabel Label of the column to be added. Must not be same as the<br>
   *                        label of an existing column.<br>
   *     @param depCol Column vector to be appended to the table.<br>
   * <br>
   *     @throws InvalidCall If DataTable_ contains no rows at the time of this call.<br>
   *     @throws InvalidArgument If columnLabel specified already exists in the<br>
   *                             DataTable_.<br>
   *     @throws InvalidColumn If the input column contains incorrect number of <br>
   *                           rows.                                               
   */
  public void appendColumn(String columnLabel, VectorVec3 depCol) {
    opensimCommonJNI.DataTableVec3_appendColumn__SWIG_3(swigCPtr, this, columnLabel, VectorVec3.getCPtr(depCol), depCol);
  }

  /**
   *  Append column to the DataTable_ using a SimTK::VectorView.<br>
   * <br>
   *     @param columnLabel Label of the column to be added. Must not be same as the<br>
   *                        label of an existing column.<br>
   *     @param depCol Column vector to be appended to the table.<br>
   * <br>
   *     @throws InvalidCall If DataTable_ contains no rows at the time of this call.<br>
   *     @throws InvalidArgument If columnLabel specified already exists in the<br>
   *                             DataTable_.<br>
   *     @throws InvalidColumn If the input column contains incorrect number of <br>
   *                           rows.                                               
   */
  public void appendColumn(String columnLabel, VectorViewVec3 depCol) {
    opensimCommonJNI.DataTableVec3_appendColumn__SWIG_4(swigCPtr, this, columnLabel, VectorViewVec3.getCPtr(depCol), depCol);
  }

  /**
   *  Remove column corresponding to the given column index.<br>
   * <br>
   *     @throws ColumnIndexOutOfRange If the index is out of range.                  
   */
  public void removeColumnAtIndex(long index) {
    opensimCommonJNI.DataTableVec3_removeColumnAtIndex(swigCPtr, this, index);
  }

  /**
   *  Remove column corresponding to the given dependent column label. The<br>
   *     independent column cannot be removed.<br>
   * <br>
   *     @throws KeyNotFound If the independent column has no entry with the given<br>
   *     value.                                                
   */
  public void removeColumn(String columnLabel) {
    opensimCommonJNI.DataTableVec3_removeColumn(swigCPtr, this, columnLabel);
  }

  /**
   *  Get dependent column at index.<br>
   * <br>
   *     @throws EmptyTable If the table is empty.<br>
   *     @throws ColumnIndexOutOfRange If index is out of range for number of columns<br>
   *                                   in the table.                               
   */
  public VectorViewVec3 getDependentColumnAtIndex(long index) {
    return new VectorViewVec3(opensimCommonJNI.DataTableVec3_getDependentColumnAtIndex(swigCPtr, this, index), true);
  }

  /**
   *  Get dependent Column which has the given column label.                <br>
   * <br>
   *     @throws KeyNotFound If columnLabel is not found to be label of any existing<br>
   *                         column.                                               
   */
  public VectorViewVec3 getDependentColumn(String columnLabel) {
    return new VectorViewVec3(opensimCommonJNI.DataTableVec3_getDependentColumn(swigCPtr, this, columnLabel), true);
  }

  /**
   *  Update dependent column at index.<br>
   * <br>
   *     @throws EmptyTable If the table is empty.<br>
   *     @throws ColumnIndexOutOfRange If index is out of range for number of columns<br>
   *                                   in the table.                               
   */
  public VectorViewVec3 updDependentColumnAtIndex(long index) {
    return new VectorViewVec3(opensimCommonJNI.DataTableVec3_updDependentColumnAtIndex(swigCPtr, this, index), true);
  }

  /**
   *  Update dependent Column which has the given column label.<br>
   * <br>
   *     @throws KeyNotFound If columnLabel is not found to be label of any existing<br>
   *                         column.                                               
   */
  public VectorViewVec3 updDependentColumn(String columnLabel) {
    return new VectorViewVec3(opensimCommonJNI.DataTableVec3_updDependentColumn(swigCPtr, this, columnLabel), true);
  }

  /**
   *  %Set value of the independent column at index.<br>
   * <br>
   *     @throws EmptyTable If the table is empty.<br>
   *     @throws RowIndexOutOfRange If rowIndex is out of range.<br>
   *     @throws InvalidRow If this operation invalidates the row. Validation is<br>
   *                        performed by derived classes.                          
   */
  public void setIndependentValueAtIndex(long rowIndex, double value) {
    opensimCommonJNI.DataTableVec3_setIndependentValueAtIndex(swigCPtr, this, rowIndex, value);
  }

  /**
   *  <br>
   *  Following functions operate on the matrix not including the independent<br>
   *  column.<br>
   *  Get a read-only view to the underlying matrix.                        
   */
  public MatrixViewVec3 getMatrix() {
    return new MatrixViewVec3(opensimCommonJNI.DataTableVec3_getMatrix(swigCPtr, this), false);
  }

  /**
   *  Get a read-only view of a block of the underlying matrix.             <br>
   * <br>
   *     @throws InvalidArgument If numRows or numColumns is zero.<br>
   *     @throws EmptyTable If the table is empty.<br>
   *     @throws RowIndexOutOfRange If one or more rows of the desired block is out<br>
   *                                of range of the matrix.<br>
   *     @throws ColumnIndexOutOfRange If one or more columns of the desired block is<br>
   *                                   out of range of the matrix.                 
   */
  public MatrixViewVec3 getMatrixBlock(long rowStart, long columnStart, long numRows, long numColumns) {
    return new MatrixViewVec3(opensimCommonJNI.DataTableVec3_getMatrixBlock(swigCPtr, this, rowStart, columnStart, numRows, numColumns), true);
  }

  /**
   *  Get a writable view to the underlying matrix.                         
   */
  public MatrixViewVec3 updMatrix() {
    return new MatrixViewVec3(opensimCommonJNI.DataTableVec3_updMatrix(swigCPtr, this), false);
  }

  /**
   *  Get a writable view of a block of the underlying matrix.<br>
   * <br>
   *     @throws InvalidArgument If numRows or numColumns is zero.<br>
   *     @throws EmptyTable If the table is empty.<br>
   *     @throws RowIndexOutOfRange If one or more rows of the desired block is out<br>
   *                                of range of the matrix.<br>
   *     @throws ColumnIndexOutOfRange If one or more columns of the desired block is<br>
   *                                   out of range of the matrix.                 
   */
  public MatrixViewVec3 updMatrixBlock(long rowStart, long columnStart, long numRows, long numColumns) {
    return new MatrixViewVec3(opensimCommonJNI.DataTableVec3_updMatrixBlock(swigCPtr, this, rowStart, columnStart, numRows, numColumns), true);
  }

  /**
   *  Get a string representation of the table, including the key-value pairs<br>
   *     in the table metadata. Table metadata will be of the form:<br>
   *     {@code 
      key => value-converted-to-string
      }<br>
   *     For example:<br>
   *     {@code 
      DataRate => 2000.00000
      Units => mm
      }<br>
   *     For values in the table metadata that do not support the operation of stream<br>
   *     insertion (operator&lt;<), the value for metadata will be:<br>
   *     {@code 
      key => <cannot-convert-to-string>
      }<br>
   *     Some examples to call this function:<br>
   *     {@code 
  All rows, all columns.
      auto tableAsString = table.toString();
  First 5 rows, all columns.
      auto tableAsString = table.toString({0, 1, 2, 3, 4});
  All rows, 3 columns with specified labels.
      auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
  Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in 
  that order).
      auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
  Lets say the table has 10 rows. Following will get last 3 rows in the 
  order specified. All columns.
      auto tableAsString = table.toString({-1, -2, -3})
      }<br>
   * <br>
   *     @param rows **[Default = all rows]** Sequence of indices of rows to be <br>
   *                 printed. Rows will be printed exactly in the order specified in <br>
   *                 the sequence. Index begins at 0 (i.e. first row is 0). Negative<br>
   *                 indices refer to rows starting from last row. Index -1 refers to<br>
   *                 last row, -2 refers to row previous to last row and so on.<br>
   *                 Default behavior is to print all rows. <br>
   *     @param columnLabels **[Default = all rows]** Sequence of labels of columns <br>
   *                         to be printed. Columns will be printed exactly in the <br>
   *                         order specified in the sequence. Default behavior is to <br>
   *                         print all columns.<br>
   *     @param withMetaData **[Default = true]** Whether or not table metadata <br>
   *                         should be printed. Default behavior is to print table <br>
   *                         metadata.<br>
   *     @param splitSize **[Default = 25]** Number of rows to print at a time. <br>
   *                      Default behavior is to print 25 rows at a time. <br>
   *     @param maxWidth **[Default = 80]** Maximum number of characters to print per<br>
   *                     line. The columns are split accordingly to make the table <br>
   *                     readable. This is useful in terminals/consoles with narrow <br>
   *                     width. Default behavior is to limit number characters per <br>
   *                     line to 80.<br>
   *     @param precision **[Default = 4]** Precision of the floating-point numbers <br>
   *                      printed. Default behavior is to print floating-point <br>
   *                      numbers with 4 places to the right of decimal point.     
   */
  public String toString(StdVectorInt rows, StdVectorString columnLabels, boolean withMetaData, long splitSize, long maxWidth, long precision) {
    return opensimCommonJNI.DataTableVec3_toString__SWIG_0(swigCPtr, this, StdVectorInt.getCPtr(rows), rows, StdVectorString.getCPtr(columnLabels), columnLabels, withMetaData, splitSize, maxWidth, precision);
  }

  /**
   *  Get a string representation of the table, including the key-value pairs<br>
   *     in the table metadata. Table metadata will be of the form:<br>
   *     {@code 
      key => value-converted-to-string
      }<br>
   *     For example:<br>
   *     {@code 
      DataRate => 2000.00000
      Units => mm
      }<br>
   *     For values in the table metadata that do not support the operation of stream<br>
   *     insertion (operator&lt;<), the value for metadata will be:<br>
   *     {@code 
      key => <cannot-convert-to-string>
      }<br>
   *     Some examples to call this function:<br>
   *     {@code 
  All rows, all columns.
      auto tableAsString = table.toString();
  First 5 rows, all columns.
      auto tableAsString = table.toString({0, 1, 2, 3, 4});
  All rows, 3 columns with specified labels.
      auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
  Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in 
  that order).
      auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
  Lets say the table has 10 rows. Following will get last 3 rows in the 
  order specified. All columns.
      auto tableAsString = table.toString({-1, -2, -3})
      }<br>
   * <br>
   *     @param rows **[Default = all rows]** Sequence of indices of rows to be <br>
   *                 printed. Rows will be printed exactly in the order specified in <br>
   *                 the sequence. Index begins at 0 (i.e. first row is 0). Negative<br>
   *                 indices refer to rows starting from last row. Index -1 refers to<br>
   *                 last row, -2 refers to row previous to last row and so on.<br>
   *                 Default behavior is to print all rows. <br>
   *     @param columnLabels **[Default = all rows]** Sequence of labels of columns <br>
   *                         to be printed. Columns will be printed exactly in the <br>
   *                         order specified in the sequence. Default behavior is to <br>
   *                         print all columns.<br>
   *     @param withMetaData **[Default = true]** Whether or not table metadata <br>
   *                         should be printed. Default behavior is to print table <br>
   *                         metadata.<br>
   *     @param splitSize **[Default = 25]** Number of rows to print at a time. <br>
   *                      Default behavior is to print 25 rows at a time. <br>
   *     @param maxWidth **[Default = 80]** Maximum number of characters to print per<br>
   *                     line. The columns are split accordingly to make the table <br>
   *                     readable. This is useful in terminals/consoles with narrow <br>
   *                     width. Default behavior is to limit number characters per <br>
   *                     line to 80.<br>
   *     
   */
  public String toString(StdVectorInt rows, StdVectorString columnLabels, boolean withMetaData, long splitSize, long maxWidth) {
    return opensimCommonJNI.DataTableVec3_toString__SWIG_1(swigCPtr, this, StdVectorInt.getCPtr(rows), rows, StdVectorString.getCPtr(columnLabels), columnLabels, withMetaData, splitSize, maxWidth);
  }

  /**
   *  Get a string representation of the table, including the key-value pairs<br>
   *     in the table metadata. Table metadata will be of the form:<br>
   *     {@code 
      key => value-converted-to-string
      }<br>
   *     For example:<br>
   *     {@code 
      DataRate => 2000.00000
      Units => mm
      }<br>
   *     For values in the table metadata that do not support the operation of stream<br>
   *     insertion (operator&lt;<), the value for metadata will be:<br>
   *     {@code 
      key => <cannot-convert-to-string>
      }<br>
   *     Some examples to call this function:<br>
   *     {@code 
  All rows, all columns.
      auto tableAsString = table.toString();
  First 5 rows, all columns.
      auto tableAsString = table.toString({0, 1, 2, 3, 4});
  All rows, 3 columns with specified labels.
      auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
  Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in 
  that order).
      auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
  Lets say the table has 10 rows. Following will get last 3 rows in the 
  order specified. All columns.
      auto tableAsString = table.toString({-1, -2, -3})
      }<br>
   * <br>
   *     @param rows **[Default = all rows]** Sequence of indices of rows to be <br>
   *                 printed. Rows will be printed exactly in the order specified in <br>
   *                 the sequence. Index begins at 0 (i.e. first row is 0). Negative<br>
   *                 indices refer to rows starting from last row. Index -1 refers to<br>
   *                 last row, -2 refers to row previous to last row and so on.<br>
   *                 Default behavior is to print all rows. <br>
   *     @param columnLabels **[Default = all rows]** Sequence of labels of columns <br>
   *                         to be printed. Columns will be printed exactly in the <br>
   *                         order specified in the sequence. Default behavior is to <br>
   *                         print all columns.<br>
   *     @param withMetaData **[Default = true]** Whether or not table metadata <br>
   *                         should be printed. Default behavior is to print table <br>
   *                         metadata.<br>
   *     @param splitSize **[Default = 25]** Number of rows to print at a time. <br>
   *                      Default behavior is to print 25 rows at a time. <br>
   *     
   */
  public String toString(StdVectorInt rows, StdVectorString columnLabels, boolean withMetaData, long splitSize) {
    return opensimCommonJNI.DataTableVec3_toString__SWIG_2(swigCPtr, this, StdVectorInt.getCPtr(rows), rows, StdVectorString.getCPtr(columnLabels), columnLabels, withMetaData, splitSize);
  }

  /**
   *  Get a string representation of the table, including the key-value pairs<br>
   *     in the table metadata. Table metadata will be of the form:<br>
   *     {@code 
      key => value-converted-to-string
      }<br>
   *     For example:<br>
   *     {@code 
      DataRate => 2000.00000
      Units => mm
      }<br>
   *     For values in the table metadata that do not support the operation of stream<br>
   *     insertion (operator&lt;<), the value for metadata will be:<br>
   *     {@code 
      key => <cannot-convert-to-string>
      }<br>
   *     Some examples to call this function:<br>
   *     {@code 
  All rows, all columns.
      auto tableAsString = table.toString();
  First 5 rows, all columns.
      auto tableAsString = table.toString({0, 1, 2, 3, 4});
  All rows, 3 columns with specified labels.
      auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
  Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in 
  that order).
      auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
  Lets say the table has 10 rows. Following will get last 3 rows in the 
  order specified. All columns.
      auto tableAsString = table.toString({-1, -2, -3})
      }<br>
   * <br>
   *     @param rows **[Default = all rows]** Sequence of indices of rows to be <br>
   *                 printed. Rows will be printed exactly in the order specified in <br>
   *                 the sequence. Index begins at 0 (i.e. first row is 0). Negative<br>
   *                 indices refer to rows starting from last row. Index -1 refers to<br>
   *                 last row, -2 refers to row previous to last row and so on.<br>
   *                 Default behavior is to print all rows. <br>
   *     @param columnLabels **[Default = all rows]** Sequence of labels of columns <br>
   *                         to be printed. Columns will be printed exactly in the <br>
   *                         order specified in the sequence. Default behavior is to <br>
   *                         print all columns.<br>
   *     @param withMetaData **[Default = true]** Whether or not table metadata <br>
   *                         should be printed. Default behavior is to print table <br>
   *                         metadata.<br>
   *     
   */
  public String toString(StdVectorInt rows, StdVectorString columnLabels, boolean withMetaData) {
    return opensimCommonJNI.DataTableVec3_toString__SWIG_3(swigCPtr, this, StdVectorInt.getCPtr(rows), rows, StdVectorString.getCPtr(columnLabels), columnLabels, withMetaData);
  }

  /**
   *  Get a string representation of the table, including the key-value pairs<br>
   *     in the table metadata. Table metadata will be of the form:<br>
   *     {@code 
      key => value-converted-to-string
      }<br>
   *     For example:<br>
   *     {@code 
      DataRate => 2000.00000
      Units => mm
      }<br>
   *     For values in the table metadata that do not support the operation of stream<br>
   *     insertion (operator&lt;<), the value for metadata will be:<br>
   *     {@code 
      key => <cannot-convert-to-string>
      }<br>
   *     Some examples to call this function:<br>
   *     {@code 
  All rows, all columns.
      auto tableAsString = table.toString();
  First 5 rows, all columns.
      auto tableAsString = table.toString({0, 1, 2, 3, 4});
  All rows, 3 columns with specified labels.
      auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
  Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in 
  that order).
      auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
  Lets say the table has 10 rows. Following will get last 3 rows in the 
  order specified. All columns.
      auto tableAsString = table.toString({-1, -2, -3})
      }<br>
   * <br>
   *     @param rows **[Default = all rows]** Sequence of indices of rows to be <br>
   *                 printed. Rows will be printed exactly in the order specified in <br>
   *                 the sequence. Index begins at 0 (i.e. first row is 0). Negative<br>
   *                 indices refer to rows starting from last row. Index -1 refers to<br>
   *                 last row, -2 refers to row previous to last row and so on.<br>
   *                 Default behavior is to print all rows. <br>
   *     @param columnLabels **[Default = all rows]** Sequence of labels of columns <br>
   *                         to be printed. Columns will be printed exactly in the <br>
   *                         order specified in the sequence. Default behavior is to <br>
   *                         print all columns.<br>
   *     
   */
  public String toString(StdVectorInt rows, StdVectorString columnLabels) {
    return opensimCommonJNI.DataTableVec3_toString__SWIG_4(swigCPtr, this, StdVectorInt.getCPtr(rows), rows, StdVectorString.getCPtr(columnLabels), columnLabels);
  }

  /**
   *  Get a string representation of the table, including the key-value pairs<br>
   *     in the table metadata. Table metadata will be of the form:<br>
   *     {@code 
      key => value-converted-to-string
      }<br>
   *     For example:<br>
   *     {@code 
      DataRate => 2000.00000
      Units => mm
      }<br>
   *     For values in the table metadata that do not support the operation of stream<br>
   *     insertion (operator&lt;<), the value for metadata will be:<br>
   *     {@code 
      key => <cannot-convert-to-string>
      }<br>
   *     Some examples to call this function:<br>
   *     {@code 
  All rows, all columns.
      auto tableAsString = table.toString();
  First 5 rows, all columns.
      auto tableAsString = table.toString({0, 1, 2, 3, 4});
  All rows, 3 columns with specified labels.
      auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
  Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in 
  that order).
      auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
  Lets say the table has 10 rows. Following will get last 3 rows in the 
  order specified. All columns.
      auto tableAsString = table.toString({-1, -2, -3})
      }<br>
   * <br>
   *     @param rows **[Default = all rows]** Sequence of indices of rows to be <br>
   *                 printed. Rows will be printed exactly in the order specified in <br>
   *                 the sequence. Index begins at 0 (i.e. first row is 0). Negative<br>
   *                 indices refer to rows starting from last row. Index -1 refers to<br>
   *                 last row, -2 refers to row previous to last row and so on.<br>
   *                 Default behavior is to print all rows. <br>
   *     
   */
  public String toString(StdVectorInt rows) {
    return opensimCommonJNI.DataTableVec3_toString__SWIG_5(swigCPtr, this, StdVectorInt.getCPtr(rows), rows);
  }

  /**
   *  Get a string representation of the table, including the key-value pairs<br>
   *     in the table metadata. Table metadata will be of the form:<br>
   *     {@code 
      key => value-converted-to-string
      }<br>
   *     For example:<br>
   *     {@code 
      DataRate => 2000.00000
      Units => mm
      }<br>
   *     For values in the table metadata that do not support the operation of stream<br>
   *     insertion (operator&lt;<), the value for metadata will be:<br>
   *     {@code 
      key => <cannot-convert-to-string>
      }<br>
   *     Some examples to call this function:<br>
   *     {@code 
  All rows, all columns.
      auto tableAsString = table.toString();
  First 5 rows, all columns.
      auto tableAsString = table.toString({0, 1, 2, 3, 4});
  All rows, 3 columns with specified labels.
      auto tableAsString = table.toString({}, {"col12", "col35", "col4"});
  Rows 5th, 3rd, 1st (in that order) and columns with specified labels (in 
  that order).
      auto tableAsString = table.toString({4, 2, 0}, {"col10", "col5", "col2"});
  Lets say the table has 10 rows. Following will get last 3 rows in the 
  order specified. All columns.
      auto tableAsString = table.toString({-1, -2, -3})
      }<br>
   * <br>
   *     
   */
  public String toString() {
    return opensimCommonJNI.DataTableVec3_toString__SWIG_6(swigCPtr, this);
  }

  public DataTableVec3 clone() {
    long cPtr = opensimCommonJNI.DataTableVec3_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new DataTableVec3(cPtr, true);
  }

}
