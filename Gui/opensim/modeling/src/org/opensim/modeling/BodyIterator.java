/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  Class used to iterate over subcomponents of a specific type (by default,<br>
 * any Component).<br>
 * This iterator is can either be a const_iterator or non-const iterator, depending<br>
 * on how you got it. If this is a const_iterator, it returns only a const<br>
 * reference to a component. If this is a non-const iterator, then it returns<br>
 * a non-const reference to a component, and thus you can modify the component.<br>
 * <br>
 * If you got this iterator from something like a ComponentList&lt;const Body&gt;, then<br>
 * it is necessarily a const_iterator. If you got this iterator from something like<br>
 * ComponentList<body>, then this may be either a const_iterator (e.g., from<br>
 * ComponentList<body>::cbegin()) or non-const iterator (e.g.,<br>
 * from ComponentList<body>::begin()).<br>
 * <br>
 * If you have a non-const iterator, you should *not* add (sub)components to any<br>
 * components.<br>
 * <br>
 * This iterator works only in the forward direction (not bidirectional).<br>
 * <br>
 * Here is an example of using this iterator with a range for loop (const_iterator):<br>
 * {@code 
ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
for (const GeometryPath& gpath : geomPathList) {
do something with gpath
}
}<br>
 * <br>
 * Here is a similar example, but where you can modify the components:<br>
 * {@code 
ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
for (GeometryPath& gpath : geomPathList) {
do something with gpath
}
}
 */
public class BodyIterator {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public BodyIterator(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(BodyIterator obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(BodyIterator obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_BodyIterator(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  @ Comparison operators for scripting<br>
   *  These variants accept only an iterator with the same template parameter.<br>
   *  <br>
   *  Check for (non)equality using a normal method rather than an operator.
   */
  public boolean equals(BodyIterator other) {
    return opensimSimulationJNI.BodyIterator_equals(swigCPtr, this, BodyIterator.getCPtr(other), other);
  }

  /**
   *  Dereference the iterator to get a reference to Component of proper<br>
   *     type (matching Filter if specified). If you have a const iterator, then<br>
   *     this returns a const reference; otherwise, this returns a non-const<br>
   *     reference. 
   */
  public Body __ref__() {
    return new Body(opensimSimulationJNI.BodyIterator___ref__(swigCPtr, this), false);
  }

  public Body deref() {
    return new Body(opensimSimulationJNI.BodyIterator_deref(swigCPtr, this), false);
  }

  /**
   *  Another dereferencing operator that returns a pointer.
   */
  public Body __deref__() {
    long cPtr = opensimSimulationJNI.BodyIterator___deref__(swigCPtr, this);
    return (cPtr == 0) ? null : new Body(cPtr, false);
  }

  /**
   *  Method equivalent to pre-increment operator for operator-deficient<br>
   *      languages. 
   */
  public BodyIterator next() {
    return new BodyIterator(opensimSimulationJNI.BodyIterator_next(swigCPtr, this), false);
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.BodyIterator_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Body(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.BodyIterator_getConcreteClassName(swigCPtr, this);
  }

  public double get_mass(int i) {
    return opensimSimulationJNI.BodyIterator_get_mass__SWIG_0(swigCPtr, this, i);
  }

  public double get_mass() {
    return opensimSimulationJNI.BodyIterator_get_mass__SWIG_1(swigCPtr, this);
  }

  public Vec3 get_mass_center(int i) {
    return new Vec3(opensimSimulationJNI.BodyIterator_get_mass_center__SWIG_0(swigCPtr, this, i), false);
  }

  public Vec3 get_mass_center() {
    return new Vec3(opensimSimulationJNI.BodyIterator_get_mass_center__SWIG_1(swigCPtr, this), false);
  }

  public Vec6 get_inertia(int i) {
    return new Vec6(opensimSimulationJNI.BodyIterator_get_inertia__SWIG_0(swigCPtr, this, i), false);
  }

  public Vec6 get_inertia() {
    return new Vec6(opensimSimulationJNI.BodyIterator_get_inertia__SWIG_1(swigCPtr, this), false);
  }

  /**
   *  Access Properties of the Body  The mass of the body in kg 
   */
  public double getMass() {
    return opensimSimulationJNI.BodyIterator_getMass(swigCPtr, this);
  }

  /**
   *  The body center of mass location (Vec3) in the Body frame. 
   */
  public Vec3 getMassCenter() {
    return new Vec3(opensimSimulationJNI.BodyIterator_getMassCenter(swigCPtr, this), false);
  }

  /**
   *  The body's inertia about the center of mass location. 
   */
  public Inertia getInertia() {
    return new Inertia(opensimSimulationJNI.BodyIterator_getInertia__SWIG_0(swigCPtr, this), false);
  }

  /**
   *  Assemble body inertial properties: mass, center of mass location, moment <br>
   *         of inertia about the origin of the body and return as<br>
   *         SimTK::MassProperties.
   */
  public MassProperties getMassProperties() {
    return new MassProperties(opensimSimulationJNI.BodyIterator_getMassProperties(swigCPtr, this), true);
  }

  public WrapObjectSet get_WrapObjectSet(int i) {
    return new WrapObjectSet(opensimSimulationJNI.BodyIterator_get_WrapObjectSet__SWIG_0(swigCPtr, this, i), false);
  }

  public WrapObjectSet get_WrapObjectSet() {
    return new WrapObjectSet(opensimSimulationJNI.BodyIterator_get_WrapObjectSet__SWIG_1(swigCPtr, this), false);
  }

  /**
   * <br>
   *     This method returns the MobilizedBodyIndex of the MobilizedBody for this<br>
   *     PhysicalFrame. This index is only available after Model::initSystem() has<br>
   *     been invoked.<br>
   * <br>
   *     The MobilizedBodyIndex is necessary to access the underlying MobilizedBody<br>
   *     in the System. It allows access to physical quantities (e.g. forces)<br>
   *     associated with individual PhysicalFrames. For examples, the underlying<br>
   *     MultibodySystem's net body forces are represented as a Vector of spatial<br>
   *     forces (torque and force on each body) and it is indexed by the <br>
   *     MobilizedBodyIndex.<br>
   * <br>
   *     @return index The MobilizedBodyIndex corresponding to this PhysicalFrame's<br>
   *                underlying MobilizedBody<br>
   * <br>
   *     @see getMobilizedBody, updMobilizedBody
   */
  public int getMobilizedBodyIndex() {
    return opensimSimulationJNI.BodyIterator_getMobilizedBodyIndex(swigCPtr, this);
  }

  /**
   *     Access a readable SimTK::MobilizedBody that backs this PhysicalFrame.<br>
   *     The MobilizedBody is only available after Model::initSystem() has been<br>
   *     invoked.<br>
   *     @see getMobilizedBodyIndex
   */
  public SWIGTYPE_p_SimTK__MobilizedBody getMobilizedBody() {
    return new SWIGTYPE_p_SimTK__MobilizedBody(opensimSimulationJNI.BodyIterator_getMobilizedBody(swigCPtr, this), false);
  }

  /**
   * <br>
   * Deprecated methods for intermediate integration of Frames  Get the named wrap object, if it exists.<br>
   * <br>
   * @param aName Name of the wrap object.<br>
   * @return const Pointer to the wrap object.
   */
  public WrapObject getWrapObject(String aName) {
    long cPtr = opensimSimulationJNI.BodyIterator_getWrapObject(swigCPtr, this, aName);
    return (cPtr == 0) ? null : new WrapObject(cPtr, false);
  }

  public WrapObjectSet getWrapObjectSet() {
    return new WrapObjectSet(opensimSimulationJNI.BodyIterator_getWrapObjectSet(swigCPtr, this), false);
  }

  public FrameGeometry get_frame_geometry(int i) {
    return new FrameGeometry(opensimSimulationJNI.BodyIterator_get_frame_geometry__SWIG_0(swigCPtr, this, i), false);
  }

  public FrameGeometry get_frame_geometry() {
    return new FrameGeometry(opensimSimulationJNI.BodyIterator_get_frame_geometry__SWIG_1(swigCPtr, this), false);
  }

  public Geometry get_attached_geometry(int i) {
    return new Geometry(opensimSimulationJNI.BodyIterator_get_attached_geometry(swigCPtr, this, i), false);
  }

  public boolean get_has_output_position() {
    return opensimSimulationJNI.BodyIterator__has_output_position_get(swigCPtr, this);
  }

  public boolean get_has_output_rotation() {
    return opensimSimulationJNI.BodyIterator__has_output_rotation_get(swigCPtr, this);
  }

  public boolean get_has_output_transform() {
    return opensimSimulationJNI.BodyIterator__has_output_transform_get(swigCPtr, this);
  }

  public boolean get_has_output_velocity() {
    return opensimSimulationJNI.BodyIterator__has_output_velocity_get(swigCPtr, this);
  }

  public boolean get_has_output_angular_velocity() {
    return opensimSimulationJNI.BodyIterator__has_output_angular_velocity_get(swigCPtr, this);
  }

  public boolean get_has_output_linear_velocity() {
    return opensimSimulationJNI.BodyIterator__has_output_linear_velocity_get(swigCPtr, this);
  }

  public boolean get_has_output_acceleration() {
    return opensimSimulationJNI.BodyIterator__has_output_acceleration_get(swigCPtr, this);
  }

  public boolean get_has_output_angular_acceleration() {
    return opensimSimulationJNI.BodyIterator__has_output_angular_acceleration_get(swigCPtr, this);
  }

  public boolean get_has_output_linear_acceleration() {
    return opensimSimulationJNI.BodyIterator__has_output_linear_acceleration_get(swigCPtr, this);
  }

  /**
   * *<br>
   *     Get the transform of this frame (F) relative to the ground frame (G).<br>
   *     It transforms quantities expressed in F into quantities expressed<br>
   *     in G. This is mathematically stated as:<br>
   *         vec_G = X_GF*vec_F ,<br>
   *     where X_GF is the transform returned by getTransformInGround.<br>
   * <br>
   *     @param state       The state applied to the model when determining the<br>
   *                        transform.<br>
   *     @return transform  The transform between this frame and the ground frame
   */
  public Transform getTransformInGround(State state) {
    return new Transform(opensimSimulationJNI.BodyIterator_getTransformInGround(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *  The spatial velocity V_GF {omega; v} of this Frame, measured with<br>
   *         respect to and expressed in the ground frame. It can be used to compute<br>
   *         the velocity of any stationary point on F, located at r_F (Vec3), in<br>
   *         ground, G, as:<br>
   *             v_G = V_GF[1] + SimTK::cross(V_GF[0], r_F);<br>
   *         Is only valid at Stage::Velocity or higher. 
   */
  public SpatialVec getVelocityInGround(State state) {
    return new SpatialVec(opensimSimulationJNI.BodyIterator_getVelocityInGround(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *  The angular velocity of this Frame, measured with respect to and<br>
   *         expressed in the ground frame (i.e., the first half of the SpatialVec<br>
   *         returned by getVelocityInGround()). 
   */
  public Vec3 getAngularVelocityInGround(State state) {
    return new Vec3(opensimSimulationJNI.BodyIterator_getAngularVelocityInGround(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *  The linear velocity of this Frame, measured with respect to and<br>
   *         expressed in the ground frame (i.e., the second half of the SpatialVec<br>
   *         returned by getVelocityInGround()). 
   */
  public Vec3 getLinearVelocityInGround(State state) {
    return new Vec3(opensimSimulationJNI.BodyIterator_getLinearVelocityInGround(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *  The spatial acceleration A_GF {alpha; a} of this Frame, measured with<br>
   *         respect to and expressed in the ground frame. It can also be used to<br>
   *         compute the acceleration of any stationary point on F, located at r_F<br>
   *         (Vec3), in ground, G, as:<br>
   *             a_G = A_GF[1] + SimTK::cross(A_GF[0], r_F) + <br>
   *                   SimTK::cross(V_GF[0], SimTK::cross(V_GF[0], r_F));<br>
   *         Is only valid at Stage::Acceleration or higher. 
   */
  public SpatialVec getAccelerationInGround(State state) {
    return new SpatialVec(opensimSimulationJNI.BodyIterator_getAccelerationInGround(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *  The angular acceleration of this Frame, measured with respect to and<br>
   *         expressed in the ground frame (i.e., the first half of the SpatialVec<br>
   *         returned by getAccelerationInGround()). 
   */
  public Vec3 getAngularAccelerationInGround(State state) {
    return new Vec3(opensimSimulationJNI.BodyIterator_getAngularAccelerationInGround(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *  The linear acceleration of this Frame, measured with respect to and<br>
   *         expressed in the ground frame (i.e., the second half of the SpatialVec<br>
   *         returned by getAccelerationInGround()). 
   */
  public Vec3 getLinearAccelerationInGround(State state) {
    return new Vec3(opensimSimulationJNI.BodyIterator_getLinearAccelerationInGround(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *     Find the transform that describes this frame (F) relative to another<br>
   *     frame (A). It transforms quantities expressed in F to quantities expressed<br>
   *     in A. This is mathematically stated as:<br>
   *         vec_A = X_AF*vec_F ,<br>
   *     where X_AF is the transform returned by this method.<br>
   * <br>
   *     @param state       The state applied to the model when determining the<br>
   *                        transform.<br>
   *     @param otherFrame  a second frame<br>
   *     @return transform  The transform between this frame and otherFrame
   */
  public Transform findTransformBetween(State state, Frame otherFrame) {
    return new Transform(opensimSimulationJNI.BodyIterator_findTransformBetween(swigCPtr, this, State.getCPtr(state), state, Frame.getCPtr(otherFrame), otherFrame), true);
  }

  /**
   *     Take a vector expressed in this frame (F) and re-express the same vector<br>
   *     in another frame (A). This re-expression accounts for the difference<br>
   *     in orientation between the frames. This is mathematically stated as:<br>
   *         vec_A = R_AF*vec_F<br>
   *     which does not translate the vector. This is intended to re-express<br>
   *     physical vector quantities such as a frame's angular velocity or an<br>
   *     applied force, from one frame to another without changing the physical<br>
   *     quantity. If you have a position vector and want to change the point from<br>
   *     which the position is measured, you want findStationLocationInAnotherFrame().<br>
   * <br>
   *     @param state       The state of the model.<br>
   *     @param vec_F       The vector to be re-expressed.<br>
   *     @param otherFrame  The frame in which the vector will be re-expressed<br>
   *     @return vec_A      The expression of the vector in otherFrame.
   */
  public Vec3 expressVectorInAnotherFrame(State state, Vec3 vec_F, Frame otherFrame) {
    return new Vec3(opensimSimulationJNI.BodyIterator_expressVectorInAnotherFrame(swigCPtr, this, State.getCPtr(state), state, Vec3.getCPtr(vec_F), vec_F, Frame.getCPtr(otherFrame), otherFrame), true);
  }

  /**
   *     Take a vector in this frame (F) and re-express the same vector<br>
   *     in Ground (G). This method is equivalent to expressVectorInAnotherFrame()<br>
   *     where the "other Frame" is always Ground.<br>
   *     @param state       The state of the model.<br>
   *     @param vec_F       The vector to be re-expressed.<br>
   *     @return vec_G      The expression of the vector in Ground.
   */
  public Vec3 expressVectorInGround(State state, Vec3 vec_F) {
    return new Vec3(opensimSimulationJNI.BodyIterator_expressVectorInGround(swigCPtr, this, State.getCPtr(state), state, Vec3.getCPtr(vec_F), vec_F), true);
  }

  /**
   *     Take a station located and expressed in this frame (F) and determine<br>
   *     its location relative to and expressed in another frame (A). The transform<br>
   *     accounts for the difference in orientation and translation between the <br>
   *     frames.<br>
   *     This is mathematically stated as: <br>
   *         loc_A = X_AF*station_F<br>
   * <br>
   *     @param state       The state of the model.<br>
   *     @param station_F   The position Vec3 from frame F's origin to the station.<br>
   *     @param otherFrame  The frame (A) in which the station's location <br>
   *                        will be relative to and expressed.<br>
   *     @return loc_A      The location of the station in another frame (A).
   */
  public Vec3 findStationLocationInAnotherFrame(State state, Vec3 station_F, Frame otherFrame) {
    return new Vec3(opensimSimulationJNI.BodyIterator_findStationLocationInAnotherFrame(swigCPtr, this, State.getCPtr(state), state, Vec3.getCPtr(station_F), station_F, Frame.getCPtr(otherFrame), otherFrame), true);
  }

  /**
   *     Take a station located and expressed in this frame (F) and determine<br>
   *     its location relative to and expressed in Ground (G). This method is<br>
   *     equivalent to findStationLocationInAnotherFrame() where the "other Frame" is<br>
   *     always Ground.<br>
   * <br>
   *     Note that if you have added an OpenSim::Station, you should use the<br>
   *     Station's %getLocationInGround() method instead.<br>
   * <br>
   *     @param state       The state of the model.<br>
   *     @param station_F   The position Vec3 from frame F's origin to the station.<br>
   *     @return loc_G      The location of the station in Ground.
   */
  public Vec3 findStationLocationInGround(State state, Vec3 station_F) {
    return new Vec3(opensimSimulationJNI.BodyIterator_findStationLocationInGround(swigCPtr, this, State.getCPtr(state), state, Vec3.getCPtr(station_F), station_F), true);
  }

  /**
   *     Take a station located and expressed in this frame (F) and determine<br>
   *     its velocity relative to and expressed in Ground (G).<br>
   * <br>
   *     Note that if you have added an OpenSim::Station, you should use the<br>
   *     Station's %getVelocityInGround() method instead.<br>
   * <br>
   *     @param state       The state of the model.<br>
   *     @param station_F   The position Vec3 from frame F's origin to the station.<br>
   *     @return vel_G      The velocity of the station in Ground.
   */
  public Vec3 findStationVelocityInGround(State state, Vec3 station_F) {
    return new Vec3(opensimSimulationJNI.BodyIterator_findStationVelocityInGround(swigCPtr, this, State.getCPtr(state), state, Vec3.getCPtr(station_F), station_F), true);
  }

  /**
   *     Take a station located and expressed in this frame (F) and determine<br>
   *     its acceleration relative to and expressed in Ground (G).<br>
   * <br>
   *     Note that if you have added an OpenSim::Station, you should use the<br>
   *     Station's %getAccelerationInGround() method instead.<br>
   * <br>
   *     @param state       The state of the model.<br>
   *     @param station_F   The position Vec3 from frame F's origin to the station.<br>
   *     @return acc_G      The acceleration of the station in Ground.
   */
  public Vec3 findStationAccelerationInGround(State state, Vec3 station_F) {
    return new Vec3(opensimSimulationJNI.BodyIterator_findStationAccelerationInGround(swigCPtr, this, State.getCPtr(state), state, Vec3.getCPtr(station_F), station_F), true);
  }

  /**
   * *<br>
   * <br>
   *     Find this Frame's base Frame. See the "Advanced" note, above.<br>
   * <br>
   *     @return baseFrame     The Frame that is the base for this Frame.
   */
  public Frame findBaseFrame() {
    return new Frame(opensimSimulationJNI.BodyIterator_findBaseFrame(swigCPtr, this), false);
  }

  /**
   *     Find the equivalent Transform of this Frame (F) in its base (B) Frame.<br>
   *     That is find X_BF, such that vecB = X_BF*vecF<br>
   *     For a Frame that is itself a base, this returns the identity Transform.<br>
   *     @return X_BF     The Transform of F in B
   */
  public Transform findTransformInBaseFrame() {
    return new Transform(opensimSimulationJNI.BodyIterator_findTransformInBaseFrame(swigCPtr, this), true);
  }

  /**
   *  Accessor for position of the origin of the Frame in Ground. 
   */
  public Vec3 getPositionInGround(State state) {
    return new Vec3(opensimSimulationJNI.BodyIterator_getPositionInGround(swigCPtr, this, State.getCPtr(state), state), true);
  }

  /**
   *  Accessor for Rotation matrix of the Frame in Ground. 
   */
  public Rotation getRotationInGround(State state) {
    return new Rotation(opensimSimulationJNI.BodyIterator_getRotationInGround(swigCPtr, this, State.getCPtr(state), state), true);
  }

  /**
   *  Get a const reference to the Model this component is part of. 
   */
  public Model getModel() {
    return new Model(opensimSimulationJNI.BodyIterator_getModel(swigCPtr, this), false);
  }

  /**
   *  Does this ModelComponent have a Model associated with it? 
   */
  public boolean hasModel() {
    return opensimSimulationJNI.BodyIterator_hasModel(swigCPtr, this);
  }

  /**
   *  Have the Component add itself to the underlying computational System 
   */
  public void addToSystem(SWIGTYPE_p_SimTK__MultibodySystem system) {
    opensimSimulationJNI.BodyIterator_addToSystem(swigCPtr, this, SWIGTYPE_p_SimTK__MultibodySystem.getCPtr(system));
  }

  /**
   *  Initialize Component's state variable values from its properties 
   */
  public void initStateFromProperties(State state) {
    opensimSimulationJNI.BodyIterator_initStateFromProperties(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   * Optional method for generating arbitrary display geometry that reflects<br>
   *     this %Component at the specified <i>state</i>. This will be called once to<br>
   *     obtain ground- and body-fixed geometry (with <i>fixed=</i><code>true)</code>, and then<br>
   *     once per frame (with <i>fixed=</i><code>false)</code> to generate on-the-fly geometry such<br>
   *     as rubber band lines, force arrows, labels, or debugging aids.<br>
   * <br>
   *     Please note that there is a precondition that the state passed in to<br>
   *     generateDecorations be realized to Stage::Position. If your component can<br>
   *     visualize quantities realized at Velocity, Dynamics or Acceleration stages,<br>
   *     then you must check that the stage has been realized before using/requesting<br>
   *     stage dependent values. It is forbidden to realize the model to a higher<br>
   *     stage within generateDecorations, because this can trigger costly side-<br>
   *     effects such as evaluating all model forces even when performing a purely<br>
   *     kinematic study.<br>
   * <br>
   *     If you override this method, be sure to invoke the base class method first,<br>
   *     using code like this:<br>
   *     {@code 
      void MyComponent::generateDecorations
         (bool                                        fixed,
          const ModelDisplayHints&                    hints,
          const SimTK::State&                         state,
          SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
      {
  invoke parent class method
          Super::generateDecorations(fixed,hints,state,appendToThis);
  ... your code goes here
  can render velocity dependent quanities if stage is Velocity or higher
          if(state.getSystemStage() >= Stage::Velocity) {
  draw velocity vector for model COM
          }
  can render computed forces if stage is Dynamics or higher
          if(state.getSystemStage() >= Stage::Dynamics) {
  change the length of a force arrow based on the force in N
          }
      }
      }<br>
   * <br>
   *     @param fixed<br>
   *         If <code>true</code>, generate only geometry that is fixed to a PhysicalFrame,<br>
   *         configuration, and velocity. Otherwise generate only such dependent<br>
   *         geometry.<br>
   *     @param hints<br>
   *         See documentation for ModelDisplayHints; you may want to alter the<br>
   *         geometry you generate depending on what you find there. For example,<br>
   *         you can determine whether the user wants to see debug geometry.<br>
   *     @param state<br>
   *         The State for which geometry should be produced. See below for more<br>
   *         information.<br>
   *     @param appendToThis<br>
   *         %Array to which generated geometry should be <i>appended</i> via the<br>
   *         <code>push_back()</code> method.<br>
   * <br>
   *     When called with <i>fixed=</i><code>true</code> only modeling options and parameters<br>
   *     (Instance variables) should affect geometry; time, position, and velocity<br>
   *     should not. In that case OpenSim will already have realized the <i>state</i><br>
   *     through Instance stage. When called with <i>fixed=</i><code>false</code>, you may<br>
   *     consult any relevant value in <i>state</i>. However, to avoid unnecessary<br>
   *     computation, OpenSim guarantees only that <i>state</i> will have been realized<br>
   *     through Position stage; if you need anything higher than that (reaction<br>
   *     forces, for example) you should make sure the <i>state</i> is realized through<br>
   *     Acceleration stage. *
   */
  public void generateDecorations(boolean fixed, ModelDisplayHints hints, State state, ArrayDecorativeGeometry appendToThis) {
    opensimSimulationJNI.BodyIterator_generateDecorations(swigCPtr, this, fixed, ModelDisplayHints.getCPtr(hints), hints, State.getCPtr(state), state, ArrayDecorativeGeometry.getCPtr(appendToThis), appendToThis);
  }

  /**
   * Get the underlying MultibodySystem that this component is connected to.<br>
   * Make sure you have called Model::initSystem() prior to accessing the System.<br>
   * Throws an Exception if the System has not been created or the Component<br>
   * has not added itself to the System.<br>
   * @see hasSystem().  
   */
  public SWIGTYPE_p_SimTK__MultibodySystem getSystem() {
    return new SWIGTYPE_p_SimTK__MultibodySystem(opensimSimulationJNI.BodyIterator_getSystem(swigCPtr, this), false);
  }

  /**
   * Check if this component has an underlying MultibodySystem.<br>
   * Returns false if the System has not been created OR if this<br>
   * Component has not added itself to the System.  
   */
  public boolean hasSystem() {
    return opensimSimulationJNI.BodyIterator_hasSystem(swigCPtr, this);
  }

  /**
   *  Does the provided component already exist anywhere in the ownership<br>
   * tree (not just subcomponents of this component)? 
   */
  public boolean isComponentInOwnershipTree(Component component) {
    return opensimSimulationJNI.BodyIterator_isComponentInOwnershipTree(swigCPtr, this, Component.getCPtr(component), component);
  }

  /**
   *  Get the complete (absolute) pathname for this Component to its ancestral<br>
   * Component, which is the root of the tree to which this Component belongs.<br>
   * For example: a Coordinate Component would have an absolute path name<br>
   * like: `/arm26/elbow_r/flexion`. Accessing a Component by its<br>
   * absolutePathName from root is guaranteed to be unique. The<br>
   * absolutePathName is generated on-the-fly by traversing the ownership tree<br>
   * and, therefore, calling this method is not "free". 
   */
  public String getAbsolutePathString() {
    return opensimSimulationJNI.BodyIterator_getAbsolutePathString(swigCPtr, this);
  }

  /**
   *  Return a ComponentPath of the absolute path of this Component.<br>
   * Note that this has more overhead than calling `getName()` because<br>
   * it traverses up the tree to generate the absolute pathname (and its<br>
   * computational cost is thus a function of depth). Consider other<br>
   * options if this is repeatedly called and efficiency is important.<br>
   * For instance, `getAbsolutePathString()` is faster if you only<br>
   * need the path as a string. 
   */
  public ComponentPath getAbsolutePath() {
    return new ComponentPath(opensimSimulationJNI.BodyIterator_getAbsolutePath(swigCPtr, this), true);
  }

  /**
   *  Get the relative path of this Component with respect to another<br>
   * Component, as a string. 
   */
  public String getRelativePathString(Component wrt) {
    return opensimSimulationJNI.BodyIterator_getRelativePathString(swigCPtr, this, Component.getCPtr(wrt), wrt);
  }

  /**
   *  Get the relative path of this Component with respect to another<br>
   * Component. 
   */
  public ComponentPath getRelativePath(Component wrt) {
    return new ComponentPath(opensimSimulationJNI.BodyIterator_getRelativePath(swigCPtr, this, Component.getCPtr(wrt), wrt), true);
  }

  /**
   *  Query if there is a component (of any type) at the specified<br>
   * path name. For example,<br>
   * {@code 
  bool exists = model.hasComponent("right_elbow/elbow_flexion");
  }<br>
   * checks if `model` has a subcomponent "right_elbow," which has a<br>
   * subcomponent "elbow_flexion." 
   */
  public boolean hasComponent(String pathname) {
    return opensimSimulationJNI.BodyIterator_hasComponent(swigCPtr, this, pathname);
  }

  /**
   *  Similar to the templatized getComponent(), except this returns the<br>
   * component as the generic Component type. This can be used in<br>
   * Python/Java/MATLAB. Here is an example of using this in MATLAB:<br>
   * {@code 
  coord = model.getComponent('right_elbow/elbow_flexion')
  coord.getNumConnectees() % okay; this is a Component method.
  coord.getDefaultClamped() % inaccessible; method on Coordinate.
  Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.
  }<br>
   * <br>
   * %Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  coord = model.getComponent('right_elbow/elbow_flexion')
  coord.getDefaultClamped() # works; no downcasting necessary.
  }
   */
  public Component getComponent(String pathname) {
    return new Component(opensimSimulationJNI.BodyIterator_getComponent(swigCPtr, this, pathname), false);
  }

  /**
   *  Print a list to the console of all components whose absolute path name<br>
   * contains the given string. You might use this if (a) you know the name<br>
   * of a component in your model but don't know its absolute path, (b) if<br>
   * you want to find all components with a given name, or (c) to get a list<br>
   * of all components on the right leg of a model (if all components on the<br>
   * right side have "_r" in their name).<br>
   * <br>
   * A function call like:<br>
   * {@code 
  unsigned num = comp.printComponentsMatching("rotation");
  }<br>
   * may produce output like:<br>
   * {@literal 
  /leg_model/right_hip/rotation
  /leg_model/left_hip/rotation
  }<br>
   * <br>
   * @return The number of matches. 
   */
  public long printComponentsMatching(String substring) {
    return opensimSimulationJNI.BodyIterator_printComponentsMatching(swigCPtr, this, substring);
  }

  /**
   * Get the number of "continuous" state variables maintained by the<br>
   * Component and its subcomponents.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public int getNumStateVariables() {
    return opensimSimulationJNI.BodyIterator_getNumStateVariables(swigCPtr, this);
  }

  /**
   * Get the names of continuous state variables maintained by the<br>
   * Component and its subcomponents. Each variable's name is prepended<br>
   * by its path in the component hierarchy.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public ArrayStr getStateVariableNames() {
    return new ArrayStr(opensimSimulationJNI.BodyIterator_getStateVariableNames(swigCPtr, this), true);
  }

  /**
   * Get the names of discrete state variables maintained by the Component<br>
   * and its subcomponents. Each variable's name is prepended by its path in<br>
   * the component hierarchy.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public ArrayStr getDiscreteVariableNames() {
    return new ArrayStr(opensimSimulationJNI.BodyIterator_getDiscreteVariableNames(swigCPtr, this), true);
  }

  /**
   * Get the names of the modeling options maintained by the Component<br>
   * and its subcomponents. Each options's name is prepended by its path in<br>
   * the component hierarchy.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public ArrayStr getModelingOptionNames() {
    return new ArrayStr(opensimSimulationJNI.BodyIterator_getModelingOptionNames(swigCPtr, this), true);
  }

  /**
   *  Get the number of Sockets in this Component. 
   */
  public int getNumSockets() {
    return opensimSimulationJNI.BodyIterator_getNumSockets(swigCPtr, this);
  }

  /**
   *  Collect and return the names of the sockets in this component. You<br>
   * can use this to iterate through the sockets:<br>
   * {@code 
  for (std::string name : comp.getSocketNames()) {
      const AbstractSocket& socket = getSocket(name);
  }
  } 
   */
  public StdVectorString getSocketNames() {
    return new StdVectorString(opensimSimulationJNI.BodyIterator_getSocketNames(swigCPtr, this), true);
  }

  /**
   *  Get the connectee as an Object. This means you will not have<br>
   * access to the methods on the concrete connectee. This is the method you<br>
   * must use in MATLAB to access the connectee.<br>
   * <br>
   * Example:<br>
   * {@code 
  const Object& obj = joint.getConnectee("parent_frame");
  obj.getName(); // method on Object works.
  obj.getMobilizedBody(); // error: not available.
  }<br>
   * <br>
   * In MATLAB, if you want the concrete type, you need to downcast the<br>
   * Object. Here is an example where you know the "parent_frame" is a Body:<br>
   * {@code 
  f = joint.getConnectee('parent_frame');
  m = Body.safeDownCast(f).getMass();
  }<br>
   * <br>
   * Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  f = joint.getConnectee("parent_frame");
  m = f.getMass() # works (if the parent frame is a body)
  }
   */
  public OpenSimObject getConnectee(String name) {
    return new OpenSimObject(opensimSimulationJNI.BodyIterator_getConnectee__SWIG_2(swigCPtr, this, name), false);
  }

  /**
   *  Get the connectee at the provided index as an Object. This means you<br>
   * will not have access to the methods on the concrete connectee. This is the<br>
   * method you must use in scripts to access the connectee.<br>
   * <br>
   * Example:<br>
   * {@code 
  const Object& obj = controller.getConnectee("actuators", 1);
  obj.getName(); // method on Object works.
  obj.getDefaultControls(); // error: not available.
  }<br>
   * <br>
   * In MATLAB, if you want the concrete type, you need to downcast the<br>
   * Object. Here is an example where you know the "actuators" are Actuators:<br>
   * {@code 
  actu = controller.getConnectee('actuators', 1);
  controls = Actuator.safeDownCast(f).getDefaultControls();
  }<br>
   * <br>
   * Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  actu = controller.getConnectee("actuators", 1);
  controls = actu.getDefaultControls() # works (if 'actu' is an Actuator)
  }
   */
  public OpenSimObject getConnectee(String name, int index) {
    return new OpenSimObject(opensimSimulationJNI.BodyIterator_getConnectee__SWIG_3(swigCPtr, this, name, index), false);
  }

  /**
   * Returns a pointer to the AbstractSocket with a given socket name, or `nullptr`<br>
   * if the socket with the given name does not exist on the component.<br>
   * <br>
   * See `getSocket()` for more details about how the socket is looked up.<br>
   * <br>
   * <b>C++ example</b><br>
   * {@code 
  if (const AbstractSocket* s = component.tryGetSocket("frame")) {
      // do something with *s
  }
  else {
      // handle the no-socket-by-that-name case
  }
  }
   */
  public AbstractSocket tryGetSocket(String name) {
    long cPtr = opensimSimulationJNI.BodyIterator_tryGetSocket(swigCPtr, this, name);
    return (cPtr == 0) ? null : new AbstractSocket(cPtr, false);
  }

  public AbstractSocket getSocket(String name) {
    return new AbstractSocket(opensimSimulationJNI.BodyIterator_getSocket(swigCPtr, this, name), false);
  }

  /**
   *  Access the number of Inputs that this component has. 
   */
  public int getNumInputs() {
    return opensimSimulationJNI.BodyIterator_getNumInputs(swigCPtr, this);
  }

  /**
   *  Access the number of Outputs that this component has. 
   */
  public int getNumOutputs() {
    return opensimSimulationJNI.BodyIterator_getNumOutputs(swigCPtr, this);
  }

  /**
   *  Collect and return the names of Inputs in this component as an<br>
   * std::vector. 
   */
  public StdVectorString getInputNames() {
    return new StdVectorString(opensimSimulationJNI.BodyIterator_getInputNames(swigCPtr, this), true);
  }

  /**
   *  Collect and return the names of Outputs in this component as an<br>
   * std::vector. 
   */
  public StdVectorString getOutputNames() {
    return new StdVectorString(opensimSimulationJNI.BodyIterator_getOutputNames(swigCPtr, this), true);
  }

  /**
   * Get an Input provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get an Input from a Component in the model<br>
   * {@code 
  model.getComponent("/path/to/component").getInput("inputName");
  }<br>
   * <br>
   * If you have not yet called finalizeFromProperties() on this<br>
   * component, this function will update the Input (to tell it which<br>
   * component it's in) before providing it to you.<br>
   * <br>
   * @param name   the name of the Input<br>
   * @return const reference to the AbstractInput
   */
  public AbstractInput getInput(String name) {
    return new AbstractInput(opensimSimulationJNI.BodyIterator_getInput(swigCPtr, this, name), false);
  }

  /**
   * If it exists on the component, returns a pointer to the named `Output`; otherwise,<br>
   * returns a `nullptr`.<br>
   * <br>
   * Related: `getOutput`<br>
   * <br>
   * @param name  the name the `Output` to find<br>
   * @return if it exists, a pointer to the `Output`; otherwise, `nullptr`
   */
  public AbstractOutput tryGetOutput(String name) {
    long cPtr = opensimSimulationJNI.BodyIterator_tryGetOutput(swigCPtr, this, name);
    return (cPtr == 0) ? null : new AbstractOutput(cPtr, false);
  }

  /**
   * Get the Output provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get an Output from a Component in a model<br>
   * {@code 
  model.getComponent("/path/to/component").getOutput("outputName");
  }<br>
   * <br>
   * @param name   the name of the Output<br>
   * @return const reference to the AbstractOutput
   */
  public AbstractOutput getOutput(String name) {
    return new AbstractOutput(opensimSimulationJNI.BodyIterator_getOutput(swigCPtr, this, name), false);
  }

  /**
   * Based on a specified path, get the value of a modeling option.<br>
   * <br>
   * The specified path consists of the name of the modeling option<br>
   * prepended by its absolute or relative path in the component hierarchy.<br>
   * <br>
   * If this component is the owner of the modeling option, the specified<br>
   * path should simply be the name of the modeling option.<br>
   * <br>
   * @param state State in which to set the modeling option.<br>
   * @param path Path of the modeling option in the component hierarchy.<br>
   * @return flag Value of the modeling option.<br>
   * @throws EmptyComponentPath if the specified path is an empty string<br>
   * (i.e., path == "").<br>
   * @throws VariableOwnerNotFoundOnSpecifiedPath if the candidate owner<br>
   * of the modeling option cannot be found at the specified path.<br>
   * @throws VariableNotFound if the specified modeling option cannot be<br>
   * found in the candidate owner.<br>
   * @see Component#resolveVariableNameAndOwner()
   */
  public int getModelingOption(State state, String path) {
    return opensimSimulationJNI.BodyIterator_getModelingOption__SWIG_0(swigCPtr, this, State.getCPtr(state), state, path);
  }

  public int getModelingOption(State state, ComponentPath path) {
    return opensimSimulationJNI.BodyIterator_getModelingOption__SWIG_1(swigCPtr, this, State.getCPtr(state), state, ComponentPath.getCPtr(path), path);
  }

  /**
   * Based on a specified path, set the value of a modeling option.<br>
   * <br>
   * The specified path consists of the name of the modeling option<br>
   * prepended by its absolute or relative path in the component hierarchy.<br>
   * <br>
   * If this component is the owner of the modeling option, the specified<br>
   * path should simply be the name of the modeling option.<br>
   * <br>
   * Note: Successfully setting the value of the modeling option will revert<br>
   * the realization stage back to SimTK::Stage::Instance.<br>
   * <br>
   * @param state State in which to set the modeling option.<br>
   * @param path Path of the modeling option in the component hierarchy.<br>
   * @param flag Value to which to set the modeling option.<br>
   * @throws ModelingOptionMaxExceeded if the flag is greater that the<br>
   * maximum allowed for the specified modeling option.<br>
   * @throws EmptyComponentPath if the specified path is an empty string<br>
   * (i.e., path == "").<br>
   * @throws VariableOwnerNotFoundOnSpecifiedPath if the candidate owner<br>
   * of the modeling option cannot be found at the specified path.<br>
   * @throws VariableNotFound if the specified modeling option cannot be<br>
   * found in the candidate owner.<br>
   * @see Component#resolveVariableNameAndOwner()
   */
  public void setModelingOption(State state, String path, int flag) {
    opensimSimulationJNI.BodyIterator_setModelingOption__SWIG_0(swigCPtr, this, State.getCPtr(state), state, path, flag);
  }

  public void setModelingOption(State state, ComponentPath path, int flag) {
    opensimSimulationJNI.BodyIterator_setModelingOption__SWIG_1(swigCPtr, this, State.getCPtr(state), state, ComponentPath.getCPtr(path), path, flag);
  }

  /**
   * Get the value of a state variable allocated by this Component.<br>
   * <br>
   * To connect this StateVariable as an input to another component (such as<br>
   * a Reporter), use getOutput(name); each state variable has a<br>
   * corresponding Output:<br>
   *  {@code 
   foo.getInput("input1").connect(bar.getOutput(name));
   }<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @param name    the name (string) of the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableValue(State state, String name) {
    return opensimSimulationJNI.BodyIterator_getStateVariableValue__SWIG_0(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Get the value of a state variable allocated by this Component.<br>
   * <br>
   * To connect this StateVariable as an input to another component (such as<br>
   * a Reporter), use getOutput(name); each state variable has a<br>
   * corresponding Output:<br>
   * <br>
   *  {@code 
   foo.getInput("input1").connect(bar.getOutput(name));
   }<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @param path    path to the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableValue(State state, ComponentPath path) {
    return opensimSimulationJNI.BodyIterator_getStateVariableValue__SWIG_1(swigCPtr, this, State.getCPtr(state), state, ComponentPath.getCPtr(path), path);
  }

  /**
   * %Set the value of a state variable allocated by this Component by name.<br>
   * <br>
   * @param state  the State for which to set the value<br>
   * @param name   the name of the state variable<br>
   * @param value  the value to set<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setStateVariableValue(State state, String name, double value) {
    opensimSimulationJNI.BodyIterator_setStateVariableValue(swigCPtr, this, State.getCPtr(state), state, name, value);
  }

  /**
   * Get all values of the state variables allocated by this Component.<br>
   * Includes state variables allocated by its subcomponents.<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @return Vector of state variable values of length getNumStateVariables()<br>
   *                in the order returned by getStateVariableNames()<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public Vector getStateVariableValues(State state) {
    return new Vector(opensimSimulationJNI.BodyIterator_getStateVariableValues(swigCPtr, this, State.getCPtr(state), state), true);
  }

  /**
   * %Set all values of the state variables allocated by this Component.<br>
   * Includes state variables allocated by its subcomponents. Note, this<br>
   * method simply sets the values on the input State. If other conditions<br>
   * must be met (such as satisfying kinematic constraints for Coordinates,<br>
   * or fiber and tendon equilibrium for muscles) you must invoke the<br>
   * appropriate methods on Model (e.g. assemble() to satisfy constraints or<br>
   * equilibrateMuscles()) to satisfy these conditions starting from the<br>
   * State values provided by setStateVariableValues.<br>
   * <br>
   * @param state   the State whose values are set<br>
   * @param values  Vector of state variable values of length<br>
   *                getNumStateVariables() in the order returned by<br>
   *                getStateVariableNames()<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setStateVariableValues(State state, Vector values) {
    opensimSimulationJNI.BodyIterator_setStateVariableValues(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(values), values);
  }

  /**
   * Get the value of a state variable derivative computed by this Component.<br>
   * <br>
   * @param state   the State for which to get the derivative value<br>
   * @param name    the name (string) of the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableDerivativeValue(State state, String name) {
    return opensimSimulationJNI.BodyIterator_getStateVariableDerivativeValue__SWIG_0(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Get the value of a state variable derivative computed by this Component.<br>
   * <br>
   * @param state   the State for which to get the derivative value<br>
   * @param path    path to the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableDerivativeValue(State state, ComponentPath path) {
    return opensimSimulationJNI.BodyIterator_getStateVariableDerivativeValue__SWIG_1(swigCPtr, this, State.getCPtr(state), state, ComponentPath.getCPtr(path), path);
  }

  /**
   * Based on a specified path, resolve the name of a state variable,<br>
   * discrete variable, or modeling option and resolve the component that<br>
   * owns it (i.e., its parent).<br>
   * <br>
   * The path consists of the name of the state variable, discrete variable,<br>
   * or modeling option prepended by its absolute or relative path in the<br>
   * component hierarchy.<br>
   * <br>
   * This method does not verify that the variable or option can actually be<br>
   * found at the spcified path. It simply parses the path, returning the<br>
   * variable name and candidate owner.<br>
   * <br>
   * Note: Calling Component::traversPathToComponent&lt;Component&gt;() will not<br>
   * work for state variables, discrete variables, and modeling options<br>
   * because these obects are not themselves Components. However, a pointer<br>
   * to a StateVariable can be obtained in a single step by calling<br>
   * Component::traverseToStateVariable(). A similar dedicated method is not<br>
   * available for discrete variables or for modeling options.<br>
   * <br>
   * #### Example Paths<br>
   * <br>
   * A relative path in which this component is the owner:<br>
   *   ```variable_name```<br>
   * <br>
   * An absolute path from the root of the component hierarchy:<br>
   *   ```/grandparent_name/parent_name/variable_name```<br>
   * <br>
   * A relative path in which a sibling of this component is the owner:<br>
   *   ```../sibling_name/variable_name```<br>
   * <br>
   * @param path Path of the state variable, discrete variable, or modeling<br>
   * option in the component heirarchy.<br>
   * @param varName The name of the state variable, discrete variable,<br>
   * or modeling option is returned in this parameter.<br>
   * @return Pointer to the component that, according to the path, owns the<br>
   * state variable, discrete variable, or modeling option. If the specified<br>
   * path consists only of the name of the state variable, discrete variable,<br>
   * or modeling option, a pointer to this component is returned.<br>
   * @throws EmptyComponentPath if the specified path is an empty string<br>
   * (i.e., path == "").<br>
   * @throws VariableOwnerNotFoundOnSpecifiedPath if the candidate owner<br>
   * cannot be found at the specified path.
   */
  public Component resolveVariableNameAndOwner(ComponentPath path, SWIGTYPE_p_std__string varName) {
    long cPtr = opensimSimulationJNI.BodyIterator_resolveVariableNameAndOwner(swigCPtr, this, ComponentPath.getCPtr(path), path, SWIGTYPE_p_std__string.getCPtr(varName));
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   * Based on a specified path, get the value of a discrete variable.<br>
   * <br>
   * The specified path consists of the name of the discrete variable<br>
   * prepended by its absolute or relative path in the component hierarchy.<br>
   * <br>
   * If this component is the owner of the discrete variable, the specified<br>
   * path should simply be the name of the discrete variable.<br>
   * <br>
   * @param state State from which to get the value.<br>
   * @param path Path of the discrete variable in the component hierarchy.<br>
   * @return Value of the discrete variable.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   * System (i.e., if initSystem has not been called).<br>
   * @throws EmptyComponentPath if the specified path is an empty string<br>
   * (i.e., path == "").<br>
   * @throws VariableOwnerNotFoundOnSpecifiedPath if the candidate owner<br>
   * of the variable cannot be found at the specified path.<br>
   * @throws VariableNotFound if the specified variable cannot be found in<br>
   * the candidate owner.<br>
   * @see Component#resolveVariableNameAndOwner()
   */
  public double getDiscreteVariableValue(State state, String path) {
    return opensimSimulationJNI.BodyIterator_getDiscreteVariableValue(swigCPtr, this, State.getCPtr(state), state, path);
  }

  /**
   * Based on a specified path, retrieve a read-only reference to the<br>
   * abstract value of the discrete variable at a specified path. This method<br>
   * provides a more general interface that is not limited to values of type<br>
   * double.<br>
   * <br>
   * The specified path consists of the name of the discrete variable<br>
   * prepended by its absolute or relative path in the component hierarchy.<br>
   * <br>
   * If this component is the owner of the discrete variable, the specified<br>
   * path should simply be the name of the discrete variable.<br>
   * <br>
   * To obtain the type-specific value of a discrete variable from an<br>
   * AbstractValue, perform a cast using the templated methods provided in<br>
   * class SimTK::Value&lt;T&gt;. When the type is unknown, it can be queried using<br>
   * the SimTK::Value&lt;T&gt;::isA() method. For example,<br>
   * <br>
   * ```<br>
   *      const SimTK::AbstractValue&amp; valAbstract =<br>
   *          getDiscreteVariableAbstractValue(state, pathName);<br>
   * <br>
   *      if (SimTK::Value&lt;double&gt;::isA(valAbstract)) {<br>
   *          const SimTK::Value&lt;double&gt;&amp; valDbl =<br>
   *              SimTK::Value&lt;double&gt;::downcast(valAbstract);<br>
   *          double x = valDbl + 0.4;<br>
   * <br>
   *      } else if (SimTK::Value&lt;Vec3&gt;::isA(valAbstract)) {<br>
   *          const SimTK::Value&lt;Vec3&gt;&amp; valVec3 =<br>
   *              SimTK::Value&lt;Vec3&gt;::downcast(valAbstract);<br>
   *          Vec3 x = valVec3 + Vec3(0.4);<br>
   *      }<br>
   * ```<br>
   * For convenience, a templated method that implements basic downcasting<br>
   * internally is available. See getDiscreteVariableValue&lt;T&gt;().<br>
   * <br>
   * @param state State from which to get the value.<br>
   * @param path Specified path of the variable in the component heirarchy.<br>
   * @return Read-only reference to the discrete variable's AbstractValue.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called).<br>
   * @throws EmptyComponentPath if the specified path is an empty string<br>
   * (i.e., path == "").<br>
   * @throws VariableOwnerNotFoundOnSpecifiedPath if the candidate owner<br>
   * of the variable cannot be found at the specified path.<br>
   * @throws VariableNotFound if the specified variable cannot be found in<br>
   * the candidate owner.<br>
   * @see Component#resolveVariableNameAndOwner
   */
  public SWIGTYPE_p_SimTK__AbstractValue getDiscreteVariableAbstractValue(State state, String path) {
    return new SWIGTYPE_p_SimTK__AbstractValue(opensimSimulationJNI.BodyIterator_getDiscreteVariableAbstractValue(swigCPtr, this, State.getCPtr(state), state, path), false);
  }

  /**
   * Based on a specified path, set the value of a discrete variable.<br>
   * <br>
   * The specified path consists of the name of the discrete variable<br>
   * prepended by its absolute or relative path in the component hierarchy.<br>
   * <br>
   * If this component is the owner of the discrete variable, the specified<br>
   * path should simply be the name of the discrete variable.<br>
   * <br>
   * @param state State in which to set the discrete variable.<br>
   * @param path Path of the discrete variable in the component hierarchy.<br>
   * @param value Value to which to set the discrete variable.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called).<br>
   * @throws EmptyComponentPath if the specified path is an empty string<br>
   * (i.e., path == "").<br>
   * @throws VariableOwnerNotFoundOnSpecifiedPath if the candidate owner<br>
   * of the variable cannot be found at the specified path.<br>
   * @throws VariableNotFound if the specified variable cannot be found in<br>
   * the candidate owner.<br>
   * @see Component#resolveVariableNameAndOwner()
   */
  public void setDiscreteVariableValue(State state, String path, double value) {
    opensimSimulationJNI.BodyIterator_setDiscreteVariableValue(swigCPtr, this, State.getCPtr(state), state, path, value);
  }

  /**
   * Based on a specified path, retrieve a writable reference to the abstract<br>
   * value of the discrete variable. This method provides a more general<br>
   * interface that is not limited to values of type double.<br>
   * <br>
   * The specified path consists of the name of the discrete variable<br>
   * prepended by its absolute or relative path in the component hierarchy.<br>
   * <br>
   * If this component is the owner of the discrete variable, the specified<br>
   * path should simply be the name of the discrete variable.<br>
   * <br>
   * To obtain the type-specific value of a discrete variable, perform<br>
   * a cast using the template methods provided in class SimTK::Value&lt;T&gt;.<br>
   * When the type is unknown, it can be queried using the<br>
   * SimTK::Value&lt;T&gt;::isA() method. For example,<br>
   * <br>
   * ```<br>
   *      SimTK::AbstractValue&amp; valAbstract =<br>
   *          updDiscreteVariableAbstractValue(state, pathName);<br>
   * <br>
   *      if (SimTK::Value&lt;double&gt;::isA(valAbstract)) {<br>
   *          SimTK::Value&lt;double&gt;&amp; valDbl =<br>
   *              SimTK::Value&lt;double&gt;::updDowncast(valAbstract);<br>
   *          valDbl = 0.4;<br>
   * <br>
   *      } else if (SimTK::Value&lt;Vec3&gt;::isA(valAbstract)) {<br>
   *          SimTK::Value&lt;Vec3&gt;&amp; valVec3 =<br>
   *              SimTK::Value&lt;Vec3&gt;::updDowncast(valAbstract);<br>
   *          valVec3 = Vec3(0.4);<br>
   *      }<br>
   * ```<br>
   * For convenience, a templated method that implements basic downcasting<br>
   * internally is available. See setDiscreteVariableValue&lt;T&gt;().<br>
   * <br>
   * @param state State from which to get the value.<br>
   * @param path Path of the discrete variable in the component hierarchy.<br>
   * @return Writable reference to the discrete variable's AbstractValue.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called).<br>
   * @throws EmptyComponentPath if the specified path is an empty string<br>
   * (i.e., path == "").<br>
   * @throws VariableOwnerNotFoundOnSpecifiedPath if the candidate owner<br>
   * of the variable cannot be found at the specified path.<br>
   * @throws VariableNotFound if the specified variable cannot be found in<br>
   * this Component.
   */
  public SWIGTYPE_p_SimTK__AbstractValue updDiscreteVariableAbstractValue(State state, String path) {
    return new SWIGTYPE_p_SimTK__AbstractValue(opensimSimulationJNI.BodyIterator_updDiscreteVariableAbstractValue(swigCPtr, this, State.getCPtr(state), state, path), false);
  }

  /**
   * Get the index of a Component's cache variable in the Subsystem for allocations.<br>
   * <br>
   * <br>
   * @param name<br>
   *   Name of the cache variable, as provided to Component::addCacheVariable<br>
   * @return <br>
   *   A valid SimTK::CacheEntryIndex, which callers can use with simbody methods<br>
   *   (e.g. markCacheValueRealized)
   */
  public SWIGTYPE_p_SimTK__CacheEntryIndex getCacheVariableIndex(String name) {
    return new SWIGTYPE_p_SimTK__CacheEntryIndex(opensimSimulationJNI.BodyIterator_getCacheVariableIndex(swigCPtr, this, name), true);
  }

  /**
   * Returns true if the cache variable, identified by `name`, is valid.<br>
   * <br>
   * This method enables callers to monitor the validity of the cache variable,<br>
   * which enables the caller to decide whether to update the cache variable's<br>
   * value (or not). When computing an update is costly, use this method to check<br>
   * whether computing the value is necessary.<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @return bool<br>
   *     whether the cache variable's value is valid or not<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public boolean isCacheVariableValid(State state, String name) {
    return opensimSimulationJNI.BodyIterator_isCacheVariableValid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Marks the value of a cache variable, identified by `name`, as valid.<br>
   * <br>
   * Upon marking a cache variable's value as valid, the cache variable will remain<br>
   * valid until either:<br>
   * <br>
   * - the realization stage falls below the minimum realization stage set<br>
   *   when the cache variable was initialized with `Component::addCacheVariable`<br>
   * <br>
   * - the cache variable is explicitly invalidated by calling<br>
   *   `Component::markCacheVariableInvalid`<br>
   * <br>
   * This method causes `Component::isCacheVariableValid` to return true.<br>
   * `Component::isCacheVariableValid` is commonly used by value-getting<br>
   * methods to decide on whether to return the value as-is or recompute the<br>
   * value. Therefore, if a cache variable is not marked as valid then the<br>
   * cache variable's value may be recomputed more than necessary, which may<br>
   * be costly.<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public void markCacheVariableValid(State state, String name) {
    opensimSimulationJNI.BodyIterator_markCacheVariableValid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Marks the value of a cache variable, identified by `name`, as invalid.<br>
   * <br>
   * Upon marking a cache variable's value as invalid, it will remain invalid<br>
   * until `Component::markCacheVariableValid` is called (or a method which<br>
   * uses that, such as `Component::setCacheVariableValue`, is called).<br>
   * <br>
   * - Cache variables are automatically marked as invalid when the realization stage<br>
   *   falls below the minimum realization stage set when the cache variable was<br>
   *   initialized with `Component::addCacheVariable`.<br>
   * <br>
   * - Cache variables *may* be indirectly marked as invalid by other methods. For<br>
   *   example, a component-added state variable may invalidate a cache variable at<br>
   *   a lower stage. Concretely:<br>
   * <br>
   *   - A (hypothetical) component has a `length` state variable<br>
   *   - There are cache variables that are computed from `length` (e.g.<br>
   *   `strain`)<br>
   *   - So changing the `length` may invalidate the `strain` indirectly<br>
   *     (depending on how the state variable is handled)<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public void markCacheVariableInvalid(State state, String name) {
    opensimSimulationJNI.BodyIterator_markCacheVariableInvalid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   *  List all subcomponents by name and recurse into these components to<br>
   *     list their subcomponents, and so on.                                      
   */
  public void printSubcomponentInfo() {
    opensimSimulationJNI.BodyIterator_printSubcomponentInfo(swigCPtr, this);
  }

  /**
   *  List all the Sockets of this component and whether or not they are<br>
   *     connected. Also list the connectee paths for sockets that are connected. 
   */
  public void printSocketInfo() {
    opensimSimulationJNI.BodyIterator_printSocketInfo(swigCPtr, this);
  }

  /**
   *  List all the inputs of this component and whether or not they are<br>
   *     connected. Also list the (desired) connectee paths for the inputs.       
   */
  public void printInputInfo() {
    opensimSimulationJNI.BodyIterator_printInputInfo(swigCPtr, this);
  }

  /**
   *  Print outputs of this component and optionally, those of all<br>
   *     subcomponents.                                                            
   */
  public void printOutputInfo(boolean includeDescendants) {
    opensimSimulationJNI.BodyIterator_printOutputInfo__SWIG_0(swigCPtr, this, includeDescendants);
  }

  /**
   *  Print outputs of this component and optionally, those of all<br>
   *     subcomponents.                                                            
   */
  public void printOutputInfo() {
    opensimSimulationJNI.BodyIterator_printOutputInfo__SWIG_1(swigCPtr, this);
  }

  /**
   *  Access the owner of this Component.<br>
   * An exception is thrown if the %Component has no owner; in this case, the<br>
   * component is the root component, or is orphaned.<br>
   * @see hasOwner() 
   */
  public Component getOwner() {
    return new Component(opensimSimulationJNI.BodyIterator_getOwner(swigCPtr, this), false);
  }

  /**
   *  (For advanced users) Check if this %Component has an owner.<br>
   * A component may not have an owner if it:<br>
   * (1) is the root component, or<br>
   * (2) has not been added to another component 
   */
  public boolean hasOwner() {
    return opensimSimulationJNI.BodyIterator_hasOwner(swigCPtr, this);
  }

  /**
   *  Obtain the root %Component, which is this component if it is orphaned.
   */
  public Component getRoot() {
    return new Component(opensimSimulationJNI.BodyIterator_getRoot(swigCPtr, this), false);
  }

  /**
   *  Find a Component to which this Component is an ancestor---in other<br>
   *     words, a Component that is directly owned by this Component or is owned<br>
   *     by one of its sub-components, sub-sub-components, etc. The Component can<br>
   *     be found by type (by specifying a template argument) and either path or<br>
   *     name.<br>
   * <br>
   *     Here is an example of searching for a component of any type with the name<br>
   *     'elbow_flexion':<br>
   *     {@code 
      if (const Component* found =
              model.findComponent(ComponentPath("elbow_flexion"))) {
          std::cout << found.getName() << std::endl;
      }
      }<br>
   * <br>
   *     Here, we require that 'elbow_flexion' is of type Coordinate.<br>
   *     {@code 
      if (const Coordinate* found =
              model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
          std::cout << "Coordinate " << found.getName() << std::endl;
      }
      }<br>
   * <br>
   *     The search can be sped up considerably if the path or even partial path<br>
   *     name is known. For example, "forearm/elbow/elbow_flexion" will find<br>
   *     the Coordinate component of the elbow joint that connects the forearm body<br>
   *     in linear time (linear search for name at each component level). Whereas<br>
   *     supplying "elbow_flexion" requires a tree search. Returns nullptr (None in<br>
   *     Python, empty array in Matlab) if Component of that specified name cannot<br>
   *     be found.<br>
   * <br>
   *     NOTE: If the component name is ambiguous, an exception is thrown. To<br>
   *     disambiguate, more information must be provided, such as the template<br>
   *     argument to specify the type and/or a path rather than just the name. 
   */
  public Component findComponent(ComponentPath pathToFind) {
    long cPtr = opensimSimulationJNI.BodyIterator_findComponent__SWIG_2(swigCPtr, this, ComponentPath.getCPtr(pathToFind), pathToFind);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   *  Same as findComponent(const ComponentPath&amp;), but accepting a string (a<br>
   *     path or just a name) as input. 
   */
  public Component findComponent(String pathToFind) {
    long cPtr = opensimSimulationJNI.BodyIterator_findComponent__SWIG_3(swigCPtr, this, pathToFind);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   * Get an iterator through the underlying subcomponents that this component is<br>
   * composed of. The hierarchy of Components/subComponents forms a tree.<br>
   * The order of the Components is that of tree preorder traversal so that a<br>
   * component is traversed before its subcomponents.<br>
   * <br>
   * {@code 
  for (const auto& muscle : model.getComponentList<Muscle>()) {
      muscle.get_max_isometric_force();
  }
  }<br>
   * <br>
   * The returned ComponentList does not permit modifying any components; if<br>
   * you want to modify the components, see updComponentList().<br>
   * <br>
   * 
   */
  public ComponentsList getComponentsList() {
    return new ComponentsList(opensimSimulationJNI.BodyIterator_getComponentsList(swigCPtr, this), true);
  }

  /**
   *  End of conditional comment.<br>
   * Equality operator wrapper for use from languages not supporting operator<br>
   * overloading.
   */
  public boolean isEqualTo(OpenSimObject aObject) {
    return opensimSimulationJNI.BodyIterator_isEqualTo(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  /**
   *  Get the name of this Object. 
   */
  public String getName() {
    return opensimSimulationJNI.BodyIterator_getName(swigCPtr, this);
  }

  /**
   *  Get description, a one-liner summary. 
   */
  public String getDescription() {
    return opensimSimulationJNI.BodyIterator_getDescription(swigCPtr, this);
  }

  /**
   *  Get Authors of this Object 
   */
  public String getAuthors() {
    return opensimSimulationJNI.BodyIterator_getAuthors(swigCPtr, this);
  }

  /**
   *  Get references or publications to cite if using this object. 
   */
  public String getReferences() {
    return opensimSimulationJNI.BodyIterator_getReferences(swigCPtr, this);
  }

  /**
   * * Determine how many properties are stored with this %Object. These<br>
   *     are numbered 0..n-1 in the order they were created. *
   */
  public int getNumProperties() {
    return opensimSimulationJNI.BodyIterator_getNumProperties(swigCPtr, this);
  }

  /**
   *  Get a const reference to a property by its index number, returned as<br>
   *     an AbstractProperty. *
   */
  public AbstractProperty getPropertyByIndex(int propertyIndex) {
    return new AbstractProperty(opensimSimulationJNI.BodyIterator_getPropertyByIndex(swigCPtr, this, propertyIndex), false);
  }

  /**
   *  Return true if this %Object has a property of any type with the <br>
   *     given <i>name</i>, which must not be empty. *
   */
  public boolean hasProperty(String name) {
    return opensimSimulationJNI.BodyIterator_hasProperty(swigCPtr, this, name);
  }

  /**
   *  Get a const reference to a property by its name, returned as<br>
   *     an AbstractProperty. An exception is thrown if no property by this name<br>
   *     is present in this %Object. *
   */
  public AbstractProperty getPropertyByName(String name) {
    return new AbstractProperty(opensimSimulationJNI.BodyIterator_getPropertyByName(swigCPtr, this, name), false);
  }

  /**
   *  Returns <code>true</code> if no property's value has changed since the last time<br>
   *     setObjectIsUpToDateWithProperties() was called. *
   */
  public boolean isObjectUpToDateWithProperties() {
    return opensimSimulationJNI.BodyIterator_isObjectUpToDateWithProperties(swigCPtr, this);
  }

  /**
   *  Serialize this object into the XML node that represents it.   <br>
   *     @param parent <br>
   *         Parent XML node of this object. Sending in a parent node allows an XML <br>
   *         node to be generated for this object if it doesn't already have one. If <br>
   *         no parent node is supplied and this object doesn't already have an XML <br>
   *         node, this object will become the root node for a new XML document. If <br>
   *         this object already has an XML node associated with it, no new nodes <br>
   *         are ever generated and the parent node is not used.<br>
   *     @param prop (optional)<br>
   *         The pointer to the property that contains this object. If it is<br>
   *         present, check if the property is unnamed and if NOT, use the property<br>
   *         name as its name when updating the XML node. *
   */
  public void updateXMLNode(SWIGTYPE_p_SimTK__Xml__Element parent, AbstractProperty prop) {
    opensimSimulationJNI.BodyIterator_updateXMLNode__SWIG_0(swigCPtr, this, SWIGTYPE_p_SimTK__Xml__Element.getCPtr(parent), AbstractProperty.getCPtr(prop), prop);
  }

  /**
   *  Serialize this object into the XML node that represents it.   <br>
   *     @param parent <br>
   *         Parent XML node of this object. Sending in a parent node allows an XML <br>
   *         node to be generated for this object if it doesn't already have one. If <br>
   *         no parent node is supplied and this object doesn't already have an XML <br>
   *         node, this object will become the root node for a new XML document. If <br>
   *         this object already has an XML node associated with it, no new nodes <br>
   *         are ever generated and the parent node is not used.<br>
   *     
   */
  public void updateXMLNode(SWIGTYPE_p_SimTK__Xml__Element parent) {
    opensimSimulationJNI.BodyIterator_updateXMLNode__SWIG_1(swigCPtr, this, SWIGTYPE_p_SimTK__Xml__Element.getCPtr(parent));
  }

  /**
   *  Inlined means an in-memory Object that is not associated with<br>
   *     an XMLDocument. *
   */
  public boolean getInlined() {
    return opensimSimulationJNI.BodyIterator_getInlined(swigCPtr, this);
  }

  /**
   *  If there is a document associated with this object then return the<br>
   *     file name maintained by the document. Otherwise return an empty string. *
   */
  public String getDocumentFileName() {
    return opensimSimulationJNI.BodyIterator_getDocumentFileName(swigCPtr, this);
  }

  /**
   *  If there is a document associated with this object then return its<br>
   *         version number. For example this is 30000 for OpenSim 3.x documents <br>
   *         and is 305xx for OpenSim 4.0 beta and above. If there is no document<br>
   *         associated with the object, the method returns -1.
   */
  public int getDocumentFileVersion() {
    return opensimSimulationJNI.BodyIterator_getDocumentFileVersion(swigCPtr, this);
  }

  /**
   *  Write this %Object into an XML file of the given name; conventionally<br>
   *     the suffix to use is ".osim". This is useful for writing out a Model that<br>
   *     has been created programmatically, and also very useful for testing and<br>
   *     debugging. If object has invalid connections, then printing is aborted.<br>
   *     You can override this behavior by setting the debug level to at least 1 <br>
   *     (e.g., Object::setDebugLevel(1)) prior to printing. *
   */
  public boolean print(String fileName) {
    return opensimSimulationJNI.BodyIterator_print(swigCPtr, this, fileName);
  }

  /**
   *  dump the XML representation of this %Object into an std::string and return it.<br>
   *     Mainly intended for debugging and for use by the XML browser in the GUI. *
   */
  public String dump() {
    return opensimSimulationJNI.BodyIterator_dump(swigCPtr, this);
  }

  /**
   *  The default implementation returns true only if the supplied string<br>
   *     is "Object"; each %Object-derived class overrides this to match its own<br>
   *     class name. *
   */
  public boolean isA(String type) {
    return opensimSimulationJNI.BodyIterator_isA(swigCPtr, this, type);
  }

  /**
   *  Wrapper to be used on Java side to display objects in tree; this returns<br>
   *     just the object's name. *
   */
  public String toString() {
    return opensimSimulationJNI.BodyIterator_toString(swigCPtr, this);
  }

}
