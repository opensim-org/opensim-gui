/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * A utility class for fitting a set of `FunctionBasedPath`s to existing<br>
 * geometry-path in an OpenSim model using `MultivariatePolynomialFunction`s.<br>
 * <br>
 * The primary inputs to this class include a model containing path objects<br>
 * derived from `AbstractGeometryPath` (e.g., `GeometryPath`) and a reference<br>
 * trajectory containing coordinate values for all `Coordinate`s in the model.<br>
 * The path fitting process samples coordinate values around the reference<br>
 * trajectory, computes path lengths and moment arms from the geometry-based<br>
 * paths in the model, and fits polynomial coefficients for<br>
 * `MultivariatePolynomialFunction` objects based on the path length and moment<br>
 * arm samples. The fitted paths are written to an XML file, along with the<br>
 * modified coordinate values, sampled coordinate values, path lengths, and<br>
 * moment arms for both the original and fitted paths.<br>
 * <br>
 * Note: Each file name is prefixed with the name of the model, and the<br>
 *       directory to which the results are written can be specified using the<br>
 *      `setOutputDirectory` method.<br>
 * <br>
 * # Settings<br>
 * Various settings can be adjusted to control the path fitting process. The<br>
 * `setMomentArmsThreshold` method determines whether or not a path depends on a<br>
 * model coordinate. In other words, the absolute value the moment arm of a with<br>
 * respect to a particular coordinate must be greater than this value to be<br>
 * included during path fitting. The `setMinimumPolynomialOrder` and<br>
 * `setMaximumPolynomialOrder` methods specify the minimum and maximum order of<br>
 * the polynomial used to fit each path. The `setGlobalCoordinateSamplingBounds`<br>
 * property specifies the global bounds (in degrees) that determine the minimum<br>
 * and maximum coordinate values sampled at each time point. The method<br>
 * `appendCoordinateSamplingBounds` can be used to override the global bounds<br>
 * for a specific coordinate. The `setMomentArmTolerance` and<br>
 * `setPathLengthTolerance` methods specify the tolerance on the<br>
 * root-mean-square (RMS) error (in meters) between the moment arms and path<br>
 * lengths computed from the original model paths and the fitted polynomial<br>
 * paths. The `setNumSamplesPerFrame` method specifies the number of samples<br>
 * taken per time frame in the coordinate values table used to fit each path.<br>
 * The `setNumParallelThreads` method specifies the number of threads used to<br>
 * parallelize the path fitting process. The `setLatinHypercubeAlgorithm` method<br>
 * specifies the Latin hypercube sampling algorithm used to sample coordinate<br>
 * values for path fitting.<br>
 * <br>
 * The default settings are as follows:<br>
 * <br>
 *    - Moment arm threshold: 1e-3 meters<br>
 *    - Minimum polynomial order: 2<br>
 *    - Maximum polynomial order: 6<br>
 *    - Global coordinate sampling bounds: [-10, 10] degrees<br>
 *    - Moment arm tolerance: 1e-4 meters<br>
 *    - Path length tolerance: 1e-4 meters<br>
 *    - Number of samples per frame: 25<br>
 *    - Number of threads: number of available hardware threads<br>
 *    - Latin hypercube sampling algorithm: "random"<br>
 *    - Use stepwise regression: False<br>
 * <br>
 * Note: The default settings were chosen based on testing with a human<br>
 *       lower-extremity model. Different settings may be required for other<br>
 *       models with larger or smaller anatomical measures (e.g., dinosaur<br>
 *       models).<br>
 * <br>
 * # Usage<br>
 * The most basic usage of `PolynomialPathFitter` requires the user to provide<br>
 * a model and reference trajectory. The model should contain at least one path<br>
 * object derived from `AbstractGeometryPath` and should not contain any<br>
 * `FunctionBasedPath` objects. The reference trajectory must contain coordinate<br>
 * values for all `Coordinate`s in the model:<br>
 * <br>
 * {@code 
PolynomialPathFitter fitter;
fitter.setModel(ModelProcessor("model.osim"));
fitter.setCoordinateValues(TableProcessor("values.sto"));
}<br>
 * <br>
 * The additional settings can be adjusted using the various `set` methods<br>
 * described above. For example, the global coordinate sampling bounds, bounds<br>
 * for the coordinate at "/jointset/slider/position", and the number of samples<br>
 * per frame can be set as follows:<br>
 * <br>
 * {@code 
fitter.setGlobalCoordinateSamplingBounds(SimTK::Vec2(-20.0, 20.0));
fitter.appendCoordinateSamplingBounds(
        "/jointset/slider/position", SimTK::Vec2(-5.0, 15.0));
fitter.setNumSamplesPerFrame(50);
}<br>
 * <br>
 * The path fitting process can be run using the `run()` method:<br>
 * <br>
 * {@code 
fitter.run();
}<br>
 * <br>
 * # Recommendations<br>
 * Information from each step of the path fitting process is logged to the<br>
 * console, provided that you have set the OpenSim::Logger to level "info" or<br>
 * greater. Warnings are printed if the number of samples is likely insufficient<br>
 * for the fitting process, or if the fit for a particular path did not meet the<br>
 * specified tolerances.<br>
 * <br>
 * In general, it is up to the user to decide how many sample points are needed<br>
 * to adequately cover the range of motion of the model's coordinates. As the<br>
 * complexity of a muscle path increases, more sample points over a larger<br>
 * dimension of coordinate values are needed to achieve a good fit. Users may<br>
 * consider manually creating the coordinates value table to ensure that the<br>
 * sampling covers the full range of motion for the model.<br>
 * <br>
 * It is highly recommended to use the files printed to the output directory to<br>
 * evaluate the quality of the fitted paths (see `setOutputDirectory()` for more<br>
 * details). Depending on the quality of the original model, it may not be<br>
 * possible to achieve a good fit for all paths (e.g., due to kinks or other<br>
 * discontinuities in the path). Finally, the fitted paths should only be used<br>
 * in simulations for which the coordinate values represent the expected range<br>
 * of motion for the model. If you are unsure if a simulation you have created<br>
 * with the fitted paths is valid, you can use the `evaluateFunctionBasedPaths`<br>
 * static method to compare the fitted paths to the original model paths given a<br>
 * new kinematic trajectory.<br>
 * <br>
 * Note: The `evaluateFunctionBasedPaths` method can be used independently from<br>
 *       the rest of this class, and does not require the `FunctionBasedPath`s<br>
 *       in the model to use `MultivariatePolynomialFunction`s.
 */
public class PolynomialPathFitter extends OpenSimObject {
  private transient long swigCPtr;

  public PolynomialPathFitter(long cPtr, boolean cMemoryOwn) {
    super(opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(PolynomialPathFitter obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(PolynomialPathFitter obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimActuatorsAnalysesToolsJNI.delete_PolynomialPathFitter(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static PolynomialPathFitter safeDownCast(OpenSimObject obj) {
    long cPtr = opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new PolynomialPathFitter(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new PolynomialPathFitter(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getConcreteClassName(swigCPtr, this);
  }

  public PolynomialPathFitter() {
    this(opensimActuatorsAnalysesToolsJNI.new_PolynomialPathFitter__SWIG_0(), true);
  }

  public PolynomialPathFitter(PolynomialPathFitter arg0) {
    this(opensimActuatorsAnalysesToolsJNI.new_PolynomialPathFitter__SWIG_1(PolynomialPathFitter.getCPtr(arg0), arg0), true);
  }

  /**
   * The model containing geometry-based path objects to which<br>
   * polynomial-based path objects will be fitted.<br>
   * <br>
   * The model should be provided using a `ModelProcessor` object. We expect<br>
   * the model to contain at least one path object derived from<br>
   * `AbstractGeometryPath` and does not already contain any<br>
   * `FunctionBasedPath` objects. The bounds for clamped coordinates are<br>
   * obeyed during the fitting process. Locked coordinates are unlocked if<br>
   * data is provided for them, or replaced with WeldJoints if no data is<br>
   * provided for them.
   */
  public void setModel(ModelProcessor model) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setModel(swigCPtr, this, ModelProcessor.getCPtr(model), model);
  }

  /**
   * The reference trajectory used to sample coordinate values for path<br>
   * fitting.<br>
   * <br>
   * The reference trajectory should be provided using a `TableProcessor`<br>
   * object. The reference trajectory must contain coordinate values for all<br>
   * `Coordinate`s in the model. We assumed that the coordinate values meet<br>
   * all the kinematic constraints in the model, except for<br>
   * `CoordinateCouplerConstraint`s, since we automatically update the<br>
   * coordinate trajectory to satisfy these constraints. The `TimeSeriesTable`<br>
   * must contain the "inDegrees" metadata flag; the coordinate values are<br>
   * automatically converted to radians if this flag is set to "yes".
   */
  public void setCoordinateValues(TableProcessor coordinateValues) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setCoordinateValues(swigCPtr, this, TableProcessor.getCPtr(coordinateValues), coordinateValues);
  }

  /**
   * Run the path fitting process.<br>
   * <br>
   * The path fitting process consists of the following steps:<br>
   * <br>
   *     1. Load the model and reference coordinate values trajectory. The<br>
   *        coordinate values table is modified to update the column labels<br>
   *        based on the model coordinate paths, to update any coordinates<br>
   *        dependent on `CoordinateCouplerConstraint`s, and to convert the<br>
   *        coordinate values to radians if the "inDegrees" metadata flag is<br>
   *        set to "yes".<br>
   * <br>
   *     2. Set sampling bounds for coordinates based on the global and<br>
   *        coordinate-specific bounds properties.<br>
   * <br>
   *     3. Verify that the remaining user settings are valid.<br>
   * <br>
   *     4. Sample coordinate values around the reference trajectory using<br>
   *        Latin hypercube sampling. The sampling is defined based on the<br>
   *        coordinate bounds and range maps, the number of samples per frame,<br>
   *        and the Latin hypercube sampling algorithm.<br>
   * <br>
   *     5. Compute path lengths and moment arms from the geometry-based paths<br>
   *        in the input model.<br>
   * <br>
   *     6. Filter out bad coordinate samples and populate a map containing<br>
   *        the coordinates that path is dependent on.<br>
   * <br>
   *     7. Fit the polynomial coefficients by finding a least-squares fit<br>
   *        between the path lengths and moment arms computed from the<br>
   *        geometry-based paths and the path lengths and moment arms<br>
   *        computed from the fitted polynomial-based paths.<br>
   * <br>
   *     8. Print out a summary of the path fitting results, including<br>
   *        information about the fitted polynomial functions and<br>
   *        root-mean-square (RMS) errors between the original and fitted<br>
   *        paths.<br>
   * <br>
   *     9. Write the fitted paths, modified coordinate values, sampled<br>
   *        coordinate values, path lengths, and moment arms to files.<br>
   * <br>
   * Note: Steps 4, 5, and 7 are parallelized using the number of threads<br>
   *       specified via the `setParallel()` method.
   */
  public void run() {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_run(swigCPtr, this);
  }

  /**
   * The directory to which the path fitting results are written.<br>
   * <br>
   * If the path fitting is successful, the fitted paths are written as a<br>
   * `Set` of `FunctionBasedPath` objects (with path length functions defined<br>
   * using `MultivariatePolynomialFunction` objects) to an XML file. Files<br>
   * containing the modified coordinate values, sampled coordinate values,<br>
   * path lengths, and moment arms for both the original and fitted paths are<br>
   * also written to the output directory.<br>
   * <br>
   * Note: By default, results are written to the current working directory.
   */
  public void setOutputDirectory(String directory) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setOutputDirectory(swigCPtr, this, directory);
  }

  public String getOutputDirectory() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getOutputDirectory(swigCPtr, this);
  }

  /**
   * Whether or not to use stepwise regression to fit a minimal set of<br>
   * polynomial coefficients.<br>
   * <br>
   * Stepwise regression builds a vector of coefficients by individually<br>
   * adding polynomial terms that result in the smallest path length and<br>
   * moment arm error. When a new term is added, the fitting process is<br>
   * repeated to recompute the coefficients. Polynomial terms are added until<br>
   * the path length and moment arm tolerances are met, or the maximum number<br>
   * of terms is reached.<br>
   * <br>
   * Note: By default, this setting is false.<br>
   * Note: If enabled, stepwise regression will fit coefficients using the<br>
   *       maximum polynomial order based on `setMaximumPolynomialOrder()`.
   */
  public void setUseStepwiseRegression(boolean tf) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setUseStepwiseRegression(swigCPtr, this, tf);
  }

  public boolean getUseStepwiseRegression() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getUseStepwiseRegression(swigCPtr, this);
  }

  /**
   * The moment arm threshold value that determines whether or not a path<br>
   * depends on a model coordinate. In other words, the moment arm of a path<br>
   * with respect to a particular coordinate must be greater than this value<br>
   * to be included during path fitting.<br>
   * <br>
   * Note: The default moment arm threshold is set to 1e-3 meters.
   */
  public void setMomentArmThreshold(double threshold) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setMomentArmThreshold(swigCPtr, this, threshold);
  }

  /**
   *  
   */
  public double getMomentArmThreshold() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getMomentArmThreshold(swigCPtr, this);
  }

  /**
   * The minimum order of the polynomial used to fit each path. The order of<br>
   * a polynomial is the highest power of the independent variable(s) in the<br>
   * polynomial.<br>
   * <br>
   * Note: The default minimum polynomial order is set to 2.
   */
  public void setMinimumPolynomialOrder(int order) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setMinimumPolynomialOrder(swigCPtr, this, order);
  }

  /**
   *  
   */
  public int getMinimumPolynomialOrder() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getMinimumPolynomialOrder(swigCPtr, this);
  }

  /**
   * The maximum order of the polynomial used to fit each path. The order of<br>
   * a polynomial is the highest power of the independent variable(s) in the<br>
   * polynomial.<br>
   * <br>
   * Note: The default maximum polynomial order is set to 6.
   */
  public void setMaximumPolynomialOrder(int order) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setMaximumPolynomialOrder(swigCPtr, this, order);
  }

  /**
   *  
   */
  public int getMaximumPolynomialOrder() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getMaximumPolynomialOrder(swigCPtr, this);
  }

  /**
   * The global bounds that determine the minimum and maximum coordinate value<br>
   * samples at each time point.<br>
   * <br>
   * The bounds are specified as a `SimTK::Vec2`, where the first element is<br>
   * the minimum bound and the second element is the maximum bound. Rotational<br>
   * coordinates are in degrees; translational coordinates in meters. The<br>
   * maximum sample value at a particular time point is the nominal coordinate<br>
   * value plus the maximum bound, and the minimum sample value is the<br>
   * nominal coordinate value minus the minimum bound.<br>
   * <br>
   * Note: The default global bounds are set to [-10, 10] degrees/meters.<br>
   * If you have a model with paths that cross translational joints, you may<br>
   * to specify smaller bounds for the translational coordinates (see<br>
   * `appendCoordinateSamplingBounds()`).<br>
   * <br>
   * Note: To override the default global bounds for a specific coordinate,<br>
   *       use the `appendCoordinateSamplingBounds()` method.
   */
  public void setGlobalCoordinateSamplingBounds(Vec2 bounds) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setGlobalCoordinateSamplingBounds(swigCPtr, this, Vec2.getCPtr(bounds), bounds);
  }

  /**
   *  
   */
  public Vec2 getGlobalCoordinateSamplingBounds() {
    return new Vec2(opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getGlobalCoordinateSamplingBounds(swigCPtr, this), true);
  }

  /**
   * The bounds (in degrees) that determine the minimum and maximum coordinate<br>
   * value samples at each time point for the coordinate at `coordinatePath`.<br>
   * <br>
   * The bounds are specified as a `SimTK::Vec2`, where the first element is<br>
   * the minimum bound and the second element is the maximum bound. The<br>
   * maximum sample value at a particular time point is the nominal coordinate<br>
   * value plus the maximum bound, and the minimum sample value is the<br>
   * nominal coordinate value minus the minimum bound. This overrides the<br>
   * global bounds set by `setGlobalCoordinateSamplingBounds()` for this<br>
   * coordinate.
   */
  public void appendCoordinateSamplingBounds(String coordinatePath, Vec2 bounds) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_appendCoordinateSamplingBounds(swigCPtr, this, coordinatePath, Vec2.getCPtr(bounds), bounds);
  }

  /**
   * The tolerance on the root-mean-square (RMS) error (in meters) between the<br>
   * moment arms computed from an original model path and a fitted<br>
   * polynomial-based path, which is used to determine the order of the<br>
   * polynomial used in the fitted path.<br>
   * <br>
   * The moment arm RMS error must be less than the tolerance for the<br>
   * polynomial order to be accepted. If the RMS error is greater than the<br>
   * tolerance, the polynomial order is increased by one and the path is<br>
   * refitted. This process is repeated until the RMS error is less than the<br>
   * tolerance or the maximum polynomial order is reached.<br>
   * <br>
   * Note: The default moment arm tolerance is set to 1e-4 meters.<br>
   * Note: The path length RMS error must also be less than the path length<br>
   *       tolerance for the polynomial order to be accepted (see<br>
   *       `setPathLengthTolerance`).
   */
  public void setMomentArmTolerance(double tolerance) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setMomentArmTolerance(swigCPtr, this, tolerance);
  }

  /**
   *  
   */
  public double getMomentArmTolerance() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getMomentArmTolerance(swigCPtr, this);
  }

  /**
   * The tolerance on the root-mean-square (RMS) error (in meters) between the<br>
   * path lengths computed from an original model path and a fitted<br>
   * polynomial-based path, which is used to determine the order of the<br>
   * polynomial used in the fitted path.<br>
   * <br>
   * The path length RMS error must be less than the tolerance for the<br>
   * polynomial order to be accepted. If the RMS error is greater than the<br>
   * tolerance, the polynomial order is increased by one and the path is<br>
   * refitted. This process is repeated until the RMS error is less than the<br>
   * tolerance or the maximum polynomial order is reached.<br>
   * <br>
   * Note: The default path length tolerance is set to 1e-4 meters.<br>
   * Note: The moment arm RMS error must also be less than the moment arm<br>
   *       tolerance for the polynomial order to be accepted (see<br>
   *      `setMomentArmTolerance`).
   */
  public void setPathLengthTolerance(double tolerance) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setPathLengthTolerance(swigCPtr, this, tolerance);
  }

  /**
   *  
   */
  public double getPathLengthTolerance() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getPathLengthTolerance(swigCPtr, this);
  }

  /**
   * The number of samples taken per time frame in the coordinate values table<br>
   * used to fit each path.<br>
   * <br>
   * Note: The default number of samples per frame is set to 25.
   */
  public void setNumSamplesPerFrame(int numSamples) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setNumSamplesPerFrame(swigCPtr, this, numSamples);
  }

  /**
   *  
   */
  public int getNumSamplesPerFrame() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getNumSamplesPerFrame(swigCPtr, this);
  }

  /**
   * The number of threads used to parallelize the path fitting process.<br>
   * <br>
   * This setting is used to divide the coordinate sampling, path length and<br>
   * moment arm computations, and path fitting across multiple threads. The<br>
   * number of threads must be greater than zero.<br>
   * <br>
   * Note: The default is the number of available hardware threads.
   */
  public void setNumParallelThreads(int numThreads) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setNumParallelThreads(swigCPtr, this, numThreads);
  }

  /**
   *   numThreads)
   */
  public int getNumParallelThreads() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getNumParallelThreads(swigCPtr, this);
  }

  /**
   * The Latin hypercube sampling algorithm used to sample coordinate values<br>
   * for path fitting.<br>
   * <br>
   * The Latin hypercube sampling algorithm is used to sample coordinate<br>
   * values for path fitting. The algorithm can be set to either "random" or<br>
   * "ESEA", which stands for the enhanced stochastic evolutionary algorithm<br>
   * developed by Jin et al. 2005 (see class `LatinHypercubeDesign` for more<br>
   * details). The "random" algorithm is used by default, and "ESEA" can be<br>
   * used to improve the quality of the sampling at the expense of higher<br>
   * computational cost. For most applications, the "random" algorithm is<br>
   * likely sufficient.
   */
  public void setLatinHypercubeAlgorithm(String algorithm) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setLatinHypercubeAlgorithm(swigCPtr, this, algorithm);
  }

  /**
   *  
   */
  public String getLatinHypercubeAlgorithm() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getLatinHypercubeAlgorithm(swigCPtr, this);
  }

  /**
   * Whether or not to include moment arm functions in the fitted path<br>
   * (default: false).<br>
   * <br>
   * The moment arm functions are constructed by taking the derivative of the<br>
   * path length function with respect to the coordinate values using<br>
   * symbolic differentiation. The function coefficients are negated to match<br>
   * the moment arm convention in OpenSim.
   */
  public void setIncludeMomentArmFunctions(boolean tf) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setIncludeMomentArmFunctions(swigCPtr, this, tf);
  }

  /**
   *   tf)
   */
  public boolean getIncludeMomentArmFunctions() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getIncludeMomentArmFunctions(swigCPtr, this);
  }

  /**
   * Whether or not to include the lengthening speed function in the fitted<br>
   * path (default: false).<br>
   * <br>
   * The lengthening speed function is computed by taking dot product of the<br>
   * moment arm functions by the vector of time derivatives of the coordinate<br>
   * values using symbolic math. The result is negated to offset the negation<br>
   * applied to the moment arm function expressions.<br>
   * <br>
   * Note: Since FunctionBasedPath uses cached moment arm values to compute<br>
   *       lengthening speed, including this function in the path definition<br>
   *       may make lengthening speed evaluation slower compared to<br>
   *       only including the moment arm functions (the moment arm expressions<br>
   *       are effectively evaluated twice). Therefore, this setting is<br>
   *       disabled by default.
   */
  public void setIncludeLengtheningSpeedFunction(boolean tf) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_setIncludeLengtheningSpeedFunction(swigCPtr, this, tf);
  }

  /**
   *   tf)
   */
  public boolean getIncludeLengtheningSpeedFunction() {
    return opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_getIncludeLengtheningSpeedFunction(swigCPtr, this);
  }

  /**
   * Print out a summary of the path fitting results, including information<br>
   * about the fitted polynomial functions and root-mean-square (RMS) errors<br>
   * between the original and fitted paths.<br>
   * <br>
   * The `trajectory` argument is a `TableProcessor` object containing the<br>
   * simulation trajectory, specifically the set of coordinate values, used to<br>
   * compute path lengths and moment arms. The `polynomialPathsFile` argument<br>
   * is the path to an XML file containing the set of `FunctionBasedPath`s<br>
   * fitted to the geometry-based paths in `model`. These paths can be defined<br>
   * by `MultivariatePolynomialFunction`s generated by this class or any other<br>
   * `Function` objects that approximate the original model paths.
   */
  public static void evaluateFunctionBasedPaths(Model model, TableProcessor trajectory, String functionBasedPathsFile, double pathLengthTolerance, double momentArmTolerance) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_evaluateFunctionBasedPaths__SWIG_0(Model.getCPtr(model), model, TableProcessor.getCPtr(trajectory), trajectory, functionBasedPathsFile, pathLengthTolerance, momentArmTolerance);
  }

  /**
   * Print out a summary of the path fitting results, including information<br>
   * about the fitted polynomial functions and root-mean-square (RMS) errors<br>
   * between the original and fitted paths.<br>
   * <br>
   * The `trajectory` argument is a `TableProcessor` object containing the<br>
   * simulation trajectory, specifically the set of coordinate values, used to<br>
   * compute path lengths and moment arms. The `polynomialPathsFile` argument<br>
   * is the path to an XML file containing the set of `FunctionBasedPath`s<br>
   * fitted to the geometry-based paths in `model`. These paths can be defined<br>
   * by `MultivariatePolynomialFunction`s generated by this class or any other<br>
   * `Function` objects that approximate the original model paths.
   */
  public static void evaluateFunctionBasedPaths(Model model, TableProcessor trajectory, String functionBasedPathsFile, double pathLengthTolerance) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_evaluateFunctionBasedPaths__SWIG_1(Model.getCPtr(model), model, TableProcessor.getCPtr(trajectory), trajectory, functionBasedPathsFile, pathLengthTolerance);
  }

  /**
   * Print out a summary of the path fitting results, including information<br>
   * about the fitted polynomial functions and root-mean-square (RMS) errors<br>
   * between the original and fitted paths.<br>
   * <br>
   * The `trajectory` argument is a `TableProcessor` object containing the<br>
   * simulation trajectory, specifically the set of coordinate values, used to<br>
   * compute path lengths and moment arms. The `polynomialPathsFile` argument<br>
   * is the path to an XML file containing the set of `FunctionBasedPath`s<br>
   * fitted to the geometry-based paths in `model`. These paths can be defined<br>
   * by `MultivariatePolynomialFunction`s generated by this class or any other<br>
   * `Function` objects that approximate the original model paths.
   */
  public static void evaluateFunctionBasedPaths(Model model, TableProcessor trajectory, String functionBasedPathsFile) {
    opensimActuatorsAnalysesToolsJNI.PolynomialPathFitter_evaluateFunctionBasedPaths__SWIG_2(Model.getCPtr(model), model, TableProcessor.getCPtr(trajectory), trajectory, functionBasedPathsFile);
  }

}
