/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * <br>
 * Minimize the error between compliant contact force elements in the model and<br>
 * experimentally measured contact forces.<br>
 * <br>
 * This class handles multiple groups of contact forces and a single<br>
 * experimental external loads file. Tracking ground reaction forces for the<br>
 * left and right feet in gait requires only one instance of this goal.<br>
 * <br>
 * Note: The only contact element supported is SmoothSphereHalfSpaceForce.<br>
 * <br>
 * Note: This goal does not include torques or centers of pressure.<br>
 * <br>
 * This goal is computed as follows:<br>
 * <br>
 *  
\frac{1}{mg} \int_{t_i}^{t_f}
        \sum_{j \in G}
            \|\mathrm{proj}_{\hat{n}}(\vec{F}_{m,j} - \vec{F}_{e,j})\|^2 ~dt
<br>
 * We use the following notation:<br>
 * -   t_i : the initial time of this phase.<br>
 * -   t_f : the final time of this phase.<br>
 * -   mg : the total weight of the system; replaced with<br>
 *       m  if   g = 0 .<br>
 * -   G : the set of contact groups.<br>
 * -   \hat{n} : a vector used for projecting the force error.<br>
 * -   \mathrm{proj}_{\hat{n}}() : this function projects the force error<br>
 *     either onto   \hat{n}  or onto the plane perpendicular to<br>
 *       \hat{n} .<br>
 * -   \vec{F}_{m,j}  the sum of the contact forces in group   j ,<br>
 *     expressed in ground.<br>
 * -   \vec{F}_{e,j}  the experimental contact force for group   j ,<br>
 *     expressed in ground.<br>
 * <br>
 * # Tracking a subset of force components<br>
 * <br>
 * The projection is useful for selecting which components of the force to<br>
 * track. The force can be projected to be onto a vector or<br>
 * onto a plane. For example, with gait, projecting onto the vector (0, 1, 0)<br>
 * allows tracking only the vertical component of a ground reaction force;<br>
 * projecting onto the plane perpendicular to the vector (0, 0, 1) allows<br>
 * ignoring the transverse force. See the projection and projection_vector<br>
 * properties.<br>
 * <br>
 * ## Usage<br>
 * <br>
 * To use this goal, specify the following:<br>
 * - a single ExternalLoads file or object, which is a set of ExternalForces.<br>
 * - a set of contact groups, each of which contains the name of an<br>
 *     ExternalForce (within the ExternalLoads).<br>
 * <br>
 * ### Configuring the ExternalLoads<br>
 * <br>
 * The ExternalLoads class is the standard way to provide experimental contact<br>
 * forces in OpenSim. This class is a set of ExternalForce objects. For gait,<br>
 * typically the ExternalLoads contains 2 ExternalForces, one for each foot.<br>
 * This goal uses the following information from ExternalLoads:<br>
 * - **data_file**: This scalar file contains all experimental force data with<br>
 *   columns named according to each ExternalForce's force_identifier.<br>
 * <br>
 * This goal uses the following information from each ExternalForce:<br>
 * - **name**: We use the name of the ExternalForce to associate it with a<br>
 *   contact force group.<br>
 * - **applied_on_body**: All contact forces in the group with which this<br>
 *   ExternalForce is associated must use this body as either the<br>
 *   sphere_frame's base frame or the half_space_frame's base frame.<br>
 * - **force_expressed_in_body**: We use this to re-express the experimental<br>
 *   force in ground. This is either the absolute path to a PhysicalFrame in<br>
 *   the model, or the name of a Body in the model's BodySet.<br>
 * - **force_identifier**: The ExternalLoads data_file must include the 3<br>
 *   columns<br>
 *   `&lt;force_identifier&gt;x`, `&lt;force_identifier&gt;y`, `&lt;force_identifier&gt;z`.<br>
 * <br>
 * All other properties of ExternalLoads and ExternalForce are ignored by this<br>
 * goal. This means that experimental forces are processed differently by this<br>
 * goal than by other OpenSim tools such as Inverse Dynamics, Computed Muscle<br>
 * Control, and Forward.<br>
 * <br>
 * Note: The ExternalLoads used by this goal is separate from the model. Using<br>
 * this goal implies that the model contains compliant contact forces, so<br>
 * adding ExternalLoads to the model would be redundant. This class uses the<br>
 * ExternalLoads *only* for computing the force error, not for applying forces<br>
 * to the model.<br>
 * <br>
 * ### Scale factors<br>
 * <br>
 * Add a MocoParameter to the problem that will scale the tracking reference<br>
 * data associated with a contact force group. Scale factors are applied<br>
 * to the tracking error calculations based on the following equation:<br>
 * <br>
 *      error = modelValue - scaleFactor * referenceValue<br>
 * <br>
 * In other words, the scale factor is applied when computing the tracking<br>
 * error for each contact force group, not to the reference data directly.<br>
 * You must specify both the external force name associated with the contact<br>
 * force group and the index corresponding to the direction (i.e., X = 0,<br>
 * Y = 1, Z = 2) of the scaled force value. The direction is applied in<br>
 * whatever frame the reference data is expressed in based on the provided<br>
 * ExternalLoads in each contact group.<br>
 * <br>
 * Adding a scale factor to a MocoContactTrackingGoal.<br>
 * {@code 
auto* contactTrackingGoal = problem.addGoal<MocoContactTrackingGoal>();
...
contactTrackingGoal->addScaleFactor(
        'RightGRF_vertical_scale_factor', 'Right_GRF', 1, {0.5, 2.0});
}<br>
 * <br>
 * 
 */
public class MocoContactTrackingGoal extends MocoGoal {
  private transient long swigCPtr;

  public MocoContactTrackingGoal(long cPtr, boolean cMemoryOwn) {
    super(opensimMocoJNI.MocoContactTrackingGoal_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(MocoContactTrackingGoal obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimMocoJNI.delete_MocoContactTrackingGoal(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

    public void addScaleFactor(String name, String externalForceName, int index,
        double[] b) throws Exception {
        addScaleFactor(name, externalForceName, index,
                       MocoPhase.convertArrayToMB(b));
    }

  public static MocoContactTrackingGoal safeDownCast(OpenSimObject obj) {
    long cPtr = opensimMocoJNI.MocoContactTrackingGoal_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new MocoContactTrackingGoal(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimMocoJNI.MocoContactTrackingGoal_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimMocoJNI.MocoContactTrackingGoal_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimMocoJNI.MocoContactTrackingGoal_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new MocoContactTrackingGoal(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimMocoJNI.MocoContactTrackingGoal_getConcreteClassName(swigCPtr, this);
  }

  public MocoContactTrackingGoal() {
    this(opensimMocoJNI.new_MocoContactTrackingGoal__SWIG_0(), true);
  }

  public MocoContactTrackingGoal(String name) {
    this(opensimMocoJNI.new_MocoContactTrackingGoal__SWIG_1(name), true);
  }

  public MocoContactTrackingGoal(String name, double weight) {
    this(opensimMocoJNI.new_MocoContactTrackingGoal__SWIG_2(name, weight), true);
  }

  /**
   *  Set the ExternalLoads as an XML file. This clears the ExternalLoads<br>
   *  provided as an object, if one exists.
   */
  public void setExternalLoadsFile(String extLoadsFile) {
    opensimMocoJNI.MocoContactTrackingGoal_setExternalLoadsFile(swigCPtr, this, extLoadsFile);
  }

  /**
   *  Set the ExternalLoads as an object. This clears the ExternalLoads<br>
   *  XML file, if provided.
   */
  public void setExternalLoads(ExternalLoads extLoads) {
    opensimMocoJNI.MocoContactTrackingGoal_setExternalLoads(swigCPtr, this, ExternalLoads.getCPtr(extLoads), extLoads);
  }

  /**
   *  Add a group of contact forces whose sum should track the force data from<br>
   *  a single ExternalForce. The externalForceName should be the name of an<br>
   *  ExternalForce object in the ExternalLoads.
   */
  public void addContactGroup(StdVectorString contactForcePaths, String externalForceName) {
    opensimMocoJNI.MocoContactTrackingGoal_addContactGroup__SWIG_0(swigCPtr, this, StdVectorString.getCPtr(contactForcePaths), contactForcePaths, externalForceName);
  }

  /**
   *  Add a group of contact forces whose sum should track the force data from<br>
   *  a single ExternalForce.<br>
   *  If the contact force elements associated with a single ExternalForce are<br>
   *  distributed across multiple bodies use this function instead of the<br>
   *  easier-to-use addContactGroup(), and set the group's<br>
   *  alternative_frame_paths property accordingly. See<br>
   *  MocoContactTrackingGoalGroup for more information.
   */
  public void addContactGroup(MocoContactTrackingGoalGroup group) {
    opensimMocoJNI.MocoContactTrackingGoal_addContactGroup__SWIG_1(swigCPtr, this, MocoContactTrackingGoalGroup.getCPtr(group), group);
  }

  /**
   *  Set if the force error should be projected onto either a vector or<br>
   *  plane. Possible values: "none" (default), "vector", and "plane".
   */
  public void setProjection(String projection) {
    opensimMocoJNI.MocoContactTrackingGoal_setProjection(swigCPtr, this, projection);
  }

  public String getProjection() {
    return opensimMocoJNI.MocoContactTrackingGoal_getProjection(swigCPtr, this);
  }

  /**
   *  Set the vector to use for projecting the force error.<br>
   *  If the projection type is "vector", the force error is projected onto<br>
   *  the vector provided here. If the projection type is "plane", the force<br>
   *  error is projected onto the plane perpendicular to this vector.
   */
  public void setProjectionVector(Vec3 normal) {
    opensimMocoJNI.MocoContactTrackingGoal_setProjectionVector(swigCPtr, this, Vec3.getCPtr(normal), normal);
  }

  /**
   *  Unset the projection vector.
   */
  public void clearProjectionVector() {
    opensimMocoJNI.MocoContactTrackingGoal_clearProjectionVector(swigCPtr, this);
  }

  public Vec3 getProjectionVector() {
    return new Vec3(opensimMocoJNI.MocoContactTrackingGoal_getProjectionVector(swigCPtr, this), true);
  }

  /**
   *  Add a MocoParameter to the problem that will scale the tracking reference<br>
   *  data associated with a contact force group. Scale factors are applied<br>
   *  to the tracking error calculations based on the following equation:<br>
   * <br>
   *      error = modelValue - scaleFactor * referenceValue<br>
   * <br>
   *  In other words, the scale factor is applied when computing the tracking<br>
   *  error for each contact force group, not to the reference data directly.<br>
   *  You must specify both the external force name associated with the contact<br>
   *  force group and the index corresponding to the direction (i.e., X = 0,<br>
   *  Y = 1, Z = 2) of the scaled force value. The direction is applied in<br>
   *  whatever frame the reference data is expressed in based on the provided<br>
   *  ExternalLoads in each contact group.
   */
  public void addScaleFactor(String name, String externalForceName, int index, MocoBounds bounds) {
    opensimMocoJNI.MocoContactTrackingGoal_addScaleFactor(swigCPtr, this, name, externalForceName, index, MocoBounds.getCPtr(bounds), bounds);
  }

  /**
   *  Normalize each component of the 3-D tracking error by the peak value of <br>
   *  each contact force component in the tracking data. No normalization is <br>
   *  applied when tracking data is close to zero (default: false).
   */
  public void setNormalizeTrackingError(boolean tf) {
    opensimMocoJNI.MocoContactTrackingGoal_setNormalizeTrackingError(swigCPtr, this, tf);
  }

  public boolean getNormalizeTrackingError() {
    return opensimMocoJNI.MocoContactTrackingGoal_getNormalizeTrackingError(swigCPtr, this);
  }

}
