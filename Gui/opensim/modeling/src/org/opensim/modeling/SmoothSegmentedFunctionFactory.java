/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * This is a class that acts as a user friendly wrapper to QuinticBezerCurveSet<br>
 * to build specific kinds of physiologically plausible muscle curves using C2 <br>
 * continuous sets of quintic Bezier curves. This class has been written there did <br>
 * not exist a set of curves describing muscle characteristics that was:<br>
 * <br>
 * {@literal 
1. Physiologically Accurate
2. Continuous to the second derivative
3. Parameterized in a physically meaningful manner
}<br>
 * <br>
 * For example, the curves employed by Thelen (Thelen DG(2003). Adjustment of Muscle <br>
 * Mechanics Model Parameters to Simulate Dynamic Contractions in Older Adults.<br>
 * ASME Journal of Biomechanical Engineering (125).) are parameterized in a <br>
 * physically meaningful manner, making them easy to use. However there are <br>
 * many shortcomings of these curves:<br>
 * <br>
 * a. The tendon and parallel element are not C2-continuous, making them slow to <br>
 * simulate and likely not physiologically accurate. <br>
 * b. The active force length curve approaches does not achieve its minimum value<br>
 * at a normalized fiber length of 0.5, and 1.5. <br>
 * c. The force velocity curve is not C2-continuous at the origin. As it is <br>
 * written in the paper the curve is impossible to use with an equilibrium model<br>
 * because it is not invertible. In addition the force-velocity curve actually <br>
 * increases in stiffness as activation drops - a very undesirable property given<br>
 * that many muscles are inactive at any one time.<br>
 * <br>
 * The muscle curves used in the literature until 2012 have been hugely influenced<br>
 * by Thelen's work, and thus similar comments can easily be applied to just about<br>
 * every other musculoskeletal simulation.<br>
 * <br>
 * Another example is from Miller (Miller,RH(2011).Optimal Control of <br>
 * Human Running. PhD Thesis). On pg 149 a physiologically plausible force velocity<br>
 * curve is specified that gives the user the ability to change the concentric <br>
 * curvature to be consistent with a slow- or a fast-twitch muscle. This curve is <br>
 * not C2-continuous at the origin, but even worse, it contains singularities in <br>
 * its parameter space. Since these parameters do not have a physical interpretation <br>
 * this model is difficult to use without accidentally creating a curve with a <br>
 * singularity.<br>
 * <br>
 * With this motivation I set out to develop a class that could generate muscle<br>
 * characteristic curves with the following properties:<br>
 * <br>
 * {@literal 
1. Physiologically Accurate
2. Continuous to the second derivative
3. Parameterized in a physically meaningful manner
4. Monotonicity for monotonic curves
5. Computationally efficient
}<br>
 * <br>
 * These goals were surprisingly difficult to achieve, but these goals have been <br>
 * achieved using sets of C2-continuous quintic Bezier curves. The resulting <br>
 * muscle curve functions in this class take parameters that would be intuitive to <br>
 * biomechanists who simulate human musculoskeletal systems, and returns a <br>
 * SmoothSegmentedFunction which is capable of evaluating the value, derivatives <br>
 * and optionally the integral of the desired function (or actually relation as <br>
 * the case may be). <br>
 * <br>
 * Each curve is made up of one or more C2 quintic Bezier curves x(u), <br>
 * and y(u), with linearly extrapolated ends as shown in the figure below. These <br>
 * quintic curves span 2 points, and achieve the desired derivative at its end <br>
 * points. The degree of curviness can be varied from 0 to 1 (0, 0.75 and 1.0 are <br>
 * shown in the figure in gray, blue and black respectively), and will make the <br>
 * curve approximate a line when set to 0 (gray), and approximate a curve that <br>
 * hugs the intersection of the lines that are defined by the end points locations <br>
 * and the slopes at the end of each curve segment (red lines). Although you do <br>
 * not need to set all of this information directly, for some of the curves it is <br>
 * useful to know that both the slope and the curviness parameter may need to be <br>
 * altered to achieve the desired shape.<br>
 * <br>
 * <br>
 * <img src="fig_SmoothSegmentedFunctionFactory_quinticCornerSections.png"/><br>
 * <br>
 * <br>
 * <br>
 * <b>Computational Cost Details</b><br>
 * All computational costs assume the following operation costs:<br>
 * <br>
 * {@literal 
Operation Type     : #flops
,+,-,=,Boolean Op : 1 
: 10
               sqrt: 20
               trig: 40
}<br>
 * <br>
 * These relative weightings will vary processor to processor, and so any of <br>
 * the quoted computational costs are approximate.<br>
 * <br>
 * @author Matt Millard<br>
 * @version 0.0
 */
public class SmoothSegmentedFunctionFactory {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public SmoothSegmentedFunctionFactory(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(SmoothSegmentedFunctionFactory obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(SmoothSegmentedFunctionFactory obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimCommonJNI.delete_SmoothSegmentedFunctionFactory(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *         This is a function that will produce a C2 (continuous to the second<br>
   *         derivative) active force length curve.<br>
   * <br>
   * <br>
   *         @param lce0   Normalized fiber length at the left-most shoulder of the <br>
   *                       active force-length curve. The value of the active force<br>
   *                       length curve for lce &lt; lce0 will be equal to the value<br>
   *                       set in shoulderVal. Normally lce0 is approximately 0.5<br>
   * <br>
   *         @param lce1   Normalized fiber length at the transition point between <br>
   *                       the ascending limb and the plateau region of the active <br>
   *                       force length curve.<br>
   * <br>
   *         @param lce2   Normalized fiber length at the maximum active force length<br>
   *                       curve value of 1. Normally lce2 is by definition 1.<br>
   * <br>
   *         @param lce3   Normalized fiber length of the at the right most shoulder<br>
   *                       of the active-force length curve. The value of the active<br>
   *                       force length curve for lce &gt; lce2 will be equal to the <br>
   *                       value of shoulderVal. Normally lce3 is approximately 1.5<br>
   * <br>
   *         @param minActiveForceLengthValue<br>
   *                               The minimum value of the active force length <br>
   *                               curve. A physiological non-equilibrium muscle model<br>
   *                               would have this value set to 0. An equilibrium <br>
   *                               muscle model would have a non-zero lower bound on <br>
   *                               this value of 0.1 typically. shoulderVal must be <br>
   *                               greater than, or equal to 0.<br>
   * <br>
   *         @param plateauSlope   The slope of the plateau of the active force<br>
   *                               length curve between lce1 and lce2. This parameter<br>
   *                               can vary depending on the muscle model, but a <br>
   *                               value of 0.8616 is a good place to start.<br>
   * <br>
   *         @param curviness  The dimensionless 'curviness' parameter that <br>
   *                           can vary between 0 (a line) to 1 (a smooth, but <br>
   *                           sharply bent elbow). A value of 0 will yield an active <br>
   *                           force length curve that is composed of slightly curved <br>
   *                           line segments. A value of 1 will yield an active force<br>
   *                           length curve that is smoothly rounded.<br>
   * <br>
   *         @param computeIntegral If this is true, the integral for this curve<br>
   *                                is numerically calculated and splined. If false, <br>
   *                                this integral is not computed, and a call to <br>
   *                                .calcIntegral will throw an exception<br>
   * <br>
   *         @param curveName The name of the muscle this curve applies to. This <br>
   *                           curve name should have the name of the muscle and the<br>
   *                           curve in it (e.g. "bicep_fiberActiveForceLengthCurve") <br>
   *                           so that, if this curve ever causes an exception, a <br>
   *                           user-friendly error message can be displayed to the<br>
   *                           end user to help them debug their model.<br>
   * <br>
   *         @throws SimTK::Exception if these conditions aren't met<br>
   *             -0 &lt; lce0 &lt; lce1 &lt; lce2 &lt; lce3 <br>
   *             -shoulderVal &gt;= 0<br>
   *             -0 &lt;= plateauSlope &lt; (1/(lce3-lce2))<br>
   *             -0 &lt;= curviness &lt;= 1<br>
   * <br>
   *         @return SmoothSegmentedFunction* <br>
   * <br>
   *         <img src="fig_SmoothSegmentedFunctionFactory_falCurve.png"/><br>
   * <br>
   * <br>
   *         <b>Conditions:</b><br>
   * <br>
   *         <b>Computational Costs</b><br>
   *         {@literal  
              Without Integral :   ~20,500 flops
              With Integral    :  ~870,500 flops
          }<br>
   * <br>
   *         <b>Example:</b><br>
   *         {@code 
              double lce0 = 0.5;
              double lce1 = 0.75;
              double lce2 = 1;
              double lce3 = 1.5;
              double shoulderVal  = 0.1;
              double plateauSlope = 0.75;
              double curviness    = 0.9;
  
              SmoothSegmentedFunction* fiberfalCurve = SmoothSegmentedFunctionFactory::
                  createFiberActiveForceLengthCurve(lce0, lce1, lce2, lce3, 
                                shoulderVal, plateauSlope, curviness,false,"test");
              fiberfalCurve.printMuscleCurveToFile();
          }
   */
  public static SWIGTYPE_p_SmoothSegmentedFunction createFiberActiveForceLengthCurve(double lce0, double lce1, double lce2, double lce3, double minActiveForceLengthValue, double plateauSlope, double curviness, boolean computeIntegral, String curveName) {
    long cPtr = opensimCommonJNI.SmoothSegmentedFunctionFactory_createFiberActiveForceLengthCurve(lce0, lce1, lce2, lce3, minActiveForceLengthValue, plateauSlope, curviness, computeIntegral, curveName);
    return (cPtr == 0) ? null : new SWIGTYPE_p_SmoothSegmentedFunction(cPtr, false);
  }

  /**
   *         This function will generate a C2-continuous (continuous to the second <br>
   *         derivative) force velocity curve of a single muscle fiber. The main <br>
   *         function of this element is to model the amount the force enhancement or <br>
   *         attenuation that is associated with contracting at a particular velocity.<br>
   * <br>
   *         @param fmaxE  The normalized maximum force the fiber can generate when <br>
   *                       is being stretched. This value is reported to range <br>
   *                       between 1.1 and 1.8 in the literature, though all values<br>
   *                       are above 1.<br>
   * <br>
   *         @param dydxC  The slope of the fv(dlce(t)/dt) curve at the maximum <br>
   *                       normalized concentric contraction velocity. Although <br>
   *                       physiologically the value of dydxC at the maximum <br>
   *                       concentric contraction velocity is by definition 0, a value<br>
   *                       of 0 is often used. If you are using an equilibrium-type <br>
   *                       model, this term must be positive and greater than zero so<br>
   *                       that the fv curve can be inverted.<br>
   *                       <br /><br /><br>
   *                       Minimum Value: 0<br>
   *                       Maximum Value: dydxC &lt; 1 <br>
   *                       <br /><br /><br>
   * <br>
   *         @param dydxNearC The slope of the force velocity curve as it approaches<br>
   *                          the maximum concentric (shortening) contraction velocity.<br>
   *                          <br /><br /><br>
   *                           Minimum Value: &gt; dydxC<br>
   *                           Maximum Value: dydxNearC &lt; 1 <br>
   *                           <br /><br /><br>
   * <br>
   * <br>
   *         @param dydxIso  The slope of the fv curve when dlce(t)/dt = 0. <br>
   *                         <br /><br /><br>
   *                         Minimum Value: dydxIso &gt; 1.0<br>
   *                         Maximum Value: dydxIso &lt; Inf<br>
   * <br>
   *         @param dydxE    The analogous term of dydxC parameter but for the <br>
   *                         eccentric portion of the force-velocity curve. As with<br>
   *                         the dydxC term, the physiologically accurate value for<br>
   *                         this parameter is 0, though a value of 0 is rarely used<br>
   *                         in muscle models.  If you are using an equilibrium-type <br>
   *                         model, this term must be positive and greater than zero <br>
   *                         so that the fv curve can be inverted. <br>
   *                         <br /><br /><br>
   *                         Minimum Value: 0<br>
   *                         Maximum Value: dydxC &lt; (fmaxE-1).<br>
   *                         <br /><br /><br>
   *                         As with the dydxC term, <br>
   *                         the size of this term also affects the stiffness of the <br>
   *                         integration problem for equilibrium-type muscle models: <br>
   *                         the closer to zero this term is, the stiffer the model <br>
   *                         will be (but only when (dlce(t)/dt)/vmax approaches 1.<br>
   * <br>
   *         @param dydxNearE The slope of the force velocity curve as it approaches<br>
   *                          the maximum eccentric (lengthening) contraction velocity.<br>
   *                          <br /><br /><br>
   *                           Minimum Value: &gt; dydxE<br>
   *                           Maximum Value: dydxNearE &lt; (fmaxE-1)<br>
   *                           <br /><br /><br>
   * <br>
   * <br>
   *         @param concCurviness    The dimensionless 'curviness' parameter that <br>
   *                                 can vary between 0 (a line) to 1 (a smooth, but <br>
   *                                 sharply bent elbow). This parameter affects only<br>
   *                                 the concentric side of the fv curve.<br>
   * <br>
   *         @param eccCurviness     The dimensionless 'curviness' parameter that <br>
   *                                 can vary between 0 (a line) to 1 (a smooth, but <br>
   *                                 sharply bent elbow). This parameter affects only <br>
   *                                 the eccentric side of the fv curve.<br>
   * <br>
   *         @param computeIntegral  If this is true, the integral for this curve<br>
   *                                 is numerically calculated and splined. If false, <br>
   *                                 this integral is not computed, and a call to <br>
   *                                 SmoothSegmentedFunction::calcIntegral() will throw <br>
   *                                 an exception<br>
   * <br>
   *         @param curveName The name of the muscle this curve applies to. This <br>
   *                           curve name should have the name of the muscle and the<br>
   *                           curve in it (e.g. "bicep_fiberForceVelocityCurve") <br>
   *                           so that, if this curve ever causes an exception, a <br>
   *                           user-friendly error message can be displayed to the<br>
   *                           end user to help them debug their model.<br>
   * <br>
   *         @throws SimTK::Exception unless these conditions are met<br>
   * <br>
   *             -0 &lt;= dydxC &lt; 1<br>
   *             -dydxC &lt; dydxNearC &lt; 1<br>
   *             -1 &lt; dydxIso<br>
   *             -dydxE &lt; (fmaxE-1) <br>
   *             -dydxE &lt; dydxNearC &lt; (fmaxE-1)<br>
   *             -0&lt;= concCurviness &lt;=0<br>
   *             -0 &lt;= eccCurviness &lt;= 0<br>
   * <br>
   *         @return SmoothSegmentedFunction* <br>
   * <br>
   *                 <img src="fig_SmoothSegmentedFunctionFactory_fvCurve.png"/><br>
   * <br>
   * <br>
   * <br>
   *         <b>Computational Costs</b><br>
   *         {@literal  
              Without Integral :   ~8,200 flops
              With Integral    : ~348,200 flops
          }<br>
   * <br>
   *         <b>Example:</b><br>
   *         {@code 
              double fmaxE = 1.8;
              double dydxC = 0.1;
              double dydxNearC = 0.25;
              double dydxE = 0.1;
              double dydxNearE = 0.15;
              double dydxIso= 5;
              double concCurviness = 0.1;
              double eccCurviness = 0.75;
  
              SmoothSegmentedFunction fiberFVCurve = SmoothSegmentedFunctionFactory::
                  createFiberForceVelocityCurve(fmaxE, 
                      dydxC, dydxNearC, dydxIso, dydxE, dydxNearE,
                      concCurviness,  eccCurviness,false,"test");
              fiberFVCurve.printMuscleCurveToFile();
          }             
   */
  public static SWIGTYPE_p_SmoothSegmentedFunction createFiberForceVelocityCurve(double fmaxE, double dydxC, double dydxNearC, double dydxIso, double dydxE, double dydxNearE, double concCurviness, double eccCurviness, boolean computeIntegral, String curveName) {
    long cPtr = opensimCommonJNI.SmoothSegmentedFunctionFactory_createFiberForceVelocityCurve(fmaxE, dydxC, dydxNearC, dydxIso, dydxE, dydxNearE, concCurviness, eccCurviness, computeIntegral, curveName);
    return (cPtr == 0) ? null : new SWIGTYPE_p_SmoothSegmentedFunction(cPtr, false);
  }

  /**
   *         This function will generate a C2-continuous (continuous to the 2nd<br>
   *         derivative) inverse curve that the function <br>
   *         createFiberForceVelocityCurve generates. The inverse force velocity <br>
   *         curve is required by every equilibrium muscle model in order to compute<br>
   *         the derivative of fiber velocity. To generate the inverse force velocity<br>
   *         curve simply call this function with EXACTLY the same parameter values<br>
   *         that you used to generate the force velocity curve. See the parameter<br>
   *         descriptions for createFiberForceVelocityCurve, as the parameters for<br>
   *         the inverse function are identical. The curve name should be different,<br>
   *         however, because this is an inverse curve <br>
   *         (e.g. "bicep_fiberForceVelocityInverseCurve")<br>
   * <br>
   * <br>
   *         <img src="fig_SmoothSegmentedFunctionFactory_fvInvCurve.png"/>
   */
  public static SWIGTYPE_p_SmoothSegmentedFunction createFiberForceVelocityInverseCurve(double fmaxE, double dydxC, double dydxNearC, double dydxIso, double dydxE, double dydxNearE, double concCurviness, double eccCurviness, boolean computeIntegral, String muscleName) {
    long cPtr = opensimCommonJNI.SmoothSegmentedFunctionFactory_createFiberForceVelocityInverseCurve(fmaxE, dydxC, dydxNearC, dydxIso, dydxE, dydxNearE, concCurviness, eccCurviness, computeIntegral, muscleName);
    return (cPtr == 0) ? null : new SWIGTYPE_p_SmoothSegmentedFunction(cPtr, false);
  }

  /**
   *         This element will generate a C2-continuous (continuous to the 2nd<br>
   *         derivative) compressive force profile curve as a function of pennation.<br>
   *         A muscle model with this element usually places this element parallel to<br>
   *         the fiber.The main function of this element is to prevent the fiber from <br>
   *         achieving a pennation angle of pi/2 radians. This type of element is <br>
   *         necessary for a parallelogram pennated equilibrium muscle models because <br>
   *         without it, the muscle model can deform to the point where a pennation <br>
   *         angle of pi/2 radians is reached, which causes a singularity in the <br>
   *         model.<br>
   * <br>
   * <br>
   *         @param phi0 The pennation angle at which the compressive force element<br>
   *                     starts to engage . When the pennation angle is greater than <br>
   *                     phi0, the compressive element is generating a force. When the <br>
   *                     pennation angle is less than phi0, the compressive element <br>
   *                     generates no force.<br>
   * <br>
   *         @param kiso This is the maximum stiffness of the compressive element, <br>
   *                     which occurs when the fiber is pennated by 90 degrees<br>
   * <br>
   *         @param curviness    The dimensionless 'curviness' parameter that <br>
   *                             can vary between 0 (a line) to 1 (a smooth, but <br>
   *                             sharply bent elbow)<br>
   * <br>
   *         @param computeIntegral  If this is true, the integral for this curve<br>
   *                                 is numerically calculated and splined. If false, <br>
   *                                 this integral is not computed, and a call to <br>
   *                                 .calcIntegral will throw an exception<br>
   * <br>
   *         @param curveName The name of the muscle this curve applies to. This <br>
   *                           curve name should have the name of the muscle and the<br>
   *                           curve in it <br>
   *                           (e.g. "bicep_fiberCompressiveForcePennationCurve") <br>
   *                           so that, if this curve ever causes an exception, a <br>
   *                           user-friendly error message can be displayed to the<br>
   *                           end user to help them debug their model.<br>
   * <br>
   *         @throws SimTK::Exception unless the following conditions are met<br>
   *             -0 &lt; phi0 &lt; SimTK::Pi/2<br>
   *             -kiso &gt; 1/(SimTK::Pi/2-phi0)<br>
   *             -0 &lt;= curviness &lt;= 1<br>
   * <br>
   *         @return SmoothSegmentedFunction object<br>
   * <br>
   *         <img src="fig_SmoothSegmentedFunctionFactory_fcphiCurve.png"/><br>
   * <br>
   * <br>
   * <br>
   * <br>
   * <br>
   *         <b>Computational Costs</b><br>
   *         {@literal  
              Without Integral :   ~4,100 flops
              With Integral    : ~174,100 flops
          }<br>
   * <br>
   *         <b>Example:</b><br>
   *         {@code 
              double phi0 = (SimTK::Pi/2)*(8.0/9.0);
              double kiso = 8.389863790885878;
              double c    = 0.0;
  
              SmoothSegmentedFunction fiberCEPhiCurve = SmoothSegmentedFunctionFactory::
                  createFiberCompressiveForcePennationCurve(phi0,kiso,c,
                  true,"test");
              fiberCEPhiCurve.printMuscleCurveToFile();
          }
   */
  public static SWIGTYPE_p_SmoothSegmentedFunction createFiberCompressiveForcePennationCurve(double phi0, double kiso, double curviness, boolean computeIntegral, String curveName) {
    long cPtr = opensimCommonJNI.SmoothSegmentedFunctionFactory_createFiberCompressiveForcePennationCurve(phi0, kiso, curviness, computeIntegral, curveName);
    return (cPtr == 0) ? null : new SWIGTYPE_p_SmoothSegmentedFunction(cPtr, false);
  }

  /**
   *         This element will generate a C2-continuous (continuous to the 2nd<br>
   *         derivative) compressive force profile curve as a function of <br>
   *         cos(pennation).<br>
   * <br>
   *         A muscle model with this element usually places this element in line <br>
   *         with the tendon. The main function of this element is to prevent the <br>
   *         fiber from achieving a pennation angle of pi/2 radians. This type of <br>
   *         element is necessary for a parallelogram pennated muscle models because <br>
   *         without it, the muscle model can deform to the point where a pennation <br>
   *         angle of pi/2 radians is reached, which causes a singularity in the <br>
   *         model.<br>
   * <br>
   * <br>
   *         @param cosPhi0 The cosine of the pennation angle at which the <br>
   *                         compressive force element starts to engage. When the <br>
   *                         cos of the pennation angle is greater than cosPhi0, the <br>
   *                         compressive element generates no force. When cos of the<br>
   *                         pennation angle is less than cosPhi0, the compressive <br>
   *                         element generates a compressive force.<br>
   * <br>
   *         @param kiso This is the maximum stiffness of the compressive element, <br>
   *                     which occurs when cosPhi is zero. This parameter must be<br>
   *                     negative<br>
   *                     cos<br>
   *         @param curviness    The dimensionless 'curviness' parameter that <br>
   *                             can vary between 0 (a line) to 1 (a smooth, but <br>
   *                             sharply bent elbow)<br>
   * <br>
   *         @param computeIntegral  If this is true, the integral for this curve<br>
   *                                 is numerically calculated and splined. If false, <br>
   *                                 this integral is not computed, and a call to <br>
   *                                 .calcIntegral will throw an exception<br>
   * <br>
   *         @param curveName The name of the muscle this curve applies to. This <br>
   *                           curve name should have the name of the muscle and the<br>
   *                           curve in it <br>
   *                      (e.g. "bicep_fiberCompressiveForceCosPennationCurve") <br>
   *                           so that, if this curve ever causes an exception, a <br>
   *                           user-friendly error message can be displayed to the<br>
   *                           end user to help them debug their model.<br>
   * <br>
   *         @throws SimTK::Exception unless the following conditions are met:<br>
   *             -0 &lt; cosPhi0<br>
   *             -kiso &gt; 1/(cosPhi0)<br>
   *             -0 &lt;= curviness &lt;= 1<br>
   * <br>
   *         @return SmoothSegmentedFunction* <br>
   * <br>
   *         <img src="fig_SmoothSegmentedFunctionFactory_fcCosPhiCurve.png"/><br>
   * <br>
   *         <b>Computational Costs</b><br>
   *         {@literal  
              Without Integral :   ~4,100 flops
              With Integral    : ~174,100 flops
          }<br>
   * <br>
   *         <b>Example:</b><br>
   *         {@code 
              double cosPhi0 = cos( (80.0/90.0)*SimTK::Pi/2);
              double kiso    = -1.2/(cosPhi0);
              double c       = 0.5;
  
              SmoothSegmentedFunction fiberCECosPhiCurve = SmoothSegmentedFunctionFactory::
                  createFiberCompressiveForceCosPennationCurve(cosPhi0,kiso,
                                                             c,true,"test");
              fiberCEPhiCurve.printMuscleCurveToFile();
          }
   */
  public static SWIGTYPE_p_SmoothSegmentedFunction createFiberCompressiveForceCosPennationCurve(double cosPhi0, double kiso, double curviness, boolean computeIntegral, String curveName) {
    long cPtr = opensimCommonJNI.SmoothSegmentedFunctionFactory_createFiberCompressiveForceCosPennationCurve(cosPhi0, kiso, curviness, computeIntegral, curveName);
    return (cPtr == 0) ? null : new SWIGTYPE_p_SmoothSegmentedFunction(cPtr, false);
  }

  /**
   *         This element will generate a C2-continuous (continuous to the second <br>
   *         derivative) curve that models a compressive force profile that is a <br>
   *         function of fiber length. The main function of<br>
   *         this element is to prevent the fiber from achieving an unrealistically<br>
   *         short length. This type of element is necessary for equilibrium-type <br>
   *         muscle models because of the editing that is done to the active force<br>
   *         length curve that endows an equilibrium model fiber with the ability to<br>
   *         to generate force when a physiological fiber cannot.<br>
   * <br>
   * <br>
   * <br>
   *         @param l0   The normalized fiber length at which the compressive element <br>
   *                     starts to engage. When the fiber is shorter than l0, the <br>
   *                     compressive element is generating a force. When the fiber <br>
   *                     length is longer than l0, the compressive element generates<br>
   *                     no force.<br>
   * <br>
   *         @param kiso This is the maximum stiffness of the compressive element, <br>
   *                     which occurs when the fiber has a length of 0, under a load <br>
   *                     of 1 maximum isometric unit of force.<br>
   * <br>
   *         @param curviness    The dimensionless 'curviness' parameter that <br>
   *                             can vary between 0 (a line) to 1 (a smooth, but <br>
   *                             sharply bent elbow)<br>
   * <br>
   *         @param computeIntegral  If this is true, the integral for this curve<br>
   *                                 is numerically calculated and splined. If false, <br>
   *                                 this integral is not computed, and a call to <br>
   *                                 .calcIntegral will throw an exception<br>
   * <br>
   *          @param curveName The name of the muscle this curve applies to. This <br>
   *                           curve name should have the name of the muscle and the<br>
   *                           curve in it <br>
   *                           (e.g. "bicep_fiberCompressiveForceLengthCurve") <br>
   *                           so that, if this curve ever causes an exception, a <br>
   *                           user-friendly error message can be displayed to the<br>
   *                           end user to help them debug their model.<br>
   * <br>
   *         @throws SimTK::Exception unless the following conditions are met<br>
   *             -e0 &gt; 0<br>
   *             -kiso &gt; 1/(e0)<br>
   *             -0 &lt;= curviness &lt;= 1<br>
   * <br>
   *         @return SmoothSegmentedFunction*<br>
   * <br>
   *         <img src="fig_SmoothSegmentedFunctionFactory_fpeCurve.png"/><br>
   * <br>
   * <br>
   *         <b>Computational Costs</b><br>
   *         {@literal  
              Without Integral :   ~4,100 flops
              With Integral    : ~174,100 flops
          }<br>
   * <br>
   *         <b>Example:</b><br>
   *         {@code 
              double lmax = 0.6;
              double kiso = -8.389863790885878;
              double c    = 0.1;//0.0;
  
              SmoothSegmentedFunction fiberCECurve = SmoothSegmentedFunctionFactory::
                  createFiberCompressiveForceLengthCurve(lmax,kiso,c,true,"test");
              fiberCECurve.printMuscleCurveToFile();
          }
   */
  public static SWIGTYPE_p_SmoothSegmentedFunction createFiberCompressiveForceLengthCurve(double l0, double kiso, double curviness, boolean computeIntegral, String curveName) {
    long cPtr = opensimCommonJNI.SmoothSegmentedFunctionFactory_createFiberCompressiveForceLengthCurve(l0, kiso, curviness, computeIntegral, curveName);
    return (cPtr == 0) ? null : new SWIGTYPE_p_SmoothSegmentedFunction(cPtr, false);
  }

  /**
   *         This function will generate a C2-continuous curve that fits a fiber's <br>
   *         tensile force length curve.<br>
   * <br>
   *         @param eZero The fiber strain at which the fiber begins to develop force.<br>
   *                      Thus an e0 of 0.0 means that the fiber will start to develop<br>
   *                      passive force when it has a normalized length of 1.0. Note<br>
   *                      that e0 can be positive or negative.<br>
   * <br>
   *         @param eIso The fiber strain at which the fiber develops 1 unit of <br>
   *                     normalized force (1 maximum isometric force). Note that the <br>
   *                     '1' is left off. Thus an e0 of 0.6 means that the fiber <br>
   *                     will develop an 1 normalized force unit when it is strained <br>
   *                     by 60% of its resting length, or to a normalized length of <br>
   *                     1.6<br>
   * <br>
   *         @param kLow   The normalized stiffness (or slope) of the fiber curve <br>
   *                       close to the location where the force-length curve <br>
   *                       approaches a normalized force of 0. This is usually <br>
   *                       chosen to be a small, but non-zero fraction of kIso <br>
   *                       (kLow = 0.025 kIso is typical).<br>
   * <br>
   *         @param kIso   The normalized stiffness (or slope) of the fiber curve <br>
   *                       when the fiber is strained by eIso (or has a length of <br>
   *                       1+eIso) under a load of 1 maximum isometric unit of force.<br>
   * <br>
   * <br>
   *         @param curviness    The dimensionless 'curviness' parameter that <br>
   *                             can vary between 0 (a line) to 1 (a smooth, but <br>
   *                             sharply bent elbow)<br>
   * <br>
   *         @param computeIntegral  If this is true, the integral for this curve<br>
   *                                 is numerically calculated and splined. If false, <br>
   *                                 this integral is not computed, and a call to <br>
   *                                 .calcIntegral will throw an exception<br>
   * <br>
   *          @param curveName The name of the muscle this curve applies to. This <br>
   *                           curve name should have the name of the muscle and the<br>
   *                           curve in it (e.g. "bicep_fiberForceLengthCurve") <br>
   *                           so that, if this curve ever causes an exception, a <br>
   *                           user-friendly error message can be displayed to the<br>
   *                           end user to help them debug their model.<br>
   * <br>
   *         @throws SimTK::Exception unless the following conditions are met<br>
   *             -eIso &gt; eZero            <br>
   *             -kIso &gt; 1/(eIso-eZero)<br>
   *             -0 &lt; kLow &lt; kIso<br>
   *             -0 &lt;= curviness &lt;= 1<br>
   * <br>
   *         @return SmoothSegmentedFunction*<br>
   * <br>
   * <br>
   *         <img src="fig_SmoothSegmentedFunctionFactory_fcLengthCurve.png"/><br>
   * <br>
   * <br>
   *         <b>Computational Costs</b><br>
   *         {@literal  
              Without Integral :   ~4,100 flops
              With Integral    : ~174,100 flops
          }<br>
   * <br>
   *         <b>Example:</b><br>
   *         {@code 
              double eIso      = 0.6;
              double eZero     = 0.0;
              double kIso      = 4.0/(eIso-eZero);
              double kNearZero = 0.025*kIso
              double c         = 0.5;
  
              SmoothSegmentedFunction fiberFLCurve 
              = SmoothSegmentedFunctionFactory::
                createFiberForceLengthCurve(eZero, eIso,
                                            kLow, kIso, c, true,"test");
              fiberFLCurve.printMuscleCurveToFile();
          }
   */
  public static SWIGTYPE_p_SmoothSegmentedFunction createFiberForceLengthCurve(double eZero, double eIso, double kLow, double kIso, double curviness, boolean computeIntegral, String curveName) {
    long cPtr = opensimCommonJNI.SmoothSegmentedFunctionFactory_createFiberForceLengthCurve(eZero, eIso, kLow, kIso, curviness, computeIntegral, curveName);
    return (cPtr == 0) ? null : new SWIGTYPE_p_SmoothSegmentedFunction(cPtr, false);
  }

  /**
   *         Will generate a C2-continuous (continuous to the second derivative) <br>
   *         curve in a MuscleFunctionObject object that fits a tendon's tensile <br>
   *         force length curve. <br>
   * <br>
   * <br>
   * <br>
   *         @param eIso   The tendon strain at which the tendon develops 1 unit<br>
   *                     of normalized force (1 maximum isometric force). Note that <br>
   *                     the'1' is left off. Thus an e0 of 0.04 means that the tendon <br>
   *                     will develop an 1 normalized force unit when it is strained <br>
   *                     by 4% of its resting length, at a normalized length of <br>
   *                     1.04<br>
   * <br>
   *         @param kIso    The normalized stiffness (or slope) of the tendon<br>
   *                         curve when the tendon is strained by e0 <br>
   *                         (or has a length of 1+e0) under a load of 1 maximum<br>
   *                         isometric unit of force.        <br>
   * <br>
   *         @param fToe    The normalized force at which the tendon smoothly<br>
   *                        transitions from the curved low stiffness region to <br>
   *                        the linear stiffness region.<br>
   * <br>
   *         @param curviness    The dimensionless 'curviness' parameter that <br>
   *                             can vary between 0 (a line) to 1 (a smooth, but <br>
   *                             sharply bent elbow)<br>
   * <br>
   *         @param computeIntegral  If this is true, the integral for this curve<br>
   *                                 is numerically calculated and splined. If false, <br>
   *                                 this integral is not computed, and a call to <br>
   *                                 .calcIntegral will throw an exception<br>
   * <br>
   *          @param curveName The name of the muscle this curve applies to. This <br>
   *                           curve name should have the name of the muscle and the<br>
   *                           curve in it (e.g. "bicep_tendonForceLengthCurve") <br>
   *                           so that, if this curve ever causes an exception, a <br>
   *                           user-friendly error message can be displayed to the<br>
   *                           end user to help them debug their model.<br>
   * <br>
   *         @throws SimTK::Exception unless the following conditions are met:<br>
   *             -0 &lt; fToe &lt; 1<br>
   *             -e0 &gt; 0<br>
   *             -kiso &gt; 1/e0<br>
   *             -0 &lt;= curviness &lt;= 1<br>
   * <br>
   *         @return SmoothSegmentedFunction*<br>
   * <br>
   *         <img src="fig_SmoothSegmentedFunctionFactory_fseCurve.png"/><br>
   * <br>
   * <br>
   *         <b>Computational Costs</b><br>
   *         {@literal  
              Without Integral :   ~4,100 flops
              With Integral    : ~174,100 flops
          }<br>
   * <br>
   *         <b>Example:</b><br>
   *         {@code 
              double e0   = 0.04;
              double kiso = 42.79679348815859;
              double fToe = 1.0/3.0
              double c    = 0.75;
  
              SmoothSegmentedFunction* tendonCurve = SmoothSegmentedFunctionFactory::
                                                  createTendonForceLengthCurve(
                                                    e0,kiso,fToe,c,true,"test");
              tendonCurve.printMuscleCurveToFile();  
          }
   */
  public static SWIGTYPE_p_SmoothSegmentedFunction createTendonForceLengthCurve(double eIso, double kIso, double fToe, double curviness, boolean computeIntegral, String curveName) {
    long cPtr = opensimCommonJNI.SmoothSegmentedFunctionFactory_createTendonForceLengthCurve(eIso, kIso, fToe, curviness, computeIntegral, curveName);
    return (cPtr == 0) ? null : new SWIGTYPE_p_SmoothSegmentedFunction(cPtr, false);
  }

  public SmoothSegmentedFunctionFactory() {
    this(opensimCommonJNI.new_SmoothSegmentedFunctionFactory(), true);
  }

}
