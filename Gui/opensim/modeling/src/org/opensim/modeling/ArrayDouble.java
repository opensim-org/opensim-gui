/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * A class for storing an array of values of type T.  The capacity of the class<br>
 * grows as needed.  To use this template for a class of type T, class T should<br>
 * implement the following methods:  default constructor, copy constructor,<br>
 * assignment operator (=), equality operator (==), and less than<br>
 * operator (&lt;).<br>
 * <br>
 * @version 1.0<br>
 * @author Frank C. Anderson
 */
public class ArrayDouble {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public ArrayDouble(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(ArrayDouble obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(ArrayDouble obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimCommonJNI.delete_ArrayDouble(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

	public void fromString(String string) {
      // Remove open and close parenth if any
      String workString= new String(string);
      int liveStart = workString.indexOf("(");
      int liveEnd = workString.indexOf(")");
      if (liveStart!=-1 && liveEnd!=-1){
          workString = workString.substring(liveStart+1, liveEnd);
      }
      else if (liveStart!=liveEnd){
          // throw new ParseException("Illegal format: Expect space separated" +
          //                          " values, optionally between matched " +
          //                          "parentheses", liveEnd);
          return;
      }
      String[] splits = workString.split(" ");
      double[] values = new double[splits.length];
      for(int i=0; i<splits.length; i++){
           values[i]=Double.parseDouble(splits[i]);
       }
       this.setValues(values, splits.length);
	}

  /**
   * Default constructor.<br>
   * <br>
   * @param aDefaultValue Default value of an array element.  This value<br>
   * is used to initialize array elements as the size of the array is<br>
   * changed.<br>
   * @param aSize Initial size of the array.  The array elements are<br>
   * initialized to aDefaultValue.<br>
   * @param aCapacity Initial capacity of the array.  The initial capacity<br>
   * is guaranteed to be at least as large as aSize + 1.
   */
  public ArrayDouble(double aDefaultValue, int aSize, int aCapacity) {
    this(opensimCommonJNI.new_ArrayDouble__SWIG_0(aDefaultValue, aSize, aCapacity), true);
  }

  /**
   * Default constructor.<br>
   * <br>
   * @param aDefaultValue Default value of an array element.  This value<br>
   * is used to initialize array elements as the size of the array is<br>
   * changed.<br>
   * @param aSize Initial size of the array.  The array elements are<br>
   * initialized to aDefaultValue.<br>
   * 
   */
  public ArrayDouble(double aDefaultValue, int aSize) {
    this(opensimCommonJNI.new_ArrayDouble__SWIG_1(aDefaultValue, aSize), true);
  }

  /**
   * Default constructor.<br>
   * <br>
   * @param aDefaultValue Default value of an array element.  This value<br>
   * is used to initialize array elements as the size of the array is<br>
   * changed.<br>
   * <br>
   * 
   */
  public ArrayDouble(double aDefaultValue) {
    this(opensimCommonJNI.new_ArrayDouble__SWIG_2(aDefaultValue), true);
  }

  /**
   * Default constructor.<br>
   * <br>
   * <br>
   * <br>
   * 
   */
  public ArrayDouble() {
    this(opensimCommonJNI.new_ArrayDouble__SWIG_3(), true);
  }

  /**
   * Copy constructor.<br>
   * <br>
   * @param aArray Array to be copied.
   */
  public ArrayDouble(ArrayDouble aArray) {
    this(opensimCommonJNI.new_ArrayDouble__SWIG_4(ArrayDouble.getCPtr(aArray), aArray), true);
  }

  public boolean arrayEquals(ArrayDouble aArray) {
    return opensimCommonJNI.ArrayDouble_arrayEquals(swigCPtr, this, ArrayDouble.getCPtr(aArray), aArray);
  }

  /**
   * Trim the capacity of this array so that it is one larger than the size<br>
   * of this array.  This is useful for reducing the amount of memory used<br>
   * by this array.  This capacity is kept at one larger than the size so<br>
   * that, for example, an array of characters can be treated as a NULL<br>
   * terminated string.
   */
  public void trim() {
    opensimCommonJNI.ArrayDouble_trim(swigCPtr, this);
  }

  /**
   * %Set the size of the array.  This method can be used to either increase<br>
   * or decrease the size of the array.  If this size of the array is<br>
   * increased, the new elements are initialized to the default value<br>
   * that was specified at the time of construction.<br>
   * <br>
   * Note that the size of an array is different than its capacity.  The size<br>
   * indicates how many valid elements are stored in an array.  The capacity<br>
   * indicates how much the size of the array can be increased without<br>
   * allocated more memory.  At all times size &lt;= capacity.<br>
   * <br>
   * @param aSize Desired size of the array.  The size must be greater than<br>
   * or equal to zero.
   */
  public boolean setSize(int aSize) {
    return opensimCommonJNI.ArrayDouble_setSize(swigCPtr, this, aSize);
  }

  /**
   * Get the size of the array.<br>
   * <br>
   * @return Size of the array.
   */
  public int getSize() {
    return opensimCommonJNI.ArrayDouble_getSize(swigCPtr, this);
  }

  /**
   *  Alternate name for getSize(). *
   */
  public int size() {
    return opensimCommonJNI.ArrayDouble_size(swigCPtr, this);
  }

  /**
   * Append a value onto the array.<br>
   * <br>
   * @param aValue Value to be appended.<br>
   * @return New size of the array, or, equivalently, the index to the new<br>
   * first empty element of the array.
   */
  public int append(double aValue) {
    return opensimCommonJNI.ArrayDouble_append__SWIG_0(swigCPtr, this, aValue);
  }

  /**
   * Append an array of values.<br>
   * <br>
   * @param aArray Array of values to append.<br>
   * @return New size of the array, or, equivalently, the index to the new<br>
   * first empty element of the array.
   */
  public int append(ArrayDouble aArray) {
    return opensimCommonJNI.ArrayDouble_append__SWIG_1(swigCPtr, this, ArrayDouble.getCPtr(aArray), aArray);
  }

  /**
   * Insert a value into the array at a specified index.<br>
   * <br>
   * This method is relatively computationally costly since many of the array<br>
   * elements may need to be shifted.<br>
   * <br>
   * @param aValue Value to be inserted.<br>
   * @param aIndex Index at which to insert the new value.  All current elements<br>
   * from aIndex to the end of the array are shifted one place in the direction<br>
   * of the end of the array.  If the specified index is greater than the<br>
   * current size of the array, the size of the array is increased to aIndex+1<br>
   * and the intervening new elements are initialized to the default value that<br>
   * was specified at the time of construction.<br>
   * @return Size of the array after the insertion.
   */
  public int insert(int aIndex, double aValue) {
    return opensimCommonJNI.ArrayDouble_insert(swigCPtr, this, aIndex, aValue);
  }

  /**
   * Remove a value from the array at a specified index.<br>
   * <br>
   * This method is relatively computationally costly since many of the array<br>
   * elements may need to be shifted.<br>
   * <br>
   * @param aIndex Index of the value to remove.  All elements from aIndex to<br>
   * the end of the array are shifted one place toward the beginning of<br>
   * the array.  If aIndex is less than 0 or greater than or equal to the<br>
   * current size of the array, no element is removed.<br>
   * @return Size of the array after the removal.
   */
  public int remove(int aIndex) {
    return opensimCommonJNI.ArrayDouble_remove(swigCPtr, this, aIndex);
  }

  /**
   * %Set the value at a specified index.<br>
   * <br>
   * @param aIndex Index of the array element to be set.  It is permissible<br>
   * for aIndex to be past the current end of the array- the capacity will<br>
   * be increased if necessary.  Values between the current end of the array<br>
   * and aIndex are not initialized.<br>
   * @param aValue Value.
   */
  public void set(int aIndex, double aValue) {
    opensimCommonJNI.ArrayDouble_set(swigCPtr, this, aIndex, aValue);
  }

  /**
   * Get a const reference to the value at a specified array index.<br>
   * <br>
   * If the index is negative or passed the end of the array, an exception<br>
   * is thrown.<br>
   * <br>
   * For faster execution, the array elements can be accessed through the<br>
   * overloaded operator[], which does no bounds checking.<br>
   * <br>
   * @param aIndex Index of the desired array element.<br>
   * @return const reference to the array element.<br>
   * @throws Exception if (aIndex&lt;0)||(aIndex&gt;=_size).<br>
   * @see operator[].
   */
  public double get(int aIndex) {
    return opensimCommonJNI.ArrayDouble_get(swigCPtr, this, aIndex);
  }

  public double getitem(int index) {
    return opensimCommonJNI.ArrayDouble_getitem(swigCPtr, this, index);
  }

  public void setitem(int index, double val) {
    opensimCommonJNI.ArrayDouble_setitem(swigCPtr, this, index, val);
  }

  /**
   * Get the last value in the array.<br>
   * <br>
   * @return Last value in the array.<br>
   * @throws Exception if the array is empty.
   */
  public double getLast() {
    return opensimCommonJNI.ArrayDouble_getLast(swigCPtr, this);
  }

  /**
   * Linear search for an element matching a given value.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @return Index of the array element matching aValue. If there is more than<br>
   * one such elements with the same value the index of the first of these elements<br>
   * is returned.  If no match is found, -1 is returned.
   */
  public int findIndex(double aValue) {
    return opensimCommonJNI.ArrayDouble_findIndex(swigCPtr, this, aValue);
  }

  /**
   * Linear search in reverse for an element matching a given value.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @return Index of the array element matching aValue. If there is more than<br>
   * one such elements with the same value the index of the last of these elements<br>
   * is returned.  If no match is found, -1 is returned.
   */
  public int rfindIndex(double aValue) {
    return opensimCommonJNI.ArrayDouble_rfindIndex(swigCPtr, this, aValue);
  }

  /**
   * Search for the largest value in the array that is less than or<br>
   * equal to a specified value.  If there is more than one element with this<br>
   * largest value, the index of the first of these elements can optionally be<br>
   * found, but this can be up to twice as costly.<br>
   * <br>
   * This method assumes that the array element values monotonically<br>
   * increase as the array index increases.  Note that monotonically<br>
   * increase means never decrease, so it is permissible for elements to<br>
   * <br>
   * A binary search is performed (i.e., the array is repeatedly subdivided<br>
   * into two bins one of which must contain the specified until the<br>
   * appropriate element is identified), so the performance of this method<br>
   * is approximately ln(n), where n is the size of the array.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @param aFindFirst If true, find the first element that satisfies<br>
   * the search.  If false, the index of any element that satisfies the<br>
   * search can be returned- which index will be returned depends on the<br>
   * length of the array and is therefore somewhat arbitrary. By default,<br>
   * this flag is false.<br>
   * @param aLo Lowest array index to consider in the search.<br>
   * @param aHi Highest array index to consider in the search.<br>
   * @return Index of the array element that has the largest value that is less<br>
   * than or equal to aValue.  If there is more than one such elements with the<br>
   * same value and aFindFirst is set to true, the index of the first of<br>
   * these elements is returned.  If an error is encountered (e.g., the array<br>
   * is empty), or the array contains no element that is less than or equal<br>
   * to aValue, -1 is returned.
   */
  public int searchBinary(double aValue, boolean aFindFirst, int aLo, int aHi) {
    return opensimCommonJNI.ArrayDouble_searchBinary__SWIG_0(swigCPtr, this, aValue, aFindFirst, aLo, aHi);
  }

  /**
   * Search for the largest value in the array that is less than or<br>
   * equal to a specified value.  If there is more than one element with this<br>
   * largest value, the index of the first of these elements can optionally be<br>
   * found, but this can be up to twice as costly.<br>
   * <br>
   * This method assumes that the array element values monotonically<br>
   * increase as the array index increases.  Note that monotonically<br>
   * increase means never decrease, so it is permissible for elements to<br>
   * <br>
   * A binary search is performed (i.e., the array is repeatedly subdivided<br>
   * into two bins one of which must contain the specified until the<br>
   * appropriate element is identified), so the performance of this method<br>
   * is approximately ln(n), where n is the size of the array.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @param aFindFirst If true, find the first element that satisfies<br>
   * the search.  If false, the index of any element that satisfies the<br>
   * search can be returned- which index will be returned depends on the<br>
   * length of the array and is therefore somewhat arbitrary. By default,<br>
   * this flag is false.<br>
   * @param aLo Lowest array index to consider in the search.<br>
   * <br>
   * @return Index of the array element that has the largest value that is less<br>
   * than or equal to aValue.  If there is more than one such elements with the<br>
   * same value and aFindFirst is set to true, the index of the first of<br>
   * these elements is returned.  If an error is encountered (e.g., the array<br>
   * is empty), or the array contains no element that is less than or equal<br>
   * to aValue, -1 is returned.
   */
  public int searchBinary(double aValue, boolean aFindFirst, int aLo) {
    return opensimCommonJNI.ArrayDouble_searchBinary__SWIG_1(swigCPtr, this, aValue, aFindFirst, aLo);
  }

  /**
   * Search for the largest value in the array that is less than or<br>
   * equal to a specified value.  If there is more than one element with this<br>
   * largest value, the index of the first of these elements can optionally be<br>
   * found, but this can be up to twice as costly.<br>
   * <br>
   * This method assumes that the array element values monotonically<br>
   * increase as the array index increases.  Note that monotonically<br>
   * increase means never decrease, so it is permissible for elements to<br>
   * <br>
   * A binary search is performed (i.e., the array is repeatedly subdivided<br>
   * into two bins one of which must contain the specified until the<br>
   * appropriate element is identified), so the performance of this method<br>
   * is approximately ln(n), where n is the size of the array.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @param aFindFirst If true, find the first element that satisfies<br>
   * the search.  If false, the index of any element that satisfies the<br>
   * search can be returned- which index will be returned depends on the<br>
   * length of the array and is therefore somewhat arbitrary. By default,<br>
   * this flag is false.<br>
   * <br>
   * <br>
   * @return Index of the array element that has the largest value that is less<br>
   * than or equal to aValue.  If there is more than one such elements with the<br>
   * same value and aFindFirst is set to true, the index of the first of<br>
   * these elements is returned.  If an error is encountered (e.g., the array<br>
   * is empty), or the array contains no element that is less than or equal<br>
   * to aValue, -1 is returned.
   */
  public int searchBinary(double aValue, boolean aFindFirst) {
    return opensimCommonJNI.ArrayDouble_searchBinary__SWIG_2(swigCPtr, this, aValue, aFindFirst);
  }

  /**
   * Search for the largest value in the array that is less than or<br>
   * equal to a specified value.  If there is more than one element with this<br>
   * largest value, the index of the first of these elements can optionally be<br>
   * found, but this can be up to twice as costly.<br>
   * <br>
   * This method assumes that the array element values monotonically<br>
   * increase as the array index increases.  Note that monotonically<br>
   * increase means never decrease, so it is permissible for elements to<br>
   * <br>
   * A binary search is performed (i.e., the array is repeatedly subdivided<br>
   * into two bins one of which must contain the specified until the<br>
   * appropriate element is identified), so the performance of this method<br>
   * is approximately ln(n), where n is the size of the array.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * <br>
   * <br>
   * <br>
   * @return Index of the array element that has the largest value that is less<br>
   * than or equal to aValue.  If there is more than one such elements with the<br>
   * same value and aFindFirst is set to true, the index of the first of<br>
   * these elements is returned.  If an error is encountered (e.g., the array<br>
   * is empty), or the array contains no element that is less than or equal<br>
   * to aValue, -1 is returned.
   */
  public int searchBinary(double aValue) {
    return opensimCommonJNI.ArrayDouble_searchBinary__SWIG_3(swigCPtr, this, aValue);
  }

  public void setValues(double[] dValues, int size) {
    opensimCommonJNI.ArrayDouble_setValues(swigCPtr, this, dValues, size);
  }

  public Vec3 getAsVec3() {
    return new Vec3(opensimCommonJNI.ArrayDouble_getAsVec3(swigCPtr, this), true);
  }

  public static Vec3 createVec3(double e1, double e2, double e3) {
    return new Vec3(opensimCommonJNI.ArrayDouble_createVec3__SWIG_0(e1, e2, e3), true);
  }

  public static Vec3 createVec3(double e1) {
    return new Vec3(opensimCommonJNI.ArrayDouble_createVec3__SWIG_1(e1), true);
  }

  public static Vec3 createVec3(double[] es) {
    return new Vec3(opensimCommonJNI.ArrayDouble_createVec3__SWIG_2(es), true);
  }

  public Vector getAsVector() {
    return new Vector(opensimCommonJNI.ArrayDouble_getAsVector(swigCPtr, this), true);
  }

  public void populateFromVector(Vector aVector) {
    opensimCommonJNI.ArrayDouble_populateFromVector(swigCPtr, this, Vector.getCPtr(aVector), aVector);
  }

  public static ArrayDouble getValuesFromVec3(Vec3 vec3) {
    return new ArrayDouble(opensimCommonJNI.ArrayDouble_getValuesFromVec3(Vec3.getCPtr(vec3), vec3), true);
  }

  public String toString() {
    return opensimCommonJNI.ArrayDouble_toString(swigCPtr, this);
  }

}
