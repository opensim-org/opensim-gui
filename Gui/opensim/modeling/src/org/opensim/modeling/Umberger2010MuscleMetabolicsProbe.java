/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * %Umberger2010MuscleMetabolicsProbe is a Probe ModelComponent for computing <br>
 * the net metabolic energy rate of a set of Muscles in the model during a <br>
 * simulation. <br>
 * <br>
 * <h1>%Umberger2010MuscleMetabolicsProbe Theory</h1><br>
 * <br>
 * The discussion here is based on the following papers:<br>
 * <br>
 * <a href="http://dx.doi.org/10.1371/journal.pone.0150378"><br>
 * Uchida, T. K., Hicks, J. L., Dembia, C. L., Delp, S. L. (2016). Stretching<br>
 * your energetic budget: how tendon compliance affects the metabolic cost of<br>
 * running. PLOS ONE 11(3), e0150378.</a><br>
 * <br>
 * <a href="http://www.ncbi.nlm.nih.gov/pubmed/20356877"><br>
 * Umberger, B. R. (2010). Stance and swing phase costs in human walking.<br>
 * J R Soc Interface 7, 1329-40.</a><br>
 * <br>
 * <a href="http://www.ncbi.nlm.nih.gov/pubmed/12745424"><br>
 * Umberger, B. R., Gerritsen, K. G. and Martin, P. E. (2003). <br>
 * A model of human muscle energy expenditure. <br>
 * Comput Methods Biomech Biomed Engin 6, 99-111.</a><br>
 * <br>
 * <i>Note that the equations below that describe the particular implementation <br>
 * of %Umberger2010MuscleMetabolicsProbe may slightly differ from the equations<br>
 * described in the representative publications above. Note also that we define<br>
 * positive muscle velocity to indicate lengthening (eccentric contraction) and<br>
 * negative muscle velocity to indicate shortening (concentric contraction).</i><br>
 * <br>
 * <br>
 * %Muscle metabolic power (or rate of metabolic energy consumption) is equal to<br>
 * the rate at which heat is liberated plus the rate at which work is done:<br>
 * <br>
 * <b>Edot = Bdot + sumOfAllMuscles(Adot + Mdot + Sdot + Wdot).</b><br>
 * <br>
 * - Bdot is the basal heat rate (W).<br>
 * - Adot is the activation heat rate (W).<br>
 * - Mdot is the maintenance heat rate (W).<br>
 * - Sdot is the shortening heat rate (W).<br>
 * - Wdot is the mechanical work rate (W).<br>
 * <br>
 * <br>
 * This probe also uses muscle parameters stored in the MetabolicMuscle object for each muscle.<br>
 * The full set of all MetabolicMuscles (MetabolicMuscleSet) is a property of this probe:<br>
 * <br>
 * - m = The mass of the muscle (kg).<br>
 * - r = Ratio of slow-twitch fibers in the muscle (between 0 and 1).<br>
 * <br>
 * The recruitment model described by Bhargava et al. (2004) is used to set the<br>
 * slow-twitch fiber ratio used in the calculations below. The ratio specified<br>
 * by the user indicates the composition of the muscle; this value is used only<br>
 * at full excitation (i.e., when all fibers are recruited). As excitation<br>
 * decreases from 1 to 0, the proportion of recruited fibers that are<br>
 * slow-twitch fibers increases from r to 1. See<br>
 * <a href="http://www.ncbi.nlm.nih.gov/pubmed/14672571">Bhargava, L.J., Pandy,<br>
 * M.G., Anderson, F.C. (2004) A phenomenological model for estimating metabolic<br>
 * energy consumption in muscle contraction. J Biomech 37:81-88</a> and Uchida<br>
 * et al. (2016). To assume a constant ratio of slow- and fast-twitch fiber<br>
 * recruitment, set the 'use_Bhargava_recruitment_model' property to false.<br>
 * <br>
 * <br>
 * <br>
 * <h2><b> BASAL HEAT RATE (W) </b></h2><br>
 * If <i>basal_rate_on</i> is set to true, then Bdot is calculated as follows:<br>
 * <br>
 * <b>Bdot = basal_coefficient * (m_body^basal_exponent) </b><br>
 *     - m_body = mass of the entire model<br>
 *     - basal_coefficient and basal_exponent are defined by their respective properties.<br>
 * <br>
 * <i>Note that this quantity is muscle independent. Rather it is calculated on a whole body level.</i><br>
 * <br>
 * <br>
 * <h2><b> ACTIVATION &amp; MAINTENANCE HEAT RATE (W) </b></h2><br>
 * If <i>activation_maintenance_rate_on</i> is set to true, then Adot+Mdot is calculated as follows:<br>
 * <br>
 * <b>Adot+Mdot = [128*(1-r) + 25] * A^0.6 * S                                         </b>,  <i> l_CE &lt;= l_CE_opt </i><br>
 * <br>
 * <b>Adot+Mdot = (0.4*[128*(1-r) + 25] + 0.6*[128*(1-r) + 25]*F_CE_iso) * A^0.6 * S   </b>,  <i> l_CE &gt;  l_CE_opt </i><br>
 *     - <b>A = u          </b>,    u &gt;  a<br>
 *     - <b>A = (u+a)/2    </b>,    u &lt;= a<br>
 * <br>
 *     - m = The mass of the muscle (kg).<br>
 *     - l_CE = muscle fiber length at the current time.<br>
 *     - l_CE_opt = optimal fiber length of the muscle.<br>
 *     - F_CE_iso = normalized contractile element force-length curve.<br>
 *     - u = muscle excitation at the current time.<br>
 *     - a = muscle activation at the current time.<br>
 *     - S = aerobic/anaerobic scaling factor, defined by the 'aerobic_factor' property (i.e. usually 1.0 for primarily anaerobic activities, 1.5 for primarily aerobic activities).<br>
 * <br>
 * <br>
 * <h2><b> SHORTENING HEAT RATE (W) </b></h2><br>
 * If <i>shortening_rate_on</i> is set to true, then Sdot is calculated as follows:<br>
 * <br>
 * <b>Sdot = m * (-[(alphaS_slow * v_CE_norm * r) + (alphaS_fast * v_CE_norm * (1-r))] * A^2 * S)           </b>,   <i>l_CE &lt;= l_CE_opt   &amp;   v_CE &gt;= 0 (concentric / isometric contraction)</i><br>
 * <br>
 * <b>Sdot = m * (-[(alphaS_slow * v_CE_norm * r) + (alphaS_fast * v_CE_norm * (1-r))] * A^2 * S * F_iso)   </b>,   <i>l_CE &gt;  l_CE_opt   &amp;   v_CE &gt;= 0 (concentric / isometric contraction)</i><br>
 * <br>
 * <b>Sdot = m * (alphaL * v_CE_norm * A * S)              </b>,   <i>l_CE &lt;= l_CE_opt   &amp;   v_CE &lt;  0 (eccentric contraction)</i><br>
 * <br>
 * <b>Sdot = m * (alphaL * v_CE_norm * A * S * F_CE_iso)   </b>,   <i>l_CE &gt;  l_CE_opt   &amp;   v_CE &lt;  0 (eccentric contraction)</i><br>
 *     - <b>A = u          </b>,    <i>u &gt;  a </i><br>
 *     - <b>A = (u+a)/2    </b>,    <i>u &lt;= a </i><br>
 * <br>
 *     - <b>alphaS_fast = 153 / v_CE_max          </b><br>
 *     - <b>alphaS_slow = 100 / (v_CE_max / 2.5)  </b><br>
 *     - <b>alphaL = 4.0 * alphaS_slow </b><br>
 * <br>
 *     - m = The mass of the muscle (kg).<br>
 *     - l_CE = muscle fiber length at the current time.<br>
 *     - l_CE_opt = optimal fiber length of the muscle.<br>
 *     - F_CE_iso = force that would be developed by the contractile element of muscle under isometric conditions with the current activation and fiber length.<br>
 *     - v_CE = muscle fiber velocity at the current time.<br>
 *     - v_CE_max = maximum shortening velocity of the muscle.<br>
 *     - v_CE_norm = normalized muscle fiber velocity (defined for this model as v_CE/l_CE_opt).<br>
 *               Note that this is a different metric to the typical normalized_muscle_fiber_velocity of v_CE/v_CE_max.<br>
 *     - S = aerobic/anaerobic scaling factor, defined by the 'aerobic_factor' property (i.e. usually 1.0 for primarily anaerobic activities, 1.5 for primarily aerobic activities).<br>
 * <br>
 * <br>
 * <h2><b> MECHANICAL WORK RATE (W) </b></h2><br>
 * If <i>mechanical_work_rate_on</i> is set to true, then Wdot is calculated as follows:<br>
 * <br>
 * <b>Wdot = -(F_CE * v_CE)           </b><br>
 *     - v_CE = muscle fiber velocity at the current time.<br>
 *     - F_CE = force developed by the contractile element of muscle at the current time.<br>
 * <br>
 * <br>
 * If we draw a control volume around the fiber, the first law of thermodynamics<br>
 * suggests that negative mechanical work should be included in Wdot. As such,<br>
 * we revert back to the model described in Umberger et al. (2003) by default.<br>
 * To exclude negative mechanical work from Wdot and use a coefficient of 0.3<br>
 * (rather than 4.0) to calculate alpha_L, set the<br>
 * 'include_negative_mechanical_work' property to false.<br>
 * <br>
 * During eccentric contraction, the magnitude of the (negative) mechanical work<br>
 * rate can exceed that of the total (positive) heat rate, resulting in a flow<br>
 * of energy into the fiber. Experiments indicate that the chemical processes<br>
 * involved in fiber contraction cannot be reversed, and most of the energy that<br>
 * is absorbed during eccentric contraction (in increased cross-bridge<br>
 * potentials, for example) is eventually converted into heat. Thus, we increase<br>
 * Sdot (if necessary) to ensure Edot &gt; 0 for each muscle. See<br>
 * <a href="http://www.ncbi.nlm.nih.gov/pubmed/9409483">Constable, J.K.,<br>
 * Barclay, C.J., Gibbs, C.L. (1997) Energetics of lengthening in mouse and toad<br>
 * skeletal muscles. J Physiol 505:205-215</a> and Uchida et al. (2016). To<br>
 * allow muscles to have negative total power, set the<br>
 * 'forbid_negative_total_power' property to false.<br>
 * <br>
 * <br>
 * Note that if enforce_minimum_heat_rate_per_muscle == true AND <br>
 * activation_maintenance_rate_on == shortening_rate_on == true, then the total heat<br>
 * rate (AMdot + Sdot) will be capped to a minimum value of 1.0 W/kg (Umberger(2003), page 104).<br>
 * <br>
 * <br>
 * <br>
 * <br>
 * <h1>Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter</h1><br>
 * <br>
 * Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter is an Object class that <br>
 * holds the metabolic parameters required to calculate metabolic power for a single muscle.<br>
 * <br>
 * <h2><b> Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter Properties </b></h2><br>
 * <br>
 * REQUIRED PROPERTIES<br>
 * - <b>specific_tension</b> = The specific tension of the muscle (Pascals (N/m^2)).<br>
 * - <b>density</b> = The density of the muscle (kg/m^3).<br>
 * - <b>ratio_slow_twitch_fibers</b> = Ratio of slow twitch fibers in the muscle (must be between 0 and 1).<br>
 * <br>
 * OPTIONAL PROPERTIES<br>
 * - <b>use_provided_muscle_mass</b> = An optional flag that allows the user to<br>
 *      explicitly specify a muscle mass. If set to true, the 'provided_muscle_mass'<br>
 *      property must be specified. The default setting is false, in which case, the<br>
 *      muscle mass is calculated from the following formula:<br>
 *          m = (Fmax/specific_tension)*density*Lm_opt, where <br>
 *              specific_tension and density are properties defined above<br>
 *                  (note that their default values are set based on mammalian muscle,<br>
 *                  0.25e6 N/m^2 and 1059.7 kg/m^3, respectively);<br>
 *              Fmax and Lm_opt are the maximum isometric force and optimal <br>
 *                  fiber length, respectively, of the muscle.<br>
 * <br>
 * - <b>provided_muscle_mass</b> = The user specified muscle mass (kg).<br>
 * <br>
 * <br>
 * @author Tim Dorn
 */
public class Umberger2010MuscleMetabolicsProbe extends Probe {
  private transient long swigCPtr;

  public Umberger2010MuscleMetabolicsProbe(long cPtr, boolean cMemoryOwn) {
    super(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(Umberger2010MuscleMetabolicsProbe obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(Umberger2010MuscleMetabolicsProbe obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_Umberger2010MuscleMetabolicsProbe(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static Umberger2010MuscleMetabolicsProbe safeDownCast(OpenSimObject obj) {
    long cPtr = opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new Umberger2010MuscleMetabolicsProbe(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Umberger2010MuscleMetabolicsProbe(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getConcreteClassName(swigCPtr, this);
  }

  /**
   *  Enabled by default. *
   */
  public void copyProperty_activation_maintenance_rate_on(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_activation_maintenance_rate_on(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_activation_maintenance_rate_on(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_activation_maintenance_rate_on__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_activation_maintenance_rate_on(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_activation_maintenance_rate_on__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_activation_maintenance_rate_on(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_activation_maintenance_rate_on__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_activation_maintenance_rate_on(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_activation_maintenance_rate_on(swigCPtr, this, value);
  }

  public void constructProperty_activation_maintenance_rate_on(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_activation_maintenance_rate_on(swigCPtr, this, initValue);
  }

  public boolean get_activation_maintenance_rate_on() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_activation_maintenance_rate_on__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_activation_maintenance_rate_on() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_activation_maintenance_rate_on__SWIG_1(swigCPtr, this), false);
  }

  public void set_activation_maintenance_rate_on(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_activation_maintenance_rate_on__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Enabled by default. *
   */
  public void copyProperty_shortening_rate_on(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_shortening_rate_on(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_shortening_rate_on(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_shortening_rate_on__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_shortening_rate_on(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_shortening_rate_on__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_shortening_rate_on(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_shortening_rate_on__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_shortening_rate_on(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_shortening_rate_on(swigCPtr, this, value);
  }

  public void constructProperty_shortening_rate_on(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_shortening_rate_on(swigCPtr, this, initValue);
  }

  public boolean get_shortening_rate_on() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_shortening_rate_on__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_shortening_rate_on() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_shortening_rate_on__SWIG_1(swigCPtr, this), false);
  }

  public void set_shortening_rate_on(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_shortening_rate_on__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Enabled by default. *
   */
  public void copyProperty_basal_rate_on(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_rate_on(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_basal_rate_on(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_basal_rate_on__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_basal_rate_on(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_basal_rate_on__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_basal_rate_on(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_basal_rate_on__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_basal_rate_on(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_basal_rate_on(swigCPtr, this, value);
  }

  public void constructProperty_basal_rate_on(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_rate_on(swigCPtr, this, initValue);
  }

  public boolean get_basal_rate_on() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_basal_rate_on__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_basal_rate_on() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_basal_rate_on__SWIG_1(swigCPtr, this), false);
  }

  public void set_basal_rate_on(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_basal_rate_on__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Enabled by default. *
   */
  public void copyProperty_mechanical_work_rate_on(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_mechanical_work_rate_on(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_mechanical_work_rate_on(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_mechanical_work_rate_on__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_mechanical_work_rate_on(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_mechanical_work_rate_on__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_mechanical_work_rate_on(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_mechanical_work_rate_on__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_mechanical_work_rate_on(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_mechanical_work_rate_on(swigCPtr, this, value);
  }

  public void constructProperty_mechanical_work_rate_on(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_mechanical_work_rate_on(swigCPtr, this, initValue);
  }

  public boolean get_mechanical_work_rate_on() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_mechanical_work_rate_on__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_mechanical_work_rate_on() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_mechanical_work_rate_on__SWIG_1(swigCPtr, this), false);
  }

  public void set_mechanical_work_rate_on(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_mechanical_work_rate_on__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Enabled by default. *
   */
  public void copyProperty_enforce_minimum_heat_rate_per_muscle(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_enforce_minimum_heat_rate_per_muscle(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_enforce_minimum_heat_rate_per_muscle(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_enforce_minimum_heat_rate_per_muscle__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_enforce_minimum_heat_rate_per_muscle(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_enforce_minimum_heat_rate_per_muscle__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_enforce_minimum_heat_rate_per_muscle(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_enforce_minimum_heat_rate_per_muscle__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_enforce_minimum_heat_rate_per_muscle(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_enforce_minimum_heat_rate_per_muscle(swigCPtr, this, value);
  }

  public void constructProperty_enforce_minimum_heat_rate_per_muscle(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_enforce_minimum_heat_rate_per_muscle(swigCPtr, this, initValue);
  }

  public boolean get_enforce_minimum_heat_rate_per_muscle() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_enforce_minimum_heat_rate_per_muscle__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_enforce_minimum_heat_rate_per_muscle() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_enforce_minimum_heat_rate_per_muscle__SWIG_1(swigCPtr, this), false);
  }

  public void set_enforce_minimum_heat_rate_per_muscle(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_enforce_minimum_heat_rate_per_muscle__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Default value = 1.5. *
   */
  public void copyProperty_aerobic_factor(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_aerobic_factor(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public double get_aerobic_factor(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_aerobic_factor__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_aerobic_factor(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_aerobic_factor__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_aerobic_factor(int i, double value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_aerobic_factor__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_aerobic_factor(double value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_aerobic_factor(swigCPtr, this, value);
  }

  public void constructProperty_aerobic_factor(double initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_aerobic_factor(swigCPtr, this, initValue);
  }

  public double get_aerobic_factor() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_aerobic_factor__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_aerobic_factor() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_aerobic_factor__SWIG_1(swigCPtr, this), false);
  }

  public void set_aerobic_factor(double value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_aerobic_factor__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Default value = 1.2. *
   */
  public void copyProperty_basal_coefficient(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_coefficient(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public double get_basal_coefficient(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_basal_coefficient__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_basal_coefficient(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_basal_coefficient__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_basal_coefficient(int i, double value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_basal_coefficient__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_basal_coefficient(double value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_basal_coefficient(swigCPtr, this, value);
  }

  public void constructProperty_basal_coefficient(double initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_coefficient(swigCPtr, this, initValue);
  }

  public double get_basal_coefficient() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_basal_coefficient__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_basal_coefficient() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_basal_coefficient__SWIG_1(swigCPtr, this), false);
  }

  public void set_basal_coefficient(double value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_basal_coefficient__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Default value = 1.0. *
   */
  public void copyProperty_basal_exponent(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_basal_exponent(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public double get_basal_exponent(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_basal_exponent__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_basal_exponent(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_basal_exponent__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_basal_exponent(int i, double value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_basal_exponent__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_basal_exponent(double value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_basal_exponent(swigCPtr, this, value);
  }

  public void constructProperty_basal_exponent(double initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_basal_exponent(swigCPtr, this, initValue);
  }

  public double get_basal_exponent() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_basal_exponent__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_basal_exponent() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_basal_exponent__SWIG_1(swigCPtr, this), false);
  }

  public void set_basal_exponent(double value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_basal_exponent__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Default value = 1.0. *
   */
  public void copyProperty_muscle_effort_scaling_factor(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_muscle_effort_scaling_factor(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public double get_muscle_effort_scaling_factor(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_muscle_effort_scaling_factor__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_muscle_effort_scaling_factor(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_muscle_effort_scaling_factor__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_muscle_effort_scaling_factor(int i, double value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_muscle_effort_scaling_factor__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_muscle_effort_scaling_factor(double value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_muscle_effort_scaling_factor(swigCPtr, this, value);
  }

  public void constructProperty_muscle_effort_scaling_factor(double initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_muscle_effort_scaling_factor(swigCPtr, this, initValue);
  }

  public double get_muscle_effort_scaling_factor() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_muscle_effort_scaling_factor__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_muscle_effort_scaling_factor() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_muscle_effort_scaling_factor__SWIG_1(swigCPtr, this), false);
  }

  public void set_muscle_effort_scaling_factor(double value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_muscle_effort_scaling_factor__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Enabled by default. *
   */
  public void copyProperty_use_Bhargava_recruitment_model(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_use_Bhargava_recruitment_model(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_use_Bhargava_recruitment_model(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_use_Bhargava_recruitment_model__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_use_Bhargava_recruitment_model(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_use_Bhargava_recruitment_model__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_use_Bhargava_recruitment_model(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_use_Bhargava_recruitment_model__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_use_Bhargava_recruitment_model(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_use_Bhargava_recruitment_model(swigCPtr, this, value);
  }

  public void constructProperty_use_Bhargava_recruitment_model(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_use_Bhargava_recruitment_model(swigCPtr, this, initValue);
  }

  public boolean get_use_Bhargava_recruitment_model() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_use_Bhargava_recruitment_model__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_use_Bhargava_recruitment_model() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_use_Bhargava_recruitment_model__SWIG_1(swigCPtr, this), false);
  }

  public void set_use_Bhargava_recruitment_model(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_use_Bhargava_recruitment_model__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Enabled by default. *
   */
  public void copyProperty_include_negative_mechanical_work(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_include_negative_mechanical_work(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_include_negative_mechanical_work(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_include_negative_mechanical_work__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_include_negative_mechanical_work(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_include_negative_mechanical_work__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_include_negative_mechanical_work(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_include_negative_mechanical_work__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_include_negative_mechanical_work(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_include_negative_mechanical_work(swigCPtr, this, value);
  }

  public void constructProperty_include_negative_mechanical_work(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_include_negative_mechanical_work(swigCPtr, this, initValue);
  }

  public boolean get_include_negative_mechanical_work() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_include_negative_mechanical_work__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_include_negative_mechanical_work() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_include_negative_mechanical_work__SWIG_1(swigCPtr, this), false);
  }

  public void set_include_negative_mechanical_work(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_include_negative_mechanical_work__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Enabled by default. *
   */
  public void copyProperty_forbid_negative_total_power(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_forbid_negative_total_power(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_forbid_negative_total_power(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_forbid_negative_total_power__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_forbid_negative_total_power(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_forbid_negative_total_power__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_forbid_negative_total_power(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_forbid_negative_total_power__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_forbid_negative_total_power(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_forbid_negative_total_power(swigCPtr, this, value);
  }

  public void constructProperty_forbid_negative_total_power(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_forbid_negative_total_power(swigCPtr, this, initValue);
  }

  public boolean get_forbid_negative_total_power() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_forbid_negative_total_power__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_forbid_negative_total_power() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_forbid_negative_total_power__SWIG_1(swigCPtr, this), false);
  }

  public void set_forbid_negative_total_power(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_forbid_negative_total_power__SWIG_1(swigCPtr, this, value);
  }

  /**
   *  Default value = true *
   */
  public void copyProperty_report_total_metabolics_only(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_report_total_metabolics_only(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public boolean get_report_total_metabolics_only(int i) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_report_total_metabolics_only__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_report_total_metabolics_only(int i) {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_report_total_metabolics_only__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_report_total_metabolics_only(int i, boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_report_total_metabolics_only__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_report_total_metabolics_only(boolean value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_report_total_metabolics_only(swigCPtr, this, value);
  }

  public void constructProperty_report_total_metabolics_only(boolean initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_report_total_metabolics_only(swigCPtr, this, initValue);
  }

  public boolean get_report_total_metabolics_only() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_report_total_metabolics_only__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_report_total_metabolics_only() {
    return new SWIGTYPE_p_bool(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_report_total_metabolics_only__SWIG_1(swigCPtr, this), false);
  }

  public void set_report_total_metabolics_only(boolean value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_report_total_metabolics_only__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe source) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_copyProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(swigCPtr, this, Umberger2010MuscleMetabolicsProbe.getCPtr(source), source);
  }

  public Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(int i) {
    return new Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet__SWIG_0(swigCPtr, this, i), false);
  }

  public Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(int i) {
    return new Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(int i, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet__SWIG_0(swigCPtr, this, i, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet.getCPtr(value), value);
  }

  public int append_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet value) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_append_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(swigCPtr, this, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet.getCPtr(value), value);
  }

  public void constructProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet initValue) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_constructProperty_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(swigCPtr, this, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet.getCPtr(initValue), initValue);
  }

  public Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet() {
    return new Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_get_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet__SWIG_1(swigCPtr, this), false);
  }

  public Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet() {
    return new Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_upd_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet__SWIG_1(swigCPtr, this), false);
  }

  public void set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet(Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet value) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_set_Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet__SWIG_1(swigCPtr, this, Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameterSet.getCPtr(value), value);
  }

  /**
   *  Default constructor 
   */
  public Umberger2010MuscleMetabolicsProbe() {
    this(opensimSimulationJNI.new_Umberger2010MuscleMetabolicsProbe__SWIG_0(), true);
  }

  /**
   *  Convenience constructor 
   */
  public Umberger2010MuscleMetabolicsProbe(boolean activation_maintenance_rate_on, boolean shortening_rate_on, boolean basal_rate_on, boolean work_rate_on) {
    this(opensimSimulationJNI.new_Umberger2010MuscleMetabolicsProbe__SWIG_1(activation_maintenance_rate_on, shortening_rate_on, basal_rate_on, work_rate_on), true);
  }

  /**
   *  Compute muscle metabolic power. 
   */
  public Vector computeProbeInputs(State state) {
    return new Vector(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_computeProbeInputs(swigCPtr, this, State.getCPtr(state), state), true);
  }

  /**
   *  Returns the number of probe inputs in the vector returned by computeProbeInputs(). 
   */
  public int getNumProbeInputs() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getNumProbeInputs(swigCPtr, this);
  }

  /**
   *  Returns the column labels of the probe values for reporting. <br>
   *         Currently uses the Probe name as the column label, so be sure<br>
   *         to name your probe appropriately!  
   */
  public ArrayStr getProbeOutputLabels() {
    return new ArrayStr(opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getProbeOutputLabels(swigCPtr, this), true);
  }

  /**
   *  Get the number of muscles being analyzed in the metabolic analysis. 
   */
  public int getNumMetabolicMuscles() {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getNumMetabolicMuscles(swigCPtr, this);
  }

  /**
   *  Add a muscle and its parameters so that it can be included in the metabolic analysis. 
   */
  public void addMuscle(String muscleName, double ratio_slow_twitch_fibers) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_addMuscle__SWIG_0(swigCPtr, this, muscleName, ratio_slow_twitch_fibers);
  }

  /**
   *  Add a muscle and its parameters so that it can be included in the metabolic analysis. 
   */
  public void addMuscle(String muscleName, double ratio_slow_twitch_fibers, double muscle_mass) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_addMuscle__SWIG_1(swigCPtr, this, muscleName, ratio_slow_twitch_fibers, muscle_mass);
  }

  /**
   *  Remove a muscle from the metabolic analysis. 
   */
  public void removeMuscle(String muscleName) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_removeMuscle(swigCPtr, this, muscleName);
  }

  /**
   *  %Set an existing muscle to use a provided muscle mass. 
   */
  public void useProvidedMass(String muscleName, double providedMass) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_useProvidedMass(swigCPtr, this, muscleName, providedMass);
  }

  /**
   *  %Set an existing muscle to calculate its own mass. 
   */
  public void useCalculatedMass(String muscleName) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_useCalculatedMass(swigCPtr, this, muscleName);
  }

  /**
   *  Get whether the muscle mass is being explicitly provided.<br>
   *         True means that it is using the property 'provided_muscle_mass'<br>
   *         False means that the muscle mass is being calculated from muscle properties. 
   */
  public boolean isUsingProvidedMass(String muscleName) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_isUsingProvidedMass(swigCPtr, this, muscleName);
  }

  /**
   *  Get the muscle mass used in the metabolic analysis. The value<br>
   *         returned will depend on if the muscle mass is explicitly provided<br>
   *         (i.e. isUsingProvidedMass = true), or if it is being automatically<br>
   *         calculated from muscle data already present in the model<br>
   *         (i.e. isUsingProvidedMass = true). 
   */
  public double getMuscleMass(String muscleName) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getMuscleMass(swigCPtr, this, muscleName);
  }

  /**
   *  Get the ratio of slow twitch fibers for an existing muscle. 
   */
  public double getRatioSlowTwitchFibers(String muscleName) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getRatioSlowTwitchFibers(swigCPtr, this, muscleName);
  }

  /**
   *  %Set the ratio of slow twitch fibers for an existing muscle. 
   */
  public void setRatioSlowTwitchFibers(String muscleName, double ratio) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_setRatioSlowTwitchFibers(swigCPtr, this, muscleName, ratio);
  }

  /**
   *  Get the density for an existing muscle (kg/m^3). 
   */
  public double getDensity(String muscleName) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getDensity(swigCPtr, this, muscleName);
  }

  /**
   *  %Set the density for an existing muscle (kg/m^3). 
   */
  public void setDensity(String muscleName, double density) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_setDensity(swigCPtr, this, muscleName, density);
  }

  /**
   *  Get the specific tension for an existing muscle (Pascals (N/m^2)). 
   */
  public double getSpecificTension(String muscleName) {
    return opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_getSpecificTension(swigCPtr, this, muscleName);
  }

  /**
   *  %Set the specific tension for an existing muscle (Pascals (N/m^2)). 
   */
  public void setSpecificTension(String muscleName, double specificTension) {
    opensimSimulationJNI.Umberger2010MuscleMetabolicsProbe_setSpecificTension(swigCPtr, this, muscleName, specificTension);
  }

}
