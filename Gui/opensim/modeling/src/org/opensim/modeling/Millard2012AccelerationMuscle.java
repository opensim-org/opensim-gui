/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * This class implements a 3 state (activation,fiber length and fiber velocity) <br>
 * acceleration musculo-tendon model that has several advantages over <br>
 * equilibrium musculo-tendon models: it is possible to simulate 0 activation, it <br>
 * requires fewer integrator steps to simulate, and physiological active <br>
 * force-length (with a minimum value of 0) and force velocity (with true <br>
 * asymptotes at the maximum shortening and lengthening velocities) <br>
 * curves can be employed.<br>
 * <br>
 * <img src=fig_Millard2012AccelerationMuscle.png/><br>
 * <br>
 * The dynamic equation of the mass, constrained to move in direction <br>
 *   \hat{i}  is given by the scalar equation:<br>
 * <br>
 *  
m \ddot{x} = F_{SE} - F_{CE} \cdot \hat{i}  
<br>
 * <br>
 * <br>
 * The kinematic expression for the acceleration of the mass,   \ddot{s} , <br>
 * expressed in terms of the fiber length,_{CE} , and pennation angle 
  is

\f[
\ddot{x} = \Big(\ddot{l}_{CE} \cos \phi - 2 \dot{l}_{CE}\dot{\phi}\sin\phi 
- \dot{\phi}^2 l_{CE} \cos \phi - \ddot{\phi} l_{CE} \sin \phi\Big)


The kinematic expression for the angular acceleration of the pennation angle 
can be found by taking the second derivative of the pennation constraint 
equation


l_{CE} \sin \phi = h


which yields


\ddot{\phi} = -\Big( \ddot{l}_{CE}\sin\phi + 
                    2 \dot{l}_{CE} \dot{\phi} \cos\phi
                    - \dot{\phi}^2 l_{CE} \sin \phi \Big) 
\Big( l_{CE} \cos \phi \Big)


An expression for  \ddot{l}_{CE}  can be obtained by substituting in
the equations  \ddot{\phi}   
into the equation for \ddot{x}  and simplifying:

\ddot{l}_{CE} = \frac{1}{m} \Big(  F_{SE} - F_{CE} \cdot \hat{i} \Big) \cos \phi
                + l_{CE} \dot{\phi}^2


Notice that the above equation for \ddot{l}_{CE}  has no singularities,
provided that there are no singularities in  F_{SE}  and 
 F_{M}\cdot\hat{i} . The force the fiber applies to the tendon (in N), 
_{CE}, is given by (+'ve is tension)<br>
 * <br>
 * \f[<br>
 * F_{CE} \cdot \hat{i} =  <br>
 * f_{ISO}\Big(\mathbf{a} \mathbf{f}_L(\hat{l}_{CE}) <br>
 * \mathbf{f}_V(\frac{\hat{v}_{CE}}{v_{MAX}}) <br>
 * + \beta_{CE}\hat{v}_{CE}<br>
 * + \mathbf{f}_{PE}(\hat{l}_{CE})(1+\beta_{PE}\hat{v}_{CE}) <br>
 * - \mathbf{f}_K(\hat{l}_{CE})(1-\beta_{K}\hat{v}_{CE})  \Big) \cos \phi<br>
 * -  f_{ISO} \Big( \mathbf{f}_{c\phi}(\cos \phi)<br>
 * (1- \beta_{c \phi}<br>
 * \frac{d}{dt}(\frac{l_{CE}\cos\phi}{l_{CE,OPT}\cos\phi_{OPT}})) \Big)<br>
 * <br>
 * <br>
 * The force the tendon generates (in N) is given by (+'ve is tension)<br>
 * <br>
 *  
F_{SE} =  
f_{ISO} \mathbf{f}_{SE}(\hat{l}_{SE})(1+\beta_{SE}\hat{v}_{SE}) 
<br>
 * <br>
 * Every elastic element ( \mathbf{f}_{PE}, \mathbf{f}_{K},<br>
 *  \mathbf{f}_{c\phi}, and  \mathbf{f}_{SE}) is accompanied by a <br>
 * non-linear damping element of a form that is identical to the damping found <br>
 * in a Hunt-Crossley contact model. Additionally a linear damping element,<br>
 *  \beta_{CE}\hat{v}_{CE}, is<br>
 * located in the fiber as in J.He et al. Damping is necessary to include in this <br>
 * model to prevent the mass from oscillating in a non-physiologic manner. <br>
 * Nonlinear damping Hunt-Crossley damping (where the damping force is scaled <br>
 * by the elastic force) has been chosen because this form of damping doesn't <br>
 * increase the stiffness of the system equations <br>
 * (because it is gradually turned on). <br>
 * <br>
 * As with the Hunt-Crossley contact model, the force generated by the nonlinear <br>
 * spring and damper saturated so that it is greater than or equal to zero. This<br>
 * saturation is necessary to ensure that tension elements can only generate <br>
 * tensile forces, and that compressive elements only generate compressive forces. <br>
 * Note that the sign conventions have been chosen so that damping forces are <br>
 * generated in the correct direction for each element.<br>
 * <br>
 * *}{<br>
 * (1+_{PE}_{CE}) &gt; 0 \<br>
 * (1-_{K}_{CE}) &gt; 0 \<br>
 * (1- _{c <br>
 * (_{CE}_{CE,OPT}_{OPT}})) &gt; 0 \<br>
 * (1+_{SE}_{SE}) &gt; 0<br>
 * <br>
 * <br>
 * <br>
 * For more information on these new terms please see the<br>
 * doxygen for FiberCompressiveForceLengthCurve, <br>
 * FiberCompressiveForceCosPennationCurve, and <br>
 * MuscleFirstOrderActivationDynamicModel.<br>
 * <br>
 * <b>Units</b><br>
 * <br>
 * <li>m: meters<br>
 *</li> <li>rad: radians<br>
 *</li> <li>N: Newtons<br>
 *</li> <li>kg: kilograms<br>
 *</li> <li>s: seconds</li><br>
 * <br>
 * <b>Caution</b><br>
 * <br>
 * The Millard2012AccelerationMuscle class is experimental and has not been<br>
 * extensively tested in all operational conditions.<br>
 * <br>
 * <b>Usage</b><br>
 * <br>
 *  Note that this object should be updated through the set methods provided. <br>
 *  These set methods will take care of rebuilding the muscle correctly. If you<br>
 *  modify the properties directly, the curve will not be rebuilt, and upon<br>
 *  calling a function that requires a state an exception will be thrown because <br>
 *  the muscle is out of date with its properties.<br>
 * <br>
 *  Note that this muscle does not currently implement the ignore_tendon_compliance<br>
 *  flag, nor the ignore_activation_dynamics flag.<br>
 * <br>
 * <b>Nomenclature</b><br>
 * <br>
 * Note that dot notation is used to denote time derivatives (units of <br>
 * /s  and \f$m/s^2 in this case), where as the hat symbol <br>
 * (as in  \hat{l}, \hat{v}) is used to denote time derivatives that have<br>
 * been scaled by a characteristic dimension (appear in units of <br>
 * /s  and \f$1/s^2 in this case)<br>
 * <br>
 * <li> : is the mass located at the junction between the fiber and the 
    tendon. This mass should be thought of as a time constant that indicates
    how quickly this model will converge to the force an equilibrium 
    muscle-tendon model would produce (\f$kg)<br>
 *</li> <li> \ddot{x}: is the acceleration of the mass, <br>
 *      in the  \hat{i} direction (/s^2 )
\li \f$F_{SE}: is the force developed by the tendon ( )
\li \f$F_{CE}\cdot\hat{i}: is the force developed by the fiber along the<br>
 *     tendon ( )

\li \f$l_{CE}</li>: Length of the fiber(m)<br>
 * <li>_{CE,OPT} : Length the fiber generates maximal isometric force (m)
\li _{CE}=l_{CE}/l_{CE,OPT} : 
        Normalized length of the fiber (dimensionless)
\li _{CE}=_{CE}/l_{CE,OPT} : 
        Fiber velocity divided by (\f$1/s)<br>
 *</li> <li> \hat{v}_{MAX}: <br>
 *         Maximum normalized fiber velocity (_{CE,OPT}/s ). This
                   quantity typically ranges between 10 and 15 lengths 
                   per second  (1/s)


\li</li>  : Pennation angle(rad)
\li _{OPT} : Pennation angle when the fiber is at its optimal 
                      length (rad)

\li \f$l_{SE}: Length of the series element (tendon) (m)<br>
 * <li>_{SE,R} : Resting length of the series element(m)
\li _{SE} = l_{SE}/l_{SE,R} : 
                Normalized length of the series element (dimensionless)
\li  _{SE} = _{SE}/l_{SE,R} : 
                    Normalized velocity of the tendon (1/s)

\li \f$f_{ISO}</li>: maximum force the muscle can develop statically <br>
 * ( \hat{v}_{CE}=0) at its optimal length (_{CE,OPT} ) and 
pennation angle (_{OPT} )

\li  : activation (unitless)
\li _L(_{CE}) : 
        Active force length multiplier (dimensionless)
\li _V(_{CE}}{v_{MAX}}) : 
        Force velocity multiplier (dimensionless)
\li _{PE}(_{CE}) : 
        Passive force length multiplier (dimensionless)
\li _{K}(_{CE}) :
        Fiber compressive force length multiplier (dimensionless)
\li _{c() :
        Fiber compressive cosine pennation multiplier (dimensionless)
\li _{SE}(_{SE}) :
        Series element (tendon) force-length multiplier (dimensionless)

\li _{CE} : Fiber damping (s)
\li _{PE} : Fiber parallel element damping coefficient (s)
\li _{K} : Fiber compressive force length damping coefficient (s)
\li _{c  : Fiber compressive cosine pennation damping 
                          coefficient (s)
\li _{SE} : Series element (tendon) force length damping coefficient 
                      (s)




<B> References </B>

Hunt,K., and Crossley,F. Coefficient of restitution interpreted as damping in 
vibroimpact. Transactions of the ASME Journal of Applied Mechanics, 
42(E):440445, 1975.

J.He, W.S. Levine, and G.E. Leob."The Modelling of the 
Neuro-musculo-skeletal Control System of A Cat Hindlimb", 
Proceedings of the IEEE International Symposium on Intelligent Control, 1988.

@author Matt Millard


 */
public class Millard2012AccelerationMuscle extends Muscle {
  private transient long swigCPtr;

  public Millard2012AccelerationMuscle(long cPtr, boolean cMemoryOwn) {
    super(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(Millard2012AccelerationMuscle obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimActuatorsAnalysesToolsJNI.delete_Millard2012AccelerationMuscle(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static Millard2012AccelerationMuscle safeDownCast(OpenSimObject obj) {
    long cPtr = opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new Millard2012AccelerationMuscle(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Millard2012AccelerationMuscle(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getConcreteClassName(swigCPtr, this);
  }

  public void copyProperty_default_activation(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_default_activation(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_default_activation(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_default_activation__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_default_activation(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_default_activation__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_default_activation(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_default_activation__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_default_activation(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_default_activation(swigCPtr, this, value);
  }

  public void constructProperty_default_activation(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_default_activation(swigCPtr, this, initValue);
  }

  public double get_default_activation() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_default_activation__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_default_activation() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_default_activation__SWIG_1(swigCPtr, this), false);
  }

  public void set_default_activation(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_default_activation__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_default_fiber_length(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_default_fiber_length(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_default_fiber_length(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_default_fiber_length__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_default_fiber_length(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_default_fiber_length__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_default_fiber_length(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_default_fiber_length__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_default_fiber_length(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_default_fiber_length(swigCPtr, this, value);
  }

  public void constructProperty_default_fiber_length(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_default_fiber_length(swigCPtr, this, initValue);
  }

  public double get_default_fiber_length() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_default_fiber_length__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_default_fiber_length() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_default_fiber_length__SWIG_1(swigCPtr, this), false);
  }

  public void set_default_fiber_length(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_default_fiber_length__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_default_fiber_velocity(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_default_fiber_velocity(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_default_fiber_velocity(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_default_fiber_velocity__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_default_fiber_velocity(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_default_fiber_velocity__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_default_fiber_velocity(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_default_fiber_velocity__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_default_fiber_velocity(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_default_fiber_velocity(swigCPtr, this, value);
  }

  public void constructProperty_default_fiber_velocity(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_default_fiber_velocity(swigCPtr, this, initValue);
  }

  public double get_default_fiber_velocity() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_default_fiber_velocity__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_default_fiber_velocity() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_default_fiber_velocity__SWIG_1(swigCPtr, this), false);
  }

  public void set_default_fiber_velocity(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_default_fiber_velocity__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_MuscleFirstOrderActivationDynamicModel(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public MuscleFirstOrderActivationDynamicModel get_MuscleFirstOrderActivationDynamicModel(int i) {
    return new MuscleFirstOrderActivationDynamicModel(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_MuscleFirstOrderActivationDynamicModel__SWIG_0(swigCPtr, this, i), false);
  }

  public MuscleFirstOrderActivationDynamicModel upd_MuscleFirstOrderActivationDynamicModel(int i) {
    return new MuscleFirstOrderActivationDynamicModel(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_MuscleFirstOrderActivationDynamicModel__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_MuscleFirstOrderActivationDynamicModel(int i, MuscleFirstOrderActivationDynamicModel value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_MuscleFirstOrderActivationDynamicModel__SWIG_0(swigCPtr, this, i, MuscleFirstOrderActivationDynamicModel.getCPtr(value), value);
  }

  public int append_MuscleFirstOrderActivationDynamicModel(MuscleFirstOrderActivationDynamicModel value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_MuscleFirstOrderActivationDynamicModel(swigCPtr, this, MuscleFirstOrderActivationDynamicModel.getCPtr(value), value);
  }

  public void constructProperty_MuscleFirstOrderActivationDynamicModel(MuscleFirstOrderActivationDynamicModel initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_MuscleFirstOrderActivationDynamicModel(swigCPtr, this, MuscleFirstOrderActivationDynamicModel.getCPtr(initValue), initValue);
  }

  public MuscleFirstOrderActivationDynamicModel get_MuscleFirstOrderActivationDynamicModel() {
    return new MuscleFirstOrderActivationDynamicModel(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_MuscleFirstOrderActivationDynamicModel__SWIG_1(swigCPtr, this), false);
  }

  public MuscleFirstOrderActivationDynamicModel upd_MuscleFirstOrderActivationDynamicModel() {
    return new MuscleFirstOrderActivationDynamicModel(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_MuscleFirstOrderActivationDynamicModel__SWIG_1(swigCPtr, this), false);
  }

  public void set_MuscleFirstOrderActivationDynamicModel(MuscleFirstOrderActivationDynamicModel value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_MuscleFirstOrderActivationDynamicModel__SWIG_1(swigCPtr, this, MuscleFirstOrderActivationDynamicModel.getCPtr(value), value);
  }

  public void copyProperty_ActiveForceLengthCurve(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_ActiveForceLengthCurve(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public ActiveForceLengthCurve get_ActiveForceLengthCurve(int i) {
    return new ActiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_ActiveForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public ActiveForceLengthCurve upd_ActiveForceLengthCurve(int i) {
    return new ActiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_ActiveForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_ActiveForceLengthCurve(int i, ActiveForceLengthCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_ActiveForceLengthCurve__SWIG_0(swigCPtr, this, i, ActiveForceLengthCurve.getCPtr(value), value);
  }

  public int append_ActiveForceLengthCurve(ActiveForceLengthCurve value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_ActiveForceLengthCurve(swigCPtr, this, ActiveForceLengthCurve.getCPtr(value), value);
  }

  public void constructProperty_ActiveForceLengthCurve(ActiveForceLengthCurve initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_ActiveForceLengthCurve(swigCPtr, this, ActiveForceLengthCurve.getCPtr(initValue), initValue);
  }

  public ActiveForceLengthCurve get_ActiveForceLengthCurve() {
    return new ActiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_ActiveForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public ActiveForceLengthCurve upd_ActiveForceLengthCurve() {
    return new ActiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_ActiveForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_ActiveForceLengthCurve(ActiveForceLengthCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_ActiveForceLengthCurve__SWIG_1(swigCPtr, this, ActiveForceLengthCurve.getCPtr(value), value);
  }

  public void copyProperty_ForceVelocityCurve(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_ForceVelocityCurve(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public ForceVelocityCurve get_ForceVelocityCurve(int i) {
    return new ForceVelocityCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_ForceVelocityCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public ForceVelocityCurve upd_ForceVelocityCurve(int i) {
    return new ForceVelocityCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_ForceVelocityCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_ForceVelocityCurve(int i, ForceVelocityCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_ForceVelocityCurve__SWIG_0(swigCPtr, this, i, ForceVelocityCurve.getCPtr(value), value);
  }

  public int append_ForceVelocityCurve(ForceVelocityCurve value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_ForceVelocityCurve(swigCPtr, this, ForceVelocityCurve.getCPtr(value), value);
  }

  public void constructProperty_ForceVelocityCurve(ForceVelocityCurve initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_ForceVelocityCurve(swigCPtr, this, ForceVelocityCurve.getCPtr(initValue), initValue);
  }

  public ForceVelocityCurve get_ForceVelocityCurve() {
    return new ForceVelocityCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_ForceVelocityCurve__SWIG_1(swigCPtr, this), false);
  }

  public ForceVelocityCurve upd_ForceVelocityCurve() {
    return new ForceVelocityCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_ForceVelocityCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_ForceVelocityCurve(ForceVelocityCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_ForceVelocityCurve__SWIG_1(swigCPtr, this, ForceVelocityCurve.getCPtr(value), value);
  }

  public void copyProperty_FiberForceLengthCurve(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_FiberForceLengthCurve(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public FiberForceLengthCurve get_FiberForceLengthCurve(int i) {
    return new FiberForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_FiberForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public FiberForceLengthCurve upd_FiberForceLengthCurve(int i) {
    return new FiberForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_FiberForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_FiberForceLengthCurve(int i, FiberForceLengthCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_FiberForceLengthCurve__SWIG_0(swigCPtr, this, i, FiberForceLengthCurve.getCPtr(value), value);
  }

  public int append_FiberForceLengthCurve(FiberForceLengthCurve value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_FiberForceLengthCurve(swigCPtr, this, FiberForceLengthCurve.getCPtr(value), value);
  }

  public void constructProperty_FiberForceLengthCurve(FiberForceLengthCurve initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_FiberForceLengthCurve(swigCPtr, this, FiberForceLengthCurve.getCPtr(initValue), initValue);
  }

  public FiberForceLengthCurve get_FiberForceLengthCurve() {
    return new FiberForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_FiberForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public FiberForceLengthCurve upd_FiberForceLengthCurve() {
    return new FiberForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_FiberForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_FiberForceLengthCurve(FiberForceLengthCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_FiberForceLengthCurve__SWIG_1(swigCPtr, this, FiberForceLengthCurve.getCPtr(value), value);
  }

  public void copyProperty_TendonForceLengthCurve(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_TendonForceLengthCurve(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public TendonForceLengthCurve get_TendonForceLengthCurve(int i) {
    return new TendonForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_TendonForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public TendonForceLengthCurve upd_TendonForceLengthCurve(int i) {
    return new TendonForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_TendonForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_TendonForceLengthCurve(int i, TendonForceLengthCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_TendonForceLengthCurve__SWIG_0(swigCPtr, this, i, TendonForceLengthCurve.getCPtr(value), value);
  }

  public int append_TendonForceLengthCurve(TendonForceLengthCurve value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_TendonForceLengthCurve(swigCPtr, this, TendonForceLengthCurve.getCPtr(value), value);
  }

  public void constructProperty_TendonForceLengthCurve(TendonForceLengthCurve initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_TendonForceLengthCurve(swigCPtr, this, TendonForceLengthCurve.getCPtr(initValue), initValue);
  }

  public TendonForceLengthCurve get_TendonForceLengthCurve() {
    return new TendonForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_TendonForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public TendonForceLengthCurve upd_TendonForceLengthCurve() {
    return new TendonForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_TendonForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_TendonForceLengthCurve(TendonForceLengthCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_TendonForceLengthCurve__SWIG_1(swigCPtr, this, TendonForceLengthCurve.getCPtr(value), value);
  }

  public void copyProperty_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_FiberCompressiveForceLengthCurve(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public FiberCompressiveForceLengthCurve get_FiberCompressiveForceLengthCurve(int i) {
    return new FiberCompressiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_FiberCompressiveForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public FiberCompressiveForceLengthCurve upd_FiberCompressiveForceLengthCurve(int i) {
    return new FiberCompressiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_FiberCompressiveForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_FiberCompressiveForceLengthCurve(int i, FiberCompressiveForceLengthCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_FiberCompressiveForceLengthCurve__SWIG_0(swigCPtr, this, i, FiberCompressiveForceLengthCurve.getCPtr(value), value);
  }

  public int append_FiberCompressiveForceLengthCurve(FiberCompressiveForceLengthCurve value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_FiberCompressiveForceLengthCurve(swigCPtr, this, FiberCompressiveForceLengthCurve.getCPtr(value), value);
  }

  public void constructProperty_FiberCompressiveForceLengthCurve(FiberCompressiveForceLengthCurve initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_FiberCompressiveForceLengthCurve(swigCPtr, this, FiberCompressiveForceLengthCurve.getCPtr(initValue), initValue);
  }

  public FiberCompressiveForceLengthCurve get_FiberCompressiveForceLengthCurve() {
    return new FiberCompressiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_FiberCompressiveForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public FiberCompressiveForceLengthCurve upd_FiberCompressiveForceLengthCurve() {
    return new FiberCompressiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_FiberCompressiveForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_FiberCompressiveForceLengthCurve(FiberCompressiveForceLengthCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_FiberCompressiveForceLengthCurve__SWIG_1(swigCPtr, this, FiberCompressiveForceLengthCurve.getCPtr(value), value);
  }

  public void copyProperty_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_FiberCompressiveForceCosPennationCurve(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public FiberCompressiveForceCosPennationCurve get_FiberCompressiveForceCosPennationCurve(int i) {
    return new FiberCompressiveForceCosPennationCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_FiberCompressiveForceCosPennationCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public FiberCompressiveForceCosPennationCurve upd_FiberCompressiveForceCosPennationCurve(int i) {
    return new FiberCompressiveForceCosPennationCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_FiberCompressiveForceCosPennationCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_FiberCompressiveForceCosPennationCurve(int i, FiberCompressiveForceCosPennationCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_FiberCompressiveForceCosPennationCurve__SWIG_0(swigCPtr, this, i, FiberCompressiveForceCosPennationCurve.getCPtr(value), value);
  }

  public int append_FiberCompressiveForceCosPennationCurve(FiberCompressiveForceCosPennationCurve value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_FiberCompressiveForceCosPennationCurve(swigCPtr, this, FiberCompressiveForceCosPennationCurve.getCPtr(value), value);
  }

  public void constructProperty_FiberCompressiveForceCosPennationCurve(FiberCompressiveForceCosPennationCurve initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_FiberCompressiveForceCosPennationCurve(swigCPtr, this, FiberCompressiveForceCosPennationCurve.getCPtr(initValue), initValue);
  }

  public FiberCompressiveForceCosPennationCurve get_FiberCompressiveForceCosPennationCurve() {
    return new FiberCompressiveForceCosPennationCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_FiberCompressiveForceCosPennationCurve__SWIG_1(swigCPtr, this), false);
  }

  public FiberCompressiveForceCosPennationCurve upd_FiberCompressiveForceCosPennationCurve() {
    return new FiberCompressiveForceCosPennationCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_FiberCompressiveForceCosPennationCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_FiberCompressiveForceCosPennationCurve(FiberCompressiveForceCosPennationCurve value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_FiberCompressiveForceCosPennationCurve__SWIG_1(swigCPtr, this, FiberCompressiveForceCosPennationCurve.getCPtr(value), value);
  }

  public void copyProperty_fiber_damping(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_fiber_damping(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_fiber_damping(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_fiber_damping__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_fiber_damping(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_fiber_damping__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_fiber_damping(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_fiber_damping__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_fiber_damping(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_fiber_damping(swigCPtr, this, value);
  }

  public void constructProperty_fiber_damping(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_fiber_damping(swigCPtr, this, initValue);
  }

  public double get_fiber_damping() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_fiber_damping__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_fiber_damping() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_fiber_damping__SWIG_1(swigCPtr, this), false);
  }

  public void set_fiber_damping(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_fiber_damping__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_fiber_force_length_damping(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_fiber_force_length_damping(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_fiber_force_length_damping(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_fiber_force_length_damping__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_fiber_force_length_damping(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_fiber_force_length_damping__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_fiber_force_length_damping(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_fiber_force_length_damping__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_fiber_force_length_damping(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_fiber_force_length_damping(swigCPtr, this, value);
  }

  public void constructProperty_fiber_force_length_damping(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_fiber_force_length_damping(swigCPtr, this, initValue);
  }

  public double get_fiber_force_length_damping() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_fiber_force_length_damping__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_fiber_force_length_damping() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_fiber_force_length_damping__SWIG_1(swigCPtr, this), false);
  }

  public void set_fiber_force_length_damping(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_fiber_force_length_damping__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_fiber_compressive_force_length_damping(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_fiber_compressive_force_length_damping(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_fiber_compressive_force_length_damping__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_fiber_compressive_force_length_damping(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_fiber_compressive_force_length_damping__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_fiber_compressive_force_length_damping(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_fiber_compressive_force_length_damping__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_fiber_compressive_force_length_damping(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_fiber_compressive_force_length_damping(swigCPtr, this, value);
  }

  public void constructProperty_fiber_compressive_force_length_damping(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_fiber_compressive_force_length_damping(swigCPtr, this, initValue);
  }

  public double get_fiber_compressive_force_length_damping() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_fiber_compressive_force_length_damping__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_fiber_compressive_force_length_damping() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_fiber_compressive_force_length_damping__SWIG_1(swigCPtr, this), false);
  }

  public void set_fiber_compressive_force_length_damping(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_fiber_compressive_force_length_damping__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_fiber_compressive_force_cos_pennation_damping(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_fiber_compressive_force_cos_pennation_damping(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_fiber_compressive_force_cos_pennation_damping__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_fiber_compressive_force_cos_pennation_damping(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_fiber_compressive_force_cos_pennation_damping__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_fiber_compressive_force_cos_pennation_damping(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_fiber_compressive_force_cos_pennation_damping__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_fiber_compressive_force_cos_pennation_damping(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_fiber_compressive_force_cos_pennation_damping(swigCPtr, this, value);
  }

  public void constructProperty_fiber_compressive_force_cos_pennation_damping(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_fiber_compressive_force_cos_pennation_damping(swigCPtr, this, initValue);
  }

  public double get_fiber_compressive_force_cos_pennation_damping() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_fiber_compressive_force_cos_pennation_damping__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_fiber_compressive_force_cos_pennation_damping() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_fiber_compressive_force_cos_pennation_damping__SWIG_1(swigCPtr, this), false);
  }

  public void set_fiber_compressive_force_cos_pennation_damping(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_fiber_compressive_force_cos_pennation_damping__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_tendon_force_length_damping(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_tendon_force_length_damping(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_tendon_force_length_damping(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_tendon_force_length_damping__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_tendon_force_length_damping(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_tendon_force_length_damping__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_tendon_force_length_damping(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_tendon_force_length_damping__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_tendon_force_length_damping(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_tendon_force_length_damping(swigCPtr, this, value);
  }

  public void constructProperty_tendon_force_length_damping(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_tendon_force_length_damping(swigCPtr, this, initValue);
  }

  public double get_tendon_force_length_damping() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_tendon_force_length_damping__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_tendon_force_length_damping() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_tendon_force_length_damping__SWIG_1(swigCPtr, this), false);
  }

  public void set_tendon_force_length_damping(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_tendon_force_length_damping__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_mass(Millard2012AccelerationMuscle source) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_copyProperty_mass(swigCPtr, this, Millard2012AccelerationMuscle.getCPtr(source), source);
  }

  public double get_mass(int i) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_mass__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_mass(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_mass__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_mass(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_mass__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_mass(double value) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_append_mass(swigCPtr, this, value);
  }

  public void constructProperty_mass(double initValue) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_constructProperty_mass(swigCPtr, this, initValue);
  }

  public double get_mass() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_get_mass__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_mass() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_upd_mass__SWIG_1(swigCPtr, this), false);
  }

  public void set_mass(double value) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_set_mass__SWIG_1(swigCPtr, this, value);
  }

  /**
   * Default constructor: produces a non-functional empty muscle
   */
  public Millard2012AccelerationMuscle() {
    this(opensimActuatorsAnalysesToolsJNI.new_Millard2012AccelerationMuscle__SWIG_0(), true);
  }

  /**
   * Constructs a functional muscle using all of the default curves and<br>
   *        activation model.<br>
   * <br>
   *        @param aName The name of the muscle.<br>
   * <br>
   *        @param aMaxIsometricForce <br>
   *         The force generated by the muscle when it at its optimal resting length,<br>
   *         has a contraction velocity of zero, and is fully activated <br>
   *         (Newtons).<br>
   * <br>
   *        @param aOptimalFiberLength<br>
   *         The optimal length of the muscle fiber (meters).<br>
   * <br>
   *        @param aTendonSlackLength<br>
   *         The resting length of the tendon (meters).<br>
   * <br>
   *        @param aPennationAngle<br>
   *         The angle of the fiber relative to the tendon when the fiber is at its<br>
   *         optimal resting length (radians).
   */
  public Millard2012AccelerationMuscle(String aName, double aMaxIsometricForce, double aOptimalFiberLength, double aTendonSlackLength, double aPennationAngle) {
    this(opensimActuatorsAnalysesToolsJNI.new_Millard2012AccelerationMuscle__SWIG_1(aName, aMaxIsometricForce, aOptimalFiberLength, aTendonSlackLength, aPennationAngle), true);
  }

  /**
   *    @param s the state of the system<br>
   *    @return the normalized force term associated with the compressive force length<br>
   *           element,  \mathbf{f}_K(\hat{l}_{CE}), in the equilibrium equation
   */
  public double getFiberCompressiveForceLengthMultiplier(State s) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getFiberCompressiveForceLengthMultiplier(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *    @param s the state of the system<br>
   *    @return the normalized force term associated with the compressive force <br>
   *            cosine pennation element,  \mathbf{f}_{c\phi}(\cos \phi), in the <br>
   *            equilibrium equation
   */
  public double getFiberCompressiveForceCosPennationMultiplier(State s) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getFiberCompressiveForceCosPennationMultiplier(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *    @param s the state of the system<br>
   *    @return the normalized force term associated with tendon element,<br>
   *              \mathbf{f}_{SE}(\hat{l}_{T}), in the equilibrium equation 
   */
  public double getTendonForceMultiplier(State s) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getTendonForceMultiplier(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *    @return the size of the mass between the tendon and fiber
   */
  public double getMass() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getMass(swigCPtr, this);
  }

  /**
   *    @return the MuscleFirstOrderActivationDynamicModel <br>
   *             that this muscle model uses
   */
  public MuscleFirstOrderActivationDynamicModel getActivationModel() {
    return new MuscleFirstOrderActivationDynamicModel(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getActivationModel(swigCPtr, this), false);
  }

  /**
   *    @return the MuscleFixedWidthPennationModel <br>
   *             that this muscle model uses
   */
  public MuscleFixedWidthPennationModel getPennationModel() {
    return new MuscleFixedWidthPennationModel(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getPennationModel(swigCPtr, this), false);
  }

  /**
   *     @return the ActiveForceLengthCurve that this muscle model uses
   */
  public ActiveForceLengthCurve getActiveForceLengthCurve() {
    return new ActiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getActiveForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *     @return the ForceVelocityInverseCurve that this muscle model uses
   */
  public ForceVelocityCurve getForceVelocityCurve() {
    return new ForceVelocityCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getForceVelocityCurve(swigCPtr, this), false);
  }

  /**
   *     @return the FiberForceLengthCurve that this muscle model uses
   */
  public FiberForceLengthCurve getFiberForceLengthCurve() {
    return new FiberForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getFiberForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *     @return the TendonForceLengthCurve that this muscle model uses
   */
  public TendonForceLengthCurve getTendonForceLengthCurve() {
    return new TendonForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getTendonForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *     @return the FiberCompressiveForceLengthCurve that this muscle model uses
   */
  public FiberCompressiveForceLengthCurve getFiberCompressiveForceLengthCurve() {
    return new FiberCompressiveForceLengthCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getFiberCompressiveForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *     @return the FiberCompressiveForceCosPennationCurve that this muscle <br>
   *              model uses.
   */
  public FiberCompressiveForceCosPennationCurve getFiberCompressiveForceCosPennationCurve() {
    return new FiberCompressiveForceCosPennationCurve(opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getFiberCompressiveForceCosPennationCurve(swigCPtr, this), false);
  }

  /**
   *     @return the stiffness of the muscle fibers along the tendon (N/m)
   */
  public double getFiberStiffnessAlongTendon(State s) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getFiberStiffnessAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *     @param aActivationMdl the MuscleFirstOrderActivationDynamicModel that this<br>
   *                           muscle model uses to simulate activation dynamics
   */
  public void setActivationModel(MuscleFirstOrderActivationDynamicModel aActivationMdl) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setActivationModel(swigCPtr, this, MuscleFirstOrderActivationDynamicModel.getCPtr(aActivationMdl), aActivationMdl);
  }

  /**
   *     @param aActiveForceLengthCurve the ActiveForceLengthCurve that this muscle<br>
   *                             model uses to scale active fiber force as a function<br>
   *                             of length
   */
  public void setActiveForceLengthCurve(ActiveForceLengthCurve aActiveForceLengthCurve) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setActiveForceLengthCurve(swigCPtr, this, ActiveForceLengthCurve.getCPtr(aActiveForceLengthCurve), aActiveForceLengthCurve);
  }

  /**
   *     @param aForceVelocityCurve the ForceVelocityCurve that this<br>
   *                             muscle model uses to calculate the derivative of<br>
   *                             fiber length.
   */
  public void setForceVelocityCurve(ForceVelocityCurve aForceVelocityCurve) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setForceVelocityCurve(swigCPtr, this, ForceVelocityCurve.getCPtr(aForceVelocityCurve), aForceVelocityCurve);
  }

  /**
   *     @param aFiberForceLengthCurve the FiberForceLengthCurve that this muscle <br>
   *                             model uses to calculate the passive force the muscle<br>
   *                             fiber generates as the length of the fiber changes
   */
  public void setFiberForceLengthCurve(FiberForceLengthCurve aFiberForceLengthCurve) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setFiberForceLengthCurve(swigCPtr, this, FiberForceLengthCurve.getCPtr(aFiberForceLengthCurve), aFiberForceLengthCurve);
  }

  /**
   *     @param aTendonForceLengthCurve the TendonForceLengthCurve that this muscle<br>
   *                             model uses to define the tendon force length curve
   */
  public void setTendonForceLengthCurve(TendonForceLengthCurve aTendonForceLengthCurve) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setTendonForceLengthCurve(swigCPtr, this, TendonForceLengthCurve.getCPtr(aTendonForceLengthCurve), aTendonForceLengthCurve);
  }

  /**
   *     @param aFiberCompressiveForceLengthCurve the <br>
   *             FiberCompressiveForceLengthCurve that this muscle model uses to <br>
   *             ensure the length of the fiber is always greater than a physically<br>
   *             realistic lower bound.
   */
  public void setFiberCompressiveForceLengthCurve(FiberCompressiveForceLengthCurve aFiberCompressiveForceLengthCurve) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setFiberCompressiveForceLengthCurve(swigCPtr, this, FiberCompressiveForceLengthCurve.getCPtr(aFiberCompressiveForceLengthCurve), aFiberCompressiveForceLengthCurve);
  }

  /**
   *     @param aFiberCompressiveForceCosPennationCurve the<br>
   *             FiberCompressiveForceCosPennationCurve that this muscle model uses<br>
   *             to prevent pennation angles from approaching 90 degrees, which is<br>
   *             associated with a singularity in this model.
   */
  public void setFiberCompressiveForceCosPennationCurve(FiberCompressiveForceCosPennationCurve aFiberCompressiveForceCosPennationCurve) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setFiberCompressiveForceCosPennationCurve(swigCPtr, this, FiberCompressiveForceCosPennationCurve.getCPtr(aFiberCompressiveForceCosPennationCurve), aFiberCompressiveForceCosPennationCurve);
  }

  /**
   *     @param mass<br>
   *             The size of the mass parameter between the fiber and the tendon. <br>
   *             Making this parameter small will make the muscle model more rapidly<br>
   *             converge to the results an equilibrium model would produce.<br>
   * <br>
   *     <b>Conditions</b><br>
   *     {@literal 
          mass >= 0.001
      }
   */
  public void setMass(double mass) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setMass(swigCPtr, this, mass);
  }

  /**
   *     @return the default activation level that is used as an initial condition<br>
   *              if none is provided by the user.
   */
  public double getDefaultActivation() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getDefaultActivation(swigCPtr, this);
  }

  /**
   *     @return the default fiber length that is used as an initial condition<br>
   *              if none is provided by the user.
   */
  public double getDefaultFiberLength() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getDefaultFiberLength(swigCPtr, this);
  }

  /**
   *     @return the default fiber velocity that is used as an initial condition<br>
   *              if none is provided by the user.
   */
  public double getDefaultFiberVelocity() {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getDefaultFiberVelocity(swigCPtr, this);
  }

  /**
   *     @param s The state of the system<br>
   *     @return the time derivative of activation
   */
  public double getActivationRate(State s) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getActivationRate(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *     @param s The state of the system<br>
   *     @return the velocity of the fiber (m/s)
   */
  public double getFiberVelocity(State s) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getFiberVelocity(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *     @param s The state of the system<br>
   *     @return the acceleration of the fiber (m/s)
   */
  public double getFiberAcceleration(State s) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_getFiberAcceleration(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *     @param activation the default activation level that is used to initialize<br>
   *            the muscle
   */
  public void setDefaultActivation(double activation) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setDefaultActivation(swigCPtr, this, activation);
  }

  /**
   *     @param fiberLength the default fiber length that is used to initialize<br>
   *            the muscle
   */
  public void setDefaultFiberLength(double fiberLength) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setDefaultFiberLength(swigCPtr, this, fiberLength);
  }

  /**
   *     @param fiberVelocity the default fiber velocity that is used to initialize<br>
   *            the muscle
   */
  public void setDefaultFiberVelocity(double fiberVelocity) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setDefaultFiberVelocity(swigCPtr, this, fiberVelocity);
  }

  /**
   *     @param s the state of the system<br>
   *     @param activation the desired activation level
   */
  public void setActivation(State s, double activation) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setActivation(swigCPtr, this, State.getCPtr(s), s, activation);
  }

  /**
   *     @param s the state of the system<br>
   *     @param fiberLength the desired fiber length (m)
   */
  public void setFiberLength(State s, double fiberLength) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setFiberLength(swigCPtr, this, State.getCPtr(s), s, fiberLength);
  }

  /**
   *     @param s the state of the system<br>
   *     @param fiberVelocity the desired fiber velocity (m/s)
   */
  public void setFiberVelocity(State s, double fiberVelocity) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_setFiberVelocity(swigCPtr, this, State.getCPtr(s), s, fiberVelocity);
  }

  /**
   *     @param s the state of the system<br>
   *     @return the tensile force the muscle is generating in N
   */
  public double computeActuation(State s) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_computeActuation(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  This function computes the fiber length such that muscle fiber and <br>
   *         tendon are developing the same force, and so that the velocity of<br>
   *         the entire muscle-tendon is spread between the fiber and the tendon<br>
   *         according to their relative compliances.<br>
   * <br>
   *         @param s the state of the system<br>
   *         @throws MuscleCannotEquilibrate
   */
  public void computeInitialFiberEquilibrium(State s) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_computeInitialFiberEquilibrium(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   * Conditional comment: DEPRECATED
   */
  public double calcInextensibleTendonActiveFiberForce(State s, double aActivation) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_calcInextensibleTendonActiveFiberForce(swigCPtr, this, State.getCPtr(s), s, aActivation);
  }

  public double calcActiveFiberForceAlongTendon(double activation, double fiberLength, double fiberVelocity) {
    return opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_calcActiveFiberForceAlongTendon(swigCPtr, this, activation, fiberLength, fiberVelocity);
  }

  /**
   * End of conditional comment. Adjust the properties of the muscle after the model has been scaled. The<br>
   *         optimal fiber length and tendon slack length are each multiplied by the<br>
   *         ratio of the current path length and the path length before scaling. 
   */
  public void extendPostScale(State s, ScaleSet scaleSet) {
    opensimActuatorsAnalysesToolsJNI.Millard2012AccelerationMuscle_extendPostScale(swigCPtr, this, State.getCPtr(s), s, ScaleSet.getCPtr(scaleSet), scaleSet);
  }

}
