/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  The squared difference between a model frame origin's linear acceleration<br>
 * and a reference acceleration value, summed over the frames for which a<br>
 * reference is provided, and integrated over the phase. The reference is<br>
 * a trajectory of SimTK::Vec3%s representing the acceleration reference data.<br>
 * You must provide either a file name to a STO or CSV file (or other file<br>
 * types for which there is a FileAdapter) using setAccelerationReferenceFile() or<br>
 * a TimeSeriesTableVec3 directly using setAccelerationReference(). The model frames<br>
 * that track the acceleration reference data, or "tracking" frames, are specified<br>
 * using setFramePaths().<br>
 * <br>
 * <br>
 * <br>
 * <br>
 * By default, errors for this cost are computed assuming that the provided<br>
 * reference acceleration data is the derivative of a position vector with respect<br>
 * to the ground frame and expressed in the ground frame.<br>
 * <br>
 * <br>
 * <br>
 * If using this cost for tracking acceleration signals from an inertial measurement<br>
 * unit (IMU), you must subtract the gravity vector from the model accelerations and<br>
 * express them in the tracking frames using setGravityOffset() and<br>
 * setExpressAccelerationsInTrackingFrames(). In addition, the tracking frames for<br>
 * each IMU must be in the same location and orientation in the model as in your<br>
 * experiment. Therefore, it is recommended to add new frames to your model that<br>
 * represent the experimental IMU sensors when using these settings.<br>
 * <br>
 * This cost requires realization to SimTK::Stage::Acceleration.<br>
 * <br>
 * 
 */
public class MocoAccelerationTrackingGoal extends MocoGoal {
  private transient long swigCPtr;

  public MocoAccelerationTrackingGoal(long cPtr, boolean cMemoryOwn) {
    super(opensimMocoJNI.MocoAccelerationTrackingGoal_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(MocoAccelerationTrackingGoal obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(MocoAccelerationTrackingGoal obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimMocoJNI.delete_MocoAccelerationTrackingGoal(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static MocoAccelerationTrackingGoal safeDownCast(OpenSimObject obj) {
    long cPtr = opensimMocoJNI.MocoAccelerationTrackingGoal_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new MocoAccelerationTrackingGoal(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimMocoJNI.MocoAccelerationTrackingGoal_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimMocoJNI.MocoAccelerationTrackingGoal_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimMocoJNI.MocoAccelerationTrackingGoal_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new MocoAccelerationTrackingGoal(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimMocoJNI.MocoAccelerationTrackingGoal_getConcreteClassName(swigCPtr, this);
  }

  public MocoAccelerationTrackingGoal() {
    this(opensimMocoJNI.new_MocoAccelerationTrackingGoal__SWIG_0(), true);
  }

  public MocoAccelerationTrackingGoal(String name) {
    this(opensimMocoJNI.new_MocoAccelerationTrackingGoal__SWIG_1(name), true);
  }

  public MocoAccelerationTrackingGoal(String name, double weight) {
    this(opensimMocoJNI.new_MocoAccelerationTrackingGoal__SWIG_2(name, weight), true);
  }

  /**
   *  Set the acceleration of individual frames in ground to be tracked in the<br>
   *     cost. The column labels of the provided reference must be paths to<br>
   *     frames in the model, e.g. `/bodyset/torso`. If the frame_paths property<br>
   *     is empty, all frames with data in this reference will be tracked.<br>
   *     Otherwise, only the frames specified via setFramePaths() will be<br>
   *     tracked. Calling this function clears the table set by<br>
   *     setAccelerationReference() if it exists. 
   */
  public void setAccelerationReferenceFile(String filepath) {
    opensimMocoJNI.MocoAccelerationTrackingGoal_setAccelerationReferenceFile(swigCPtr, this, filepath);
  }

  /**
   *  Each column label must be the path of a valid frame path (see<br>
   *     setAccelerationReferenceFile()). Calling this function clears the<br>
   *     `acceleration_reference_file` property. 
   */
  public void setAccelerationReference(TimeSeriesTableVec3 ref) {
    opensimMocoJNI.MocoAccelerationTrackingGoal_setAccelerationReference(swigCPtr, this, TimeSeriesTableVec3.getCPtr(ref), ref);
  }

  /**
   *  Set the paths to frames in the model that this cost term will track. The<br>
   *     names set here must correspond to OpenSim::Component%s that derive from<br>
   *     OpenSim::Frame, which includes 'linear_acceleration' (SimTK::Vec3) as an<br>
   *     output. Replaces the frame path set if it already exists. 
   */
  public void setFramePaths(StdVectorString paths) {
    opensimMocoJNI.MocoAccelerationTrackingGoal_setFramePaths(swigCPtr, this, StdVectorString.getCPtr(paths), paths);
  }

  /**
   *  Set the weight for an individual frame's acceleration tracking. If a<br>
   *     weight is already set for the requested frame, then the provided weight<br>
   *     replaces the previous weight. An exception is thrown if a weight<br>
   *     for an unknown frame is provided. 
   */
  public void setWeightForFrame(String frameName, double weight) {
    opensimMocoJNI.MocoAccelerationTrackingGoal_setWeightForFrame(swigCPtr, this, frameName, weight);
  }

  /**
   *  Provide a MocoWeightSet to weight frame acceleration tracking in the<br>
   *     cost. Replaces the weight set if it already exists. 
   */
  public void setWeightSet(MocoWeightSet weightSet) {
    opensimMocoJNI.MocoAccelerationTrackingGoal_setWeightSet(swigCPtr, this, MocoWeightSet.getCPtr(weightSet), weightSet);
  }

  /**
   *  If no acceleration reference file has been provided, this returns an<br>
   *     empty string. 
   */
  public String getAccelerationReferenceFile() {
    return opensimMocoJNI.MocoAccelerationTrackingGoal_getAccelerationReferenceFile(swigCPtr, this);
  }

  /**
   *  Subtract the model's gravity vector from the model-generated<br>
   *     accelerations. This offset is performed while the model accelerations are<br>
   *     expressed in the ground frame, before the accelerations are expressed in the<br>
   *     tracking frames when setExpressAccelerationsInTrackingFrames() is set to<br>
   *     true. This setting is useful when tracking accelerations recorded from<br>
   *     inertial measurement units. 
   */
  public void setGravityOffset(boolean tf) {
    opensimMocoJNI.MocoAccelerationTrackingGoal_setGravityOffset(swigCPtr, this, tf);
  }

  public boolean getGravityOffset() {
    return opensimMocoJNI.MocoAccelerationTrackingGoal_getGravityOffset(swigCPtr, this);
  }

  /**
   *  Express the model-generated accelerations in the individual model<br>
   *     tracking frames specified by the 'frame_paths' property. Accelerations are<br>
   *     expressed after the gravity offset is applied when setGravityOffset() is set<br>
   *     to true. This setting is useful when tracking accelerations recorded from<br>
   *     inertial measurement units. 
   */
  public void setExpressAccelerationsInTrackingFrames(boolean tf) {
    opensimMocoJNI.MocoAccelerationTrackingGoal_setExpressAccelerationsInTrackingFrames(swigCPtr, this, tf);
  }

  public boolean getExpressAccelerationsInTrackingFrames() {
    return opensimMocoJNI.MocoAccelerationTrackingGoal_getExpressAccelerationsInTrackingFrames(swigCPtr, this);
  }

}
