/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

public class SimTKVisualizerInputSilo extends SimTKVisualizerInputListener {
  private transient long swigCPtr;

  public SimTKVisualizerInputSilo(long cPtr, boolean cMemoryOwn) {
    super(opensimSimbodyJNI.SimTKVisualizerInputSilo_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(SimTKVisualizerInputSilo obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimbodyJNI.delete_SimTKVisualizerInputSilo(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  /**
   *  Default construction is all that is needed; there are no options. *
   */
  public SimTKVisualizerInputSilo() {
    this(opensimSimbodyJNI.new_SimTKVisualizerInputSilo(), true);
  }

  /**
   *  This is a very fast test that does not require locking; you don't have to <br>
   * use this but it is a good idea to do so. *
   */
  public boolean isAnyUserInput() {
    return opensimSimbodyJNI.SimTKVisualizerInputSilo_isAnyUserInput(swigCPtr, this);
  }

  /**
   *  This will wait quietly until the user has provided some input to the<br>
   * visualizer.\ Any kind of input will terminate the wait; you'll have<br>
   * to look to see what it was. *
   */
  public void waitForAnyUserInput() {
    opensimSimbodyJNI.SimTKVisualizerInputSilo_waitForAnyUserInput(swigCPtr, this);
  }

  /**
   *  This will return user key hits until they have all been consumed, in the <br>
   * same order they were received. The <i>key</i> and <i>modifiers</i> values are those that<br>
   * were provided to our implementation of the InputListener::keyPressed() method. <br>
   * @param key         <br>
   *     The key code for the key that was hit. See InputListener::KeyCode for<br>
   *     interpretation.<br>
   * @param modifiers    <br>
   *     Status of Shift,Ctrl,Alt and "special" key code. See InputListener::Modifier<br>
   *     for interpretation. <br>
   * @return <code>true</code> if a key and modifiers have been returned; <code>false</code> if the <br>
   *     character silo is now empty in which case both <i>key</i> and <i>modifiers</i> will<br>
   *     be set to zero. *
   */
  public boolean takeKeyHit(SWIGTYPE_p_unsigned_int key, SWIGTYPE_p_unsigned_int modifiers) {
    return opensimSimbodyJNI.SimTKVisualizerInputSilo_takeKeyHit(swigCPtr, this, SWIGTYPE_p_unsigned_int.getCPtr(key), SWIGTYPE_p_unsigned_int.getCPtr(modifiers));
  }

  /**
   *  Same as takeKeyHit() except that if there is no key hit input available<br>
   * it waits until there is, then returns the first one (which is removed from<br>
   * the silo just as takeKeyHit() would do. The behavior is like calling<br>
   * waitForAnyUserInput() repeatedly until takeKeyHit() returns <code>true</code>.<br>
   * @see takeKeyHit(), waitForAnyUserInput() *
   */
  public void waitForKeyHit(SWIGTYPE_p_unsigned_int key, SWIGTYPE_p_unsigned_int modifiers) {
    opensimSimbodyJNI.SimTKVisualizerInputSilo_waitForKeyHit(swigCPtr, this, SWIGTYPE_p_unsigned_int.getCPtr(key), SWIGTYPE_p_unsigned_int.getCPtr(modifiers));
  }

  /**
   *  This will return user menu picks until they have all been consumed, in the<br>
   * same order they were received. The <i>item</i> value returned is the value that was<br>
   * provided to our implementation of the InputListener::menuSelected() method. <br>
   * @param menu         <br>
   *     The id number of the menu that was selected. This is the value that was<br>
   *     assigned to this menu in the Visualizer::addMenu() call.<br>
   * @param item         <br>
   *     The menu item number for the entry that the user selected. This is the <br>
   *     number that was assigned at the time the menu was added via the <br>
   *     Visualizer::addMenu() method.<br>
   * @return <code>true</code> if a menu item number has been returned; <code>false</code> if the menu <br>
   *     pick silo is now empty in which case <i>item</i> will be set to zero. *
   */
  public boolean takeMenuPick(SWIGTYPE_p_int menu, SWIGTYPE_p_int item) {
    return opensimSimbodyJNI.SimTKVisualizerInputSilo_takeMenuPick(swigCPtr, this, SWIGTYPE_p_int.getCPtr(menu), SWIGTYPE_p_int.getCPtr(item));
  }

  /**
   *  Same as takeMenuPick() except that if there is no menu pick input available<br>
   * it waits until there is, then returns the first one (which is removed from<br>
   * the silo just as takeMenuPick() would do. The behavior is like calling<br>
   * waitForAnyUserInput() repeatedly until takeMenuPick() returns <code>true</code>.<br>
   * @see takeMenuPick(), waitForAnyUserInput() *
   */
  public void waitForMenuPick(SWIGTYPE_p_int menu, SWIGTYPE_p_int item) {
    opensimSimbodyJNI.SimTKVisualizerInputSilo_waitForMenuPick(swigCPtr, this, SWIGTYPE_p_int.getCPtr(menu), SWIGTYPE_p_int.getCPtr(item));
  }

  /**
   *  This will return user changes to slider positions until they have all been<br>
   * consumed, in the same order they were received. The <i>slider</i> and <i>value</i> <br>
   * returns are those that were provided to our implementation of the <br>
   * InputListener::sliderMoved() method. <br>
   * @param slider         <br>
   *     The id number of the slider that was moved. This is the value that was<br>
   *     assigned to this slider in the Visualizer::addSlider() call.<br>
   * @param value    <br>
   *     This is the new value associated with the slider position to which the user<br>
   *     moved it.<br>
   * @return <code>true</code> if a slider move has been returned; <code>false</code> if the slider move<br>
   *     silo is now empty in which case <i>which</i> will be set to zero and <i>value</i> <br>
   *     will be NaN. *
   */
  public boolean takeSliderMove(SWIGTYPE_p_int slider, SWIGTYPE_p_double value) {
    return opensimSimbodyJNI.SimTKVisualizerInputSilo_takeSliderMove(swigCPtr, this, SWIGTYPE_p_int.getCPtr(slider), SWIGTYPE_p_double.getCPtr(value));
  }

  /**
   *  Same as takeSliderMove() except that if there is no slider move input <br>
   * available it waits until there is, then returns the first one (which is removed<br>
   * from the silo just as takeSliderMove() would do. The behavior is like calling<br>
   * waitForAnyUserInput() repeatedly until takeSliderMove() returns <code>true</code>.<br>
   * @see takeSliderMove(), waitForAnyUserInput() *
   */
  public void waitForSliderMove(SWIGTYPE_p_int slider, SWIGTYPE_p_double value) {
    opensimSimbodyJNI.SimTKVisualizerInputSilo_waitForSliderMove(swigCPtr, this, SWIGTYPE_p_int.getCPtr(slider), SWIGTYPE_p_double.getCPtr(value));
  }

  /**
   *  Throw away any pending unprocessed input of all types. *
   */
  public void clear() {
    opensimSimbodyJNI.SimTKVisualizerInputSilo_clear(swigCPtr, this);
  }

  public long takeKeyHitKeyOnly() {
    return opensimSimbodyJNI.SimTKVisualizerInputSilo_takeKeyHitKeyOnly(swigCPtr, this);
  }

}
