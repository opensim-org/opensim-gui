/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  A CoordinateDirection is a CoordinateAxis plus a direction indicating the <br>
 * positive or negative direction along that axis. There are only six possible <br>
 * values for a CoordinateDirection, and there are predefined constants available <br>
 * covering all of them:<br>
 *   - XAxis, YAxis, ZAxis are the CoordinateAxis types; they will implicitly <br>
 *     convert to positive axis directions.<br>
 *   - NegXAxis, NegYAxis, NegZAxis are the negative directions.<br>
 *   - The unary negation operator is overloaded so that -XAxis produces<br>
 *     NegXAxis and -NegYAxis produces YAxis.<br>
 *   - The unary plus operator is overloaded for the CoordinateAxis objects<br>
 *     so that +XAxis and so on are the positive CoordinateDirection objects.<br>
 * You can also produce CoordinateDirections at compile time or run time from<br>
 * calculated axes and directions. <br>
 * @see CoordinateAxis *
 */
public class CoordinateDirection {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public CoordinateDirection(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(CoordinateDirection obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(CoordinateDirection obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimbodyJNI.delete_CoordinateDirection(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Use for compile-time construction of a negative CoordinateDirection<br>
   *     along one of the coordinate axes. *
   */
  static public class Negative {
    private transient long swigCPtr;
    protected transient boolean swigCMemOwn;
  
    public Negative(long cPtr, boolean cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = cPtr;
    }
  
    public static long getCPtr(Negative obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    public static long swigRelease(Negative obj) {
      long ptr = 0;
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new RuntimeException("Cannot release ownership as memory is not owned");
        ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.delete();
      }
      return ptr;
    }
  
    @SuppressWarnings("deprecation")
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          opensimSimbodyJNI.delete_CoordinateDirection_Negative(swigCPtr);
        }
        swigCPtr = 0;
      }
    }
  
    public Negative() {
      this(opensimSimbodyJNI.new_CoordinateDirection_Negative(), true);
    }
  
  }

  /**
   *  Implicit conversion of a CoordinateAxis to a positive <br>
   *     CoordinateDirection along that axis. *
   */
  public CoordinateDirection(CoordinateAxis axis) {
    this(opensimSimbodyJNI.new_CoordinateDirection__SWIG_0(CoordinateAxis.getCPtr(axis), axis), true);
  }

  /**
   *  Explicit creation of a CoordinateDirection from a CoordinateAxis<br>
   *     and a direction calculated at run time.<br>
   *     @param axis         XAxis, YAxis, or ZAxis<br>
   *     @param direction    Must be -1 or 1.<br>
   *     Note: Zero is not allowed for <i>direction</i>, meaning that<br>
   *     you must not try to produce one of these from the "sign" result of one of<br>
   *     the cross product methods, because there the sign can be -1, 0, or 1. *
   */
  public CoordinateDirection(CoordinateAxis axis, int direction) {
    this(opensimSimbodyJNI.new_CoordinateDirection__SWIG_1(CoordinateAxis.getCPtr(axis), axis, direction), true);
  }

  /**
   *  This is the coordinate axis XAxis, YAxis, or ZAxis contained in this<br>
   *     CoordinateDirection.\ Use getDirection() to determine whether this is the<br>
   *     positive or negative direction. *
   */
  public CoordinateAxis getAxis() {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateDirection_getAxis(swigCPtr, this), true);
  }

  /**
   *  Returns 1 or -1 to indicate the direction along the coordinate<br>
   *     axis returned by getAxis(). *
   */
  public int getDirection() {
    return opensimSimbodyJNI.CoordinateDirection_getDirection(swigCPtr, this);
  }

  /**
   *  Return true if this direction and <i>dir2</i> are along the same axis,<br>
   *     even if the direction along that axis is not the same. *
   */
  public boolean hasSameAxis(CoordinateDirection dir2) {
    return opensimSimbodyJNI.CoordinateDirection_hasSameAxis(swigCPtr, this, CoordinateDirection.getCPtr(dir2), dir2);
  }

  /**
   *  Return true if this direction and <i>dir2</i> are along the same axis,<br>
   *     and in the same direction along that axis.\ You can also<br>
   *     use operator==() for this comparison. *
   */
  public boolean isSameAxisAndDirection(CoordinateDirection dir2) {
    return opensimSimbodyJNI.CoordinateDirection_isSameAxisAndDirection(swigCPtr, this, CoordinateDirection.getCPtr(dir2), dir2);
  }

  /**
   *  Perform a specialized dot product between this coordinate direction<br>
   *     and <i>dir2;</i> returning 1 or -1 if they contain the same axis and 0 <br>
   *     otherwise, without performing any floating point operations. *
   */
  public int dotProduct(CoordinateDirection dir2) {
    return opensimSimbodyJNI.CoordinateDirection_dotProduct(swigCPtr, this, CoordinateDirection.getCPtr(dir2), dir2);
  }

  /**
   *  Return the sign that would result from a cross product between this <br>
   *     coordinate direction and <i>dir2</i>: 0 if they are along the same axis; <br>
   *     1 if the result would be in the positive direction along the third axis;<br>
   *     -1 if it would be in the negative direction. No floating point <br>
   *     computations are performed. @see crossProductAxis() *
   */
  public int crossProductSign(CoordinateDirection dir2) {
    return opensimSimbodyJNI.CoordinateDirection_crossProductSign(swigCPtr, this, CoordinateDirection.getCPtr(dir2), dir2);
  }

  /**
   *  Return the coordinate axis along which the cross product of this <br>
   *     coordinate direction and <i>dir2</i> would lie: same as this if both contain<br>
   *     the same axis (doesn't matter because the sign would be zero); otherwise,<br>
   *     the third axis that neither this one nor <i>dir2</i> contains. But note that<br>
   *     the actual result may be along that axis or in the negative direction <br>
   *     along that axis.  No floating point computations are performed. <br>
   *     @see crossProductSign(). *
   */
  public CoordinateAxis crossProductAxis(CoordinateDirection dir2) {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateDirection_crossProductAxis(swigCPtr, this, CoordinateDirection.getCPtr(dir2), dir2), true);
  }

  /**
   *  Return the axis and sign along that axis that would result from a<br>
   *     cross product between this coordinate direction and <i>dir2;</i> this <br>
   *     combines the functions of both crossProductAxis() and crossProductSign().<br>
   *     Note that if <i>dir2</i> is along the same axis as this one, we'll just<br>
   *     return this as the axis but the sign is zero since the magnitude of the <br>
   *     result would be zero. No floating point calculations are <br>
   *     performed. @see crossProductSign(), crossProductAxis() *
   */
  public CoordinateAxis crossProduct(CoordinateDirection dir2, SWIGTYPE_p_int sign) {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateDirection_crossProduct(swigCPtr, this, CoordinateDirection.getCPtr(dir2), dir2, SWIGTYPE_p_int.getCPtr(sign)), true);
  }

}
