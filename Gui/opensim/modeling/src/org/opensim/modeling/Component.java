/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * The abstract Component class defines the interface used to add computational<br>
 * elements to the underlying SimTK::System (MultibodySystem). It specifies<br>
 * the interface that components must satisfy in order to be part of the system<br>
 * and provides a series of helper methods for adding variables<br>
 * (state, discrete, cache, ...) to the underlying system. As such, Component<br>
 * handles all of the bookkeeping of system indices and provides convenience<br>
 * access to variable values (incl. derivatives) via their names as strings.<br>
 * <br>
 * # Component's Interfaces<br>
 * ## System and State<br>
 * <br>
 * The MultibodySystem and its State are defined by Simbody (ref ...). Briefly,<br>
 * a System represents the mathematical equations that specify the behavior<br>
 * of a computational model. The State is a collection of all the variables<br>
 * that uniquely define the unknowns in the system equations. Consider a single<br>
 * differential equation as a system, while a single set of variable values that<br>
 * satisfy the equation is a state of that system. These could be values for<br>
 * joint coordinates, their speeds, as well other variables that govern<br>
 * the system dynamics (e.g. muscle activation and fiber-length variables<br>
 * that dictate muscle force). These variables are called continuous state<br>
 * variables in Simbody, but are more simply referred to as <em>StateVariables</em><br>
 * in OpenSim. Component provides services to define and access its<br>
 * StateVariables and specify their dynamics (derivatives with respect to time)<br>
 * that are automatically and simultaneously integrated with the MultibodySystem<br>
 * dynamics. Common operations to integrate, take the max or min, or to delay a<br>
 * signal, etc. require internal variables to perform their calculations and<br>
 * these are also held in the State. Simbody provides the infrastructure to<br>
 * ensure that calculations are kept up-to-date with the state variable values.<br>
 * <br>
 * There are other types of "State" variables such as a flag (or options) that<br>
 * enables a component to be disabled or for a muscle force to be overridden and<br>
 * and these are identified as <em>ModelingOptions</em> since they may change<br>
 * the modeled dynamics of the component. Component provides services<br>
 * that enable developers of components to define additional ModelingOptions.<br>
 * <br>
 * ## Discrete variables<br>
 * <br>
 * Often a component requires input from an outside source (precomputed data<br>
 * from a file, another program, or interaction from a user) in which case these<br>
 * variables do not have dynamics (differential eqns.) known to the component,<br>
 * but are necessary to describe the dynamical "state" of the system. An example,<br>
 * is a throttle component (a "controller" that provides an actuator, e.g. a<br>
 * motor, with a control signal like a voltage or current) which it gets as direct<br>
 * input from the user (via a joystick, key press, etc..). The throttle controls<br>
 * the motor torque output and therefore the behavior of the model. The input by<br>
 * the user to the throttle the motor (the controls) is necessary to specify the<br>
 * model dynamics at any instant and therefore are considered part of the State.<br>
 * In OpenSim they are simply referred to as DiscreteVariables. The Component<br>
 * provides services to enable developers of components to define and access its<br>
 * DiscreteVariables.<br>
 * <br>
 * ## Cache variables<br>
 * <br>
 * Fast and efficient simulations also require computationally expensive<br>
 * calculations to be performed only when necessary. Often the result of an<br>
 * expensive calculation can be reused many times over, while the variables it<br>
 * is dependent on remain fixed. The concept of holding onto these values is<br>
 * called caching and the variables that hold these values are call<br>
 * <em>CacheVariables</em>. It is important to note, that cache variables are<br>
 * not state variables. Cache variables can always be recomputed exactly<br>
 * from the State. OpenSim uses the Simbody infrastructure to manage cache<br>
 * variables and their validity. Component provides a simplified interface to<br>
 * define and access CacheVariables.<br>
 * <br>
 * ## Stages<br>
 * <br>
 * Many modeling and simulation codes put the onus on users and component<br>
 * creators to manage the validity of cache variables, which is likely to lead<br>
 * to undetectable errors where cache values are stale (calculated based on past<br>
 * state variable values). Simbody, on the other hand, provides a more strict<br>
 * infrastructure to make it easy to exploit the efficiencies of caching while<br>
 * reducing the risks of validity errors. To do this, Simbody employs the concept<br>
 * of computational stages to "realize" (or compute) a model's system to a<br>
 * particular stage requires cached quantities up to and including the stage to<br>
 * to computed/specified. Simbody utilizes nine realization stages<br>
 * (<tt>SimTK::Stage::</tt>)<br>
 * <br>
 * -# <code>Topology</code>       finalize System with "slots" for most variables (above)<br>
 * -# <code>%Model</code>         specify modeling choices<br>
 * -# <code>Instance</code>       specify modifiable model parameters<br>
 * -# <code>Time</code>           compute time dependent quantities<br>
 * -# <code>Position</code>       compute position dependent quantities<br>
 * -# <code>Velocity</code>       compute velocity dependent quantities<br>
 * -# <code>Dynamics</code>       compute system applied forces and dependent quantities<br>
 * -# <code>Acceleration</code>   compute system accelerations and all other derivatives<br>
 * -# <code>Report</code>         compute quantities for reporting/output<br>
 * <br>
 * The Component interface is automatically invoked by the System and its<br>
 * realizations. Component users and most developers need not concern themselves<br>
 * with <code>Topology</code>, <code>%Model</code> or <code>Instance</code> stages. That interaction is managed<br>
 * by Component when component creators implement extendAddToSystem() and use the<br>
 * services provided by Component. Component creators do need to determine and<br>
 * specify stage dependencies for Discrete and CacheVariables that they add to<br>
 * their components. For example, the throttle controller reads its value from<br>
 * user input and it is valid for all calculations as long as time does not<br>
 * change. If the simulation (via numerical integration) steps forward (or<br>
 * backward for a trial step) and updates the state, the control from a previous<br>
 * state (time) should be invalid and an error generated for trying to access<br>
 * the DiscreteVariable for the control value. To do this one specifies the<br>
 * "invalidates" stage (e.g. <tt>SimTK::Stage::Time</tt>) for a DiscreteVariable<br>
 * when the variable is added to the Component. A subsequent change to that<br>
 * variable will invalidate all state cache entries at that stage or higher. For<br>
 * example, if a DiscreteVariable is declared to invalidate <tt>Stage::Position</tt><br>
 * then changing it will invalidate cache entries that depend on positions,<br>
 * velocities, forces, and accelerations.<br>
 * <br>
 * Similar principles apply to CacheVariables, which requires a "dependsOn" stage to<br>
 * be specified when a CacheVariable is added to the component. In this case,<br>
 * the cache variable "shadows" the State (unlike a DiscreteVariable, which is a<br>
 * part of the State) holding already-computed state-dependent values so that<br>
 * they do not need to be recomputed until the state changes.<br>
 * Accessing the CacheVariable in a State whose current stage is lower than<br>
 * that CacheVariable's specified dependsOn stage will trigger an exception.<br>
 * It is up to the component to update the value of the cache variable.<br>
 * Component provides methods to check if the cache is valid, update its value<br>
 * and then to mark it as valid.<br>
 * <br>
 * ## The interface of this class<br>
 * <br>
 * The primary responsibility of a Component is to add its computational<br>
 * representation(s) to the underlying SimTK::System by implementing<br>
 * extendAddToSystem().<br>
 * <br>
 * Additional methods provide support for adding modeling options, state and<br>
 * cache variables.<br>
 * <br>
 * Public methods enable access to component variables via their names.<br>
 * <br>
 * ## Subcomponents<br>
 * <br>
 * A %Component can have any number of %Components within it; we call these<br>
 * subcomponents. Subcomponents can also contain their own subcomponents as<br>
 * well. There are three categories of subcomponents, which vary in whether<br>
 * they are *configurable* and *fixed in number*:<br>
 * <br>
 * - **property subcomponents** Any Property in a Component that is of type<br>
 *   Component is a subcomponent. This includes list properties and Set%s. This<br>
 *   is the most common category of subcomponent, and its distinguishing<br>
 *   feature is that these subcomponents are *configurable* by the user of this<br>
 *   component. These subcomponents appear in the XML for this component, and<br>
 *   can be modified in XML or through the API. They are also not fixed in<br>
 *   number; users can add more property subcomponents to an existing<br>
 *   component (though it is possible to enforce a fixed number by using<br>
 *   one-value properties or limiting the size of a list property). The bodies,<br>
 *   joints, forces, etc. in a Model's BodySet, JointSet, ForceSet, etc. are<br>
 *   all examples of property subcomponents. This category of subcomponent is<br>
 *   the most similar to what was available pre-v4.0.<br>
 * - **member subcomponents** These are *not* configurable by the user of this<br>
 *   Component, and can only be modified by this Component. You can<br>
 *   still access member subcomponents through the API, but only the component<br>
 *   containing the subcomponents can modify them. Any Component class can have<br>
 *   any number of member subcomponents, but this number is *fixed* for every<br>
 *   instance of the component.<br>
 * - **adopted subcomponents** These are *not* configurable (does not appear in<br>
 *   XML) and *not* fixed in number. For example, a component can decide,<br>
 *   based on other aspects of the model, that it needs to create a new<br>
 *   subcomponent. This can be done using adopted subcomponents.<br>
 * <br>
 * Also, any specific Component can end up in any of these three categories.<br>
 * That is, if you have a MySpecialForce Component, any other Component can<br>
 * have it as a property subcomponent, a member subcomponent, or as an adopted<br>
 * subcomponent.<br>
 * <br>
 * @author Ajay Seth, Michael Sherman, Chris Dembia
 */
public class Component extends OpenSimObject {
  private transient long swigCPtr;

  public Component(long cPtr, boolean cMemoryOwn) {
    super(opensimCommonJNI.Component_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(Component obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(Component obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimCommonJNI.delete_Component(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public void addComponent(Component comp) {
      comp.markAdopted();
      private_addComponent(comp);
  }

  public static Component safeDownCast(OpenSimObject obj) {
    long cPtr = opensimCommonJNI.Component_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimCommonJNI.Component_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimCommonJNI.Component_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimCommonJNI.Component_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Component(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimCommonJNI.Component_getConcreteClassName(swigCPtr, this);
  }

  /**
   * Define a Component's internal data members and structure according to<br>
   *         its properties. This includes its subcomponents as part of the component<br>
   *         ownership tree and identifies its owner (if present) in the tree.<br>
   *         finalizeFromProperties propagates to all of the component's subcomponents<br>
   *         prior to invoking the virtual extendFinalizeFromProperties() on itself.<br>
   *         Note that if the Component has already been added to a System (result of<br>
   *         addToSystem(); e.g., Model::initSystem()) when finalizeFromProperties()<br>
   *         is called, then finalizeFromProperties() disassociates the component from<br>
   *         that System.
   */
  public void finalizeFromProperties() {
    opensimCommonJNI.Component_finalizeFromProperties(swigCPtr, this);
  }

  /**
   *  Satisfy the Component's connections specified by its Sockets and Inputs.<br>
   *         Locate Components and their Outputs to satisfy the connections in an<br>
   *         aggregate Component (e.g. Model), which is the root of a tree of<br>
   *         Components. 
   */
  public void finalizeConnections(Component root) {
    opensimCommonJNI.Component_finalizeConnections(swigCPtr, this, Component.getCPtr(root), root);
  }

  /**
   *  Disconnect/clear this Component from its aggregate component. Empties<br>
   *         all component's sockets and sets them as disconnected.
   */
  public void clearConnections() {
    opensimCommonJNI.Component_clearConnections(swigCPtr, this);
  }

  /**
   *  Have the Component add itself to the underlying computational System 
   */
  public void addToSystem(SWIGTYPE_p_SimTK__MultibodySystem system) {
    opensimCommonJNI.Component_addToSystem(swigCPtr, this, SWIGTYPE_p_SimTK__MultibodySystem.getCPtr(system));
  }

  /**
   *  Initialize Component's state variable values from its properties 
   */
  public void initStateFromProperties(State state) {
    opensimCommonJNI.Component_initStateFromProperties(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   *  %Set Component's properties given a state. 
   */
  public void setPropertiesFromState(State state) {
    opensimCommonJNI.Component_setPropertiesFromState(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   * Optional method for generating arbitrary display geometry that reflects<br>
   *     this %Component at the specified <i>state</i>. This will be called once to<br>
   *     obtain ground- and body-fixed geometry (with <i>fixed=</i><code>true)</code>, and then<br>
   *     once per frame (with <i>fixed=</i><code>false)</code> to generate on-the-fly geometry such<br>
   *     as rubber band lines, force arrows, labels, or debugging aids.<br>
   * <br>
   *     Please note that there is a precondition that the state passed in to<br>
   *     generateDecorations be realized to Stage::Position. If your component can<br>
   *     visualize quantities realized at Velocity, Dynamics or Acceleration stages,<br>
   *     then you must check that the stage has been realized before using/requesting<br>
   *     stage dependent values. It is forbidden to realize the model to a higher<br>
   *     stage within generateDecorations, because this can trigger costly side-<br>
   *     effects such as evaluating all model forces even when performing a purely<br>
   *     kinematic study.<br>
   * <br>
   *     If you override this method, be sure to invoke the base class method first,<br>
   *     using code like this:<br>
   *     {@code 
      void MyComponent::generateDecorations
         (bool                                        fixed,
          const ModelDisplayHints&                    hints,
          const SimTK::State&                         state,
          SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
      {
  invoke parent class method
          Super::generateDecorations(fixed,hints,state,appendToThis);
  ... your code goes here
  can render velocity dependent quanities if stage is Velocity or higher
          if(state.getSystemStage() >= Stage::Velocity) {
  draw velocity vector for model COM
          }
  can render computed forces if stage is Dynamics or higher
          if(state.getSystemStage() >= Stage::Dynamics) {
  change the length of a force arrow based on the force in N
          }
      }
      }<br>
   * <br>
   *     @param fixed<br>
   *         If <code>true</code>, generate only geometry that is fixed to a PhysicalFrame,<br>
   *         configuration, and velocity. Otherwise generate only such dependent<br>
   *         geometry.<br>
   *     @param hints<br>
   *         See documentation for ModelDisplayHints; you may want to alter the<br>
   *         geometry you generate depending on what you find there. For example,<br>
   *         you can determine whether the user wants to see debug geometry.<br>
   *     @param state<br>
   *         The State for which geometry should be produced. See below for more<br>
   *         information.<br>
   *     @param appendToThis<br>
   *         %Array to which generated geometry should be <i>appended</i> via the<br>
   *         <code>push_back()</code> method.<br>
   * <br>
   *     When called with <i>fixed=</i><code>true</code> only modeling options and parameters<br>
   *     (Instance variables) should affect geometry; time, position, and velocity<br>
   *     should not. In that case OpenSim will already have realized the <i>state</i><br>
   *     through Instance stage. When called with <i>fixed=</i><code>false</code>, you may<br>
   *     consult any relevant value in <i>state</i>. However, to avoid unnecessary<br>
   *     computation, OpenSim guarantees only that <i>state</i> will have been realized<br>
   *     through Position stage; if you need anything higher than that (reaction<br>
   *     forces, for example) you should make sure the <i>state</i> is realized through<br>
   *     Acceleration stage. *
   */
  public void generateDecorations(boolean fixed, ModelDisplayHints hints, State state, ArrayDecorativeGeometry appendToThis) {
    opensimCommonJNI.Component_generateDecorations(swigCPtr, this, fixed, ModelDisplayHints.getCPtr(hints), hints, State.getCPtr(state), state, ArrayDecorativeGeometry.getCPtr(appendToThis), appendToThis);
  }

  /**
   * Get the underlying MultibodySystem that this component is connected to.<br>
   * Make sure you have called Model::initSystem() prior to accessing the System.<br>
   * Throws an Exception if the System has not been created or the Component<br>
   * has not added itself to the System.<br>
   * @see hasSystem().  
   */
  public SWIGTYPE_p_SimTK__MultibodySystem getSystem() {
    return new SWIGTYPE_p_SimTK__MultibodySystem(opensimCommonJNI.Component_getSystem(swigCPtr, this), false);
  }

  /**
   * Check if this component has an underlying MultibodySystem.<br>
   * Returns false if the System has not been created OR if this<br>
   * Component has not added itself to the System.  
   */
  public boolean hasSystem() {
    return opensimCommonJNI.Component_hasSystem(swigCPtr, this);
  }

  /**
   *  Does the provided component already exist anywhere in the ownership<br>
   * tree (not just subcomponents of this component)? 
   */
  public boolean isComponentInOwnershipTree(Component component) {
    return opensimCommonJNI.Component_isComponentInOwnershipTree(swigCPtr, this, Component.getCPtr(component), component);
  }

  /**
   * Add a Component (as a subcomponent) of this component.<br>
   * This component takes ownership of the subcomponent and it will be<br>
   * serialized (appear in XML) as part of this component. Specifically,<br>
   * it will appear in the `&lt;components&gt;` list for this Component.<br>
   * If the subcomponent is already owned by this component or exists<br>
   * in the same hierarchy (tree) as this component, an Exception<br>
   * is thrown.<br>
   * Note: addComponent is intended to replace existing addBody(), addJoint,<br>
   *       ... on Model or the requirement for specific add###() methods to<br>
   *       subcomponents to a Component.<br>
   * <br>
   * Typical usage is:<br>
   *     {@code 
  Start with an empty Model (which is a Component)
          Model myModel;
  Create any Component type on the heap
          Body* newBody = new Body();
  Customize the Component by setting its properties
          newBody->setName("newBody");
          newBody->setMass(10.0);
          newBody->setMassCenter(SimTK::Vec3(0));
  ...
  Now add it to your model, which will take ownership of it
          myModel.addComponent(newBody);
  
  Keep creating and adding new components, like Joints, Forces, etc..
      }<br>
   * <br>
   * @throws ComponentAlreadyPartOfOwnershipTree<br>
   * @param subcomponent is the Component to be added. 
   */
  private void private_addComponent(Component subcomponent) {
    opensimCommonJNI.Component_private_addComponent(swigCPtr, this, Component.getCPtr(subcomponent), subcomponent);
  }

  /**
   *  Get the complete (absolute) pathname for this Component to its ancestral<br>
   * Component, which is the root of the tree to which this Component belongs.<br>
   * For example: a Coordinate Component would have an absolute path name<br>
   * like: `/arm26/elbow_r/flexion`. Accessing a Component by its<br>
   * absolutePathName from root is guaranteed to be unique. The<br>
   * absolutePathName is generated on-the-fly by traversing the ownership tree<br>
   * and, therefore, calling this method is not "free". 
   */
  public String getAbsolutePathString() {
    return opensimCommonJNI.Component_getAbsolutePathString(swigCPtr, this);
  }

  /**
   *  Return a ComponentPath of the absolute path of this Component.<br>
   * Note that this has more overhead than calling `getName()` because<br>
   * it traverses up the tree to generate the absolute pathname (and its<br>
   * computational cost is thus a function of depth). Consider other<br>
   * options if this is repeatedly called and efficiency is important.<br>
   * For instance, `getAbsolutePathString()` is faster if you only<br>
   * need the path as a string. 
   */
  public ComponentPath getAbsolutePath() {
    return new ComponentPath(opensimCommonJNI.Component_getAbsolutePath(swigCPtr, this), true);
  }

  /**
   *  Get the relative path of this Component with respect to another<br>
   * Component, as a string. 
   */
  public String getRelativePathString(Component wrt) {
    return opensimCommonJNI.Component_getRelativePathString(swigCPtr, this, Component.getCPtr(wrt), wrt);
  }

  /**
   *  Get the relative path of this Component with respect to another<br>
   * Component. 
   */
  public ComponentPath getRelativePath(Component wrt) {
    return new ComponentPath(opensimCommonJNI.Component_getRelativePath(swigCPtr, this, Component.getCPtr(wrt), wrt), true);
  }

  /**
   *  Query if there is a component (of any type) at the specified<br>
   * path name. For example,<br>
   * {@code 
  bool exists = model.hasComponent("right_elbow/elbow_flexion");
  }<br>
   * checks if `model` has a subcomponent "right_elbow," which has a<br>
   * subcomponent "elbow_flexion." 
   */
  public boolean hasComponent(String pathname) {
    return opensimCommonJNI.Component_hasComponent(swigCPtr, this, pathname);
  }

  /**
   *  Similar to the templatized getComponent(), except this returns the<br>
   * component as the generic Component type. This can be used in<br>
   * Python/Java/MATLAB. Here is an example of using this in MATLAB:<br>
   * {@code 
  coord = model.getComponent('right_elbow/elbow_flexion')
  coord.getNumConnectees() % okay; this is a Component method.
  coord.getDefaultClamped() % inaccessible; method on Coordinate.
  Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.
  }<br>
   * <br>
   * %Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  coord = model.getComponent('right_elbow/elbow_flexion')
  coord.getDefaultClamped() # works; no downcasting necessary.
  }
   */
  public Component getComponent(String pathname) {
    return new Component(opensimCommonJNI.Component_getComponent(swigCPtr, this, pathname), false);
  }

  /**
   *  Similar to the templatized updComponent(), except this returns the<br>
   * component as the generic Component type. As with the non-templatized<br>
   * getComponent(), though, this will give the concrete type in Python in<br>
   * most cases.<br>
   * @see getComponent()
   */
  public Component updComponent(String pathname) {
    return new Component(opensimCommonJNI.Component_updComponent(swigCPtr, this, pathname), false);
  }

  /**
   *  Print a list to the console of all components whose absolute path name<br>
   * contains the given string. You might use this if (a) you know the name<br>
   * of a component in your model but don't know its absolute path, (b) if<br>
   * you want to find all components with a given name, or (c) to get a list<br>
   * of all components on the right leg of a model (if all components on the<br>
   * right side have "_r" in their name).<br>
   * <br>
   * A function call like:<br>
   * {@code 
  unsigned num = comp.printComponentsMatching("rotation");
  }<br>
   * may produce output like:<br>
   * {@literal 
  /leg_model/right_hip/rotation
  /leg_model/left_hip/rotation
  }<br>
   * <br>
   * @return The number of matches. 
   */
  public long printComponentsMatching(String substring) {
    return opensimCommonJNI.Component_printComponentsMatching(swigCPtr, this, substring);
  }

  /**
   * Get the number of "continuous" state variables maintained by the<br>
   * Component and its subcomponents.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public int getNumStateVariables() {
    return opensimCommonJNI.Component_getNumStateVariables(swigCPtr, this);
  }

  /**
   * Get the names of "continuous" state variables maintained by the Component<br>
   * and its subcomponents.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public ArrayStr getStateVariableNames() {
    return new ArrayStr(opensimCommonJNI.Component_getStateVariableNames(swigCPtr, this), true);
  }

  /**
   *  Get the number of Sockets in this Component. 
   */
  public int getNumSockets() {
    return opensimCommonJNI.Component_getNumSockets(swigCPtr, this);
  }

  /**
   *  Collect and return the names of the sockets in this component. You<br>
   * can use this to iterate through the sockets:<br>
   * {@code 
  for (std::string name : comp.getSocketNames()) {
      const AbstractSocket& socket = getSocket(name);
  }
  } 
   */
  public StdVectorString getSocketNames() {
    return new StdVectorString(opensimCommonJNI.Component_getSocketNames(swigCPtr, this), true);
  }

  /**
   *  Get the connectee as an Object. This means you will not have<br>
   * access to the methods on the concrete connectee. This is the method you<br>
   * must use in MATLAB to access the connectee.<br>
   * <br>
   * Example:<br>
   * {@code 
  const Object& obj = joint.getConnectee("parent_frame");
  obj.getName(); // method on Object works.
  obj.getMobilizedBody(); // error: not available.
  }<br>
   * <br>
   * In MATLAB, if you want the concrete type, you need to downcast the<br>
   * Object. Here is an example where you know the "parent_frame" is a Body:<br>
   * {@code 
  f = joint.getConnectee('parent_frame');
  m = Body.safeDownCast(f).getMass();
  }<br>
   * <br>
   * Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  f = joint.getConnectee("parent_frame");
  m = f.getMass() # works (if the parent frame is a body)
  }
   */
  public OpenSimObject getConnectee(String name) {
    return new OpenSimObject(opensimCommonJNI.Component_getConnectee(swigCPtr, this, name), false);
  }

  public AbstractSocket getSocket(String name) {
    return new AbstractSocket(opensimCommonJNI.Component_getSocket(swigCPtr, this, name), false);
  }

  /**
   *  Get a writable reference to the AbstractSocket for the given<br>
   * socket name. Use this method to connect the Socket to something.<br>
   * <br>
   * <b>C++ example</b><br>
   * {@code 
  joint.updSocket("parent_frame").connect(model.getGround());
  }<br>
   * <br>
   * If you have not yet called finalizeFromProperties() on this<br>
   * component, this function will update the Socket (to tell it which<br>
   * component it's in) before providing it to you.
   */
  public AbstractSocket updSocket(String name) {
    return new AbstractSocket(opensimCommonJNI.Component_updSocket(swigCPtr, this, name), false);
  }

  /**
   *  Access the number of Inputs that this component has. 
   */
  public int getNumInputs() {
    return opensimCommonJNI.Component_getNumInputs(swigCPtr, this);
  }

  /**
   *  Access the number of Outputs that this component has. 
   */
  public int getNumOutputs() {
    return opensimCommonJNI.Component_getNumOutputs(swigCPtr, this);
  }

  /**
   *  Collect and return the names of Inputs in this component as an<br>
   * std::vector. 
   */
  public StdVectorString getInputNames() {
    return new StdVectorString(opensimCommonJNI.Component_getInputNames(swigCPtr, this), true);
  }

  /**
   *  Collect and return the names of Outputs in this component as an<br>
   * std::vector. 
   */
  public StdVectorString getOutputNames() {
    return new StdVectorString(opensimCommonJNI.Component_getOutputNames(swigCPtr, this), true);
  }

  /**
   * Get an Input provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get an Input from a Component in the model<br>
   * {@code 
  model.getComponent("/path/to/component").getInput("inputName");
  }<br>
   * <br>
   * If you have not yet called finalizeFromProperties() on this<br>
   * component, this function will update the Input (to tell it which<br>
   * component it's in) before providing it to you.<br>
   * <br>
   * @param name   the name of the Input<br>
   * @return const reference to the AbstractInput
   */
  public AbstractInput getInput(String name) {
    return new AbstractInput(opensimCommonJNI.Component_getInput(swigCPtr, this, name), false);
  }

  /**
   * Get a writable reference to an Input provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get a writable reference to an Input of a<br>
   * Component in a model<br>
   * {@code 
  model.updComponent("/path/to/component").updInput("inputName");
  }<br>
   * <br>
   * If you have not yet called finalizeFromProperties() on this<br>
   * component, this function will update the Input (to tell it which<br>
   * component it's in) before providing it to you.<br>
   * <br>
   * @param name   the name of the Input<br>
   * @return reference to the AbstractInput
   */
  public AbstractInput updInput(String name) {
    return new AbstractInput(opensimCommonJNI.Component_updInput(swigCPtr, this, name), false);
  }

  /**
   * Get the Output provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get an Output from a Component in a model<br>
   * {@code 
  model.getComponent("/path/to/component").getOutput("outputName");
  }<br>
   * <br>
   * @param name   the name of the Output<br>
   * @return const reference to the AbstractOutput
   */
  public AbstractOutput getOutput(String name) {
    return new AbstractOutput(opensimCommonJNI.Component_getOutput(swigCPtr, this, name), false);
  }

  /**
   * Get a writable reference to an Output provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get a writable reference to an Output of a<br>
   * Component in a model<br>
   * {@code 
  model.updComponent("/path/to/component").updOutput("outputName");
  }<br>
   * <br>
   * @param name   the name of the Output<br>
   * @return reference to the AbstractOutput
   */
  public AbstractOutput updOutput(String name) {
    return new AbstractOutput(opensimCommonJNI.Component_updOutput(swigCPtr, this, name), false);
  }

  /**
   * Get a ModelingOption flag for this Component by name.<br>
   * The flag is an integer corresponding to the index of modelingOptionNames used<br>
   * add the modeling option to the component. @see addModelingOption<br>
   * <br>
   * @param state  the State in which to set the modeling option<br>
   * @param name   the name (string) of the modeling option of interest<br>
   * @return flag  integer value for modeling option
   */
  public int getModelingOption(State state, String name) {
    return opensimCommonJNI.Component_getModelingOption(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * %Set the value of a ModelingOption flag for this Component.<br>
   * if the integer value exceeds the number of option names used to<br>
   * define the options, an exception is thrown. The SimTK::State<br>
   * Stage will be reverted back to Stage::Instance.<br>
   * <br>
   * @param state  the State in which to set the flag<br>
   * @param name   the name (string) of the modeling option of interest<br>
   * @param flag   the desired flag (int) value specifying the modeling option
   */
  public void setModelingOption(State state, String name, int flag) {
    opensimCommonJNI.Component_setModelingOption(swigCPtr, this, State.getCPtr(state), state, name, flag);
  }

  /**
   * Get the value of a state variable allocated by this Component.<br>
   * <br>
   * To connect this StateVariable as an input to another component (such as<br>
   * a Reporter), use getOutput(name); each state variable has a<br>
   * corresponding Output:<br>
   *  {@code 
   foo.getInput("input1").connect(bar.getOutput(name));
   }<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @param name    the name (string) of the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableValue(State state, String name) {
    return opensimCommonJNI.Component_getStateVariableValue__SWIG_0(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Get the value of a state variable allocated by this Component.<br>
   * <br>
   * To connect this StateVariable as an input to another component (such as<br>
   * a Reporter), use getOutput(name); each state variable has a<br>
   * corresponding Output:<br>
   * <br>
   *  {@code 
   foo.getInput("input1").connect(bar.getOutput(name));
   }<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * <br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableValue(State state, ComponentPath path) {
    return opensimCommonJNI.Component_getStateVariableValue__SWIG_1(swigCPtr, this, State.getCPtr(state), state, ComponentPath.getCPtr(path), path);
  }

  /**
   * %Set the value of a state variable allocated by this Component by name.<br>
   * <br>
   * @param state  the State for which to set the value<br>
   * @param name   the name of the state variable<br>
   * @param value  the value to set<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setStateVariableValue(State state, String name, double value) {
    opensimCommonJNI.Component_setStateVariableValue(swigCPtr, this, State.getCPtr(state), state, name, value);
  }

  /**
   * Get all values of the state variables allocated by this Component.<br>
   * Includes state variables allocated by its subcomponents.<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @return Vector of state variable values of length getNumStateVariables()<br>
   *                in the order returned by getStateVariableNames()<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public Vector getStateVariableValues(State state) {
    return new Vector(opensimCommonJNI.Component_getStateVariableValues(swigCPtr, this, State.getCPtr(state), state), true);
  }

  /**
   * %Set all values of the state variables allocated by this Component.<br>
   * Includes state variables allocated by its subcomponents. Note, this<br>
   * method simply sets the values on the input State. If other conditions<br>
   * must be met (such as satisfying kinematic constraints for Coordinates,<br>
   * or fiber and tendon equilibrium for muscles) you must invoke the<br>
   * appropriate methods on Model (e.g. assemble() to satisfy constraints or<br>
   * equilibrateMuscles()) to satisfy these conditions starting from the<br>
   * State values provided by setStateVariableValues.<br>
   * <br>
   * @param state   the State whose values are set<br>
   * @param values  Vector of state variable values of length<br>
   *                getNumStateVariables() in the order returned by<br>
   *                getStateVariableNames()<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setStateVariableValues(State state, Vector values) {
    opensimCommonJNI.Component_setStateVariableValues(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(values), values);
  }

  /**
   * Get the value of a state variable derivative computed by this Component.<br>
   * <br>
   * @param state   the State for which to get the derivative value<br>
   * @param name    the name (string) of the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableDerivativeValue(State state, String name) {
    return opensimCommonJNI.Component_getStateVariableDerivativeValue(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Get the value of a discrete variable allocated by this Component by name.<br>
   * <br>
   * @param state   the State from which to get the value<br>
   * @param name    the name of the state variable<br>
   * @return value  the discrete variable value<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getDiscreteVariableValue(State state, String name) {
    return opensimCommonJNI.Component_getDiscreteVariableValue(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * %Set the value of a discrete variable allocated by this Component by name.<br>
   * <br>
   * @param state  the State for which to set the value<br>
   * @param name   the name of the discrete variable<br>
   * @param value  the value to set<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setDiscreteVariableValue(State state, String name, double value) {
    opensimCommonJNI.Component_setDiscreteVariableValue(swigCPtr, this, State.getCPtr(state), state, name, value);
  }

  /**
   * Get the index of a Component's cache variable in the Subsystem for allocations.<br>
   * <br>
   * <br>
   * @param name<br>
   *   Name of the cache variable, as provided to Component::addCacheVariable<br>
   * @return <br>
   *   A valid SimTK::CacheEntryIndex, which callers can use with simbody methods<br>
   *   (e.g. markCacheValueRealized)
   */
  public SWIGTYPE_p_SimTK__CacheEntryIndex getCacheVariableIndex(String name) {
    return new SWIGTYPE_p_SimTK__CacheEntryIndex(opensimCommonJNI.Component_getCacheVariableIndex(swigCPtr, this, name), true);
  }

  /**
   * Returns true if the cache variable, identified by `name`, is valid.<br>
   * <br>
   * This method enables callers to monitor the validity of the cache variable,<br>
   * which enables the caller to decide whether to update the cache variable's<br>
   * value (or not). When computing an update is costly, use this method to check<br>
   * whether computing the value is necessary.<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @return bool<br>
   *     whether the cache variable's value is valid or not<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public boolean isCacheVariableValid(State state, String name) {
    return opensimCommonJNI.Component_isCacheVariableValid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Marks the value of a cache variable, identified by `name`, as valid.<br>
   * <br>
   * Upon marking a cache variable's value as valid, the cache variable will remain<br>
   * valid until either:<br>
   * <br>
   * - the realization stage falls below the minimum realization stage set<br>
   *   when the cache variable was initialized with `Component::addCacheVariable`<br>
   * <br>
   * - the cache variable is explicitly invalidated by calling<br>
   *   `Component::markCacheVariableInvalid`<br>
   * <br>
   * This method causes `Component::isCacheVariableValid` to return true.<br>
   * `Component::isCacheVariableValid` is commonly used by value-getting<br>
   * methods to decide on whether to return the value as-is or recompute the<br>
   * value. Therefore, if a cache variable is not marked as valid then the<br>
   * cache variable's value may be recomputed more than necessary, which may<br>
   * be costly.<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public void markCacheVariableValid(State state, String name) {
    opensimCommonJNI.Component_markCacheVariableValid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Marks the value of a cache variable, identified by `name`, as invalid.<br>
   * <br>
   * Upon marking a cache variable's value as invalid, it will remain invalid<br>
   * until `Component::markCacheVariableValid` is called (or a method which<br>
   * uses that, such as `Component::setCacheVariableValue`, is called).<br>
   * <br>
   * - Cache variables are automatically marked as invalid when the realization stage<br>
   *   falls below the minimum realization stage set when the cache variable was<br>
   *   initialized with `Component::addCacheVariable`.<br>
   * <br>
   * - Cache variables *may* be indirectly marked as invalid by other methods. For<br>
   *   example, a component-added state variable may invalidate a cache variable at<br>
   *   a lower stage. Concretely:<br>
   * <br>
   *   - A (hypothetical) component has a `length` state variable<br>
   *   - There are cache variables that are computed from `length` (e.g.<br>
   *   `strain`)<br>
   *   - So changing the `length` may invalidate the `strain` indirectly<br>
   *     (depending on how the state variable is handled)<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public void markCacheVariableInvalid(State state, String name) {
    opensimCommonJNI.Component_markCacheVariableInvalid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   *  List all subcomponents by name and recurse into these components to<br>
   *     list their subcomponents, and so on.                                      
   */
  public void printSubcomponentInfo() {
    opensimCommonJNI.Component_printSubcomponentInfo(swigCPtr, this);
  }

  /**
   *  List all the Sockets of this component and whether or not they are<br>
   *     connected. Also list the connectee paths for sockets that are connected. 
   */
  public void printSocketInfo() {
    opensimCommonJNI.Component_printSocketInfo(swigCPtr, this);
  }

  /**
   *  List all the inputs of this component and whether or not they are<br>
   *     connected. Also list the (desired) connectee paths for the inputs.       
   */
  public void printInputInfo() {
    opensimCommonJNI.Component_printInputInfo(swigCPtr, this);
  }

  /**
   *  Print outputs of this component and optionally, those of all<br>
   *     subcomponents.                                                            
   */
  public void printOutputInfo(boolean includeDescendants) {
    opensimCommonJNI.Component_printOutputInfo__SWIG_0(swigCPtr, this, includeDescendants);
  }

  /**
   *  Print outputs of this component and optionally, those of all<br>
   *     subcomponents.                                                            
   */
  public void printOutputInfo() {
    opensimCommonJNI.Component_printOutputInfo__SWIG_1(swigCPtr, this);
  }

  /**
   *  Access the owner of this Component.<br>
   * An exception is thrown if the %Component has no owner; in this case, the<br>
   * component is the root component, or is orphaned.<br>
   * @see hasOwner() 
   */
  public Component getOwner() {
    return new Component(opensimCommonJNI.Component_getOwner(swigCPtr, this), false);
  }

  /**
   *  (For advanced users) Check if this %Component has an owner.<br>
   * A component may not have an owner if it:<br>
   * (1) is the root component, or<br>
   * (2) has not been added to another component 
   */
  public boolean hasOwner() {
    return opensimCommonJNI.Component_hasOwner(swigCPtr, this);
  }

  /**
   *  Obtain the root %Component, which is this component if it is orphaned.
   */
  public Component getRoot() {
    return new Component(opensimCommonJNI.Component_getRoot(swigCPtr, this), false);
  }

  /**
   *  Find a Component to which this Component is an ancestor---in other<br>
   *     words, a Component that is directly owned by this Component or is owned<br>
   *     by one of its sub-components, sub-sub-components, etc. The Component can<br>
   *     be found by type (by specifying a template argument) and either path or<br>
   *     name.<br>
   * <br>
   *     Here is an example of searching for a component of any type with the name<br>
   *     'elbow_flexion':<br>
   *     {@code 
      if (const Component* found =
              model.findComponent(ComponentPath("elbow_flexion"))) {
          std::cout << found.getName() << std::endl;
      }
      }<br>
   * <br>
   *     Here, we require that 'elbow_flexion' is of type Coordinate.<br>
   *     {@code 
      if (const Coordinate* found =
              model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
          std::cout << "Coordinate " << found.getName() << std::endl;
      }
      }<br>
   * <br>
   *     The search can be sped up considerably if the path or even partial path<br>
   *     name is known. For example, "forearm/elbow/elbow_flexion" will find<br>
   *     the Coordinate component of the elbow joint that connects the forearm body<br>
   *     in linear time (linear search for name at each component level). Whereas<br>
   *     supplying "elbow_flexion" requires a tree search. Returns nullptr (None in<br>
   *     Python, empty array in Matlab) if Component of that specified name cannot<br>
   *     be found.<br>
   * <br>
   *     NOTE: If the component name is ambiguous, an exception is thrown. To<br>
   *     disambiguate, more information must be provided, such as the template<br>
   *     argument to specify the type and/or a path rather than just the name. 
   */
  public Component findComponent(ComponentPath pathToFind) {
    long cPtr = opensimCommonJNI.Component_findComponent__SWIG_2(swigCPtr, this, ComponentPath.getCPtr(pathToFind), pathToFind);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   *  Same as findComponent(const ComponentPath&amp;), but accepting a string (a<br>
   *     path or just a name) as input. 
   */
  public Component findComponent(String pathToFind) {
    long cPtr = opensimCommonJNI.Component_findComponent__SWIG_3(swigCPtr, this, pathToFind);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   * Get an iterator through the underlying subcomponents that this component is<br>
   * composed of. The hierarchy of Components/subComponents forms a tree.<br>
   * The order of the Components is that of tree preorder traversal so that a<br>
   * component is traversed before its subcomponents.<br>
   * <br>
   * {@code 
  for (const auto& muscle : model.getComponentList<Muscle>()) {
      muscle.get_max_isometric_force();
  }
  }<br>
   * <br>
   * The returned ComponentList does not permit modifying any components; if<br>
   * you want to modify the components, see updComponentList().<br>
   * <br>
   * 
   */
  public ComponentsList getComponentsList() {
    return new ComponentsList(opensimCommonJNI.Component_getComponentsList(swigCPtr, this), true);
  }

}
