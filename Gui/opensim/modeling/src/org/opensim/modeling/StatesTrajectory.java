/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * <br>
 * This class holds a sequence of SimTK::State%s. You can obtain a<br>
 * StatesTrajectory during a simulation via the StatesTrajectoryReporter. You<br>
 * can also create a StatesTrajectory from a states storage (.sto) file (see<br>
 * createFromStatesStorage()). Users can modify a trajectory by appending<br>
 * states to it, but users cannot modify the individual states that are already<br>
 * in a trajectory.<br>
 * <br>
 * This class was introduced in OpenSim version 4.0, and enables scripting<br>
 * (Python/MATLAB) and C++ users to postprocess their results with greater ease<br>
 * and flexibility than with an Analysis.<br>
 * <br>
 * Note: In a future release, we plan to support an OSTATES file format that<br>
 * allows one to write the trajectory to a file with full numerical precision.<br>
 * <br>
 * <br>
 * This class is designed to ensure the following:<br>
 * - The states are ordered nondecreasing in time (adjacent states *can* have<br>
 *   the same time).<br>
 * - All states in the trajectory are consistent with each other (see<br>
 *   isConsistent()).<br>
 * <br>
 * Note: These guarantees apply when using this class through C++, Java,<br>
 * or the %OpenSim GUI, but **not** through Python or MATLAB. This is because<br>
 * Python and MATLAB do not enforce constness and thus allow modifying the<br>
 * trajectory.<br>
 * <br>
 * <br>
 * A StatesTrajectory is not very useful on its own, since neither the<br>
 * trajectory nor the contained states know how the Component%s name the state<br>
 * variables they create. You probably want to use the trajectory with an<br>
 * OpenSim::Model, through which the state variables have a meaning (e.g.,<br>
 * `model.getStateVariableValue(states[0], "soleus_r/activation")`).<br>
 * <br>
 * SimTK::State%s have a tight association with a specific OpenSim::Model<br>
 * (actually, with the SimTK::System within an OpenSim::Model). However,<br>
 * the StatesTrajectory does not know anything about the model to which<br>
 * it corresponds. So, for example, you could use a single StatesTrajectory<br>
 * with a generic gait2392 model as well as with a scaled (subject-specific)<br>
 * gait2392 model. This flexibility may be beneficial in some scenarios, but<br>
 * also allows one to accidentally use the wrong model with a given states<br>
 * trajectory, potentially leading to silent errors that could compromise a<br>
 * scientific study.<br>
 * <br>
 * To increase your confidence that a StatesTrajectory matches a given Model,<br>
 * you can perform some weak checks with isCompatibleWith().<br>
 * <br>
 * <br>
 * Here are a few basic things you can do with a StatesTrajectory, assuming you<br>
 * already have one:<br>
 * {@code 
StatesTrajectory states = getStatesTrajectorySomehow();
const double numStates = states.getSize();
const double initialTime = states[0].getTime();
const double finalTime = states.back().getTime();
}<br>
 * <br>
 * Without a model, you can access the state variable values, but you won't<br>
 * know the identity of such state variables.<br>
 * {@code 
int numGeneralizedCoordinates = states[0].getNQ();
const SimTK::Vector& generalizedCoordinateValues = states[0].getQ();
}<br>
 * <br>
 * To do most things with the StatesTrajectory, you'll need a model as well as<br>
 * its underlying SimTK::System. **It is therefore required that you call<br>
 * `Model::initSystem()` before you try to use any states with the model**:<br>
 * {@code 
Model model("subject01.osim");
model.initSystem();
double knee_angle = model.getStateVariableValue(states[0], "knee/flexion/value");
Vec3 com = model.calcMassCenterPosition(states[0]);
}<br>
 * <br>
 * Depending on the quantity you want to obtain, you may also need to realize<br>
 * the state to a certain stage:<br>
 * {@code 
model.getMultibodySystem().realize(states[0], SimTK::Stage::Velocity);
model.getMuscles().get("soleus_r").getActivation(states[0]);
}<br>
 * <br>
 * You can iterate through a trajectory to access the value of a state variable<br>
 * at each time in the trajectory.<br>
 * {@code 
for (const auto& state : states) {
    std::cout << state.getTime() << " "
              << model.getStateVariableValue(state, "knee/flexion/value")
              << std::endl;
}
}
 */
public class StatesTrajectory {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public StatesTrajectory(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(StatesTrajectory obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(StatesTrajectory obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_StatesTrajectory(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Create an empty trajectory of states. 
   */
  public StatesTrajectory() {
    this(opensimSimulationJNI.new_StatesTrajectory(), true);
  }

  /**
   *  The number of SimTK::State%s in the trajectory. 
   */
  public long getSize() {
    return opensimSimulationJNI.StatesTrajectory_getSize(swigCPtr, this);
  }

  /**
   *  Get a const reference to the state at a given index in the trajectory.<br>
   * <br>
   * @throws IndexOutOfRange If the index is greater than the size of the<br>
   *                         trajectory.
   */
  public State get(long index) {
    return new State(opensimSimulationJNI.StatesTrajectory_get(swigCPtr, this, index), false);
  }

  /**
   *  Get a const reference to the first state in the trajectory. 
   */
  public State front() {
    return new State(opensimSimulationJNI.StatesTrajectory_front(swigCPtr, this), false);
  }

  /**
   *  Get a const reference to the last state in the trajectory. 
   */
  public State back() {
    return new State(opensimSimulationJNI.StatesTrajectory_back(swigCPtr, this), false);
  }

  /**
   *  Iterator pointing to first SimTK::State; does not allow modifying the<br>
   * states. Allows using this class in a range for loop. 
   */
  public SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator begin() {
    return new SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator(opensimSimulationJNI.StatesTrajectory_begin(swigCPtr, this), true);
  }

  /**
   *  Iterator pointing past the end of the trajectory. Allows using this<br>
   * class in a range for loop. 
   */
  public SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator end() {
    return new SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator(opensimSimulationJNI.StatesTrajectory_end(swigCPtr, this), true);
  }

  /**
   *  <br>
   *  Clear all the states in the trajectory. 
   */
  public void clear() {
    opensimSimulationJNI.StatesTrajectory_clear(swigCPtr, this);
  }

  /**
   *  Append a SimTK::State to this trajectory.<br>
   * This function ensures that the time in the new SimTK::State is greater<br>
   * than or equal to the time in the last SimTK::State in the trajectory.<br>
   * <br>
   * The state that ends up in the trajectory is a deep copy of the one<br>
   * passed in.
   */
  public void append(State state) {
    opensimSimulationJNI.StatesTrajectory_append(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   *  <br>
   *  Checks isNondecreasingInTime() and isConsistent().<br>
   * The design of this class is such that this method should always return<br>
   * true. This check may be more useful in Python or MATLAB, in which it's<br>
   * possible to edit the trajectory such that this method could return<br>
   * false.  
   */
  public boolean hasIntegrity() {
    return opensimSimulationJNI.StatesTrajectory_hasIntegrity(swigCPtr, this);
  }

  /**
   *  Returns true if times are non-decreasing; false otherwise. 
   */
  public boolean isNondecreasingInTime() {
    return opensimSimulationJNI.StatesTrajectory_isNondecreasingInTime(swigCPtr, this);
  }

  /**
   *  Checks if the states have the same number of state variables,<br>
   * constraints, etc. Returns true if the following quantities are the same<br>
   * for all states in the trajectory:<br>
   * - number of generalized coordinates (Q's)<br>
   * - number of generalized speeds (U's)<br>
   * - number of auxiliary state variables (Z's)<br>
   * - number of position constraints (QErr's)<br>
   * - number of velocity constraints (UErr's)<br>
   * - number of acceleration constraints (UDotErr's)<br>
   * - number of constraint Lagrange multipliers<br>
   * - number of event triggers<br>
   * <br>
   * Returns false otherwise.
   */
  public boolean isConsistent() {
    return opensimSimulationJNI.StatesTrajectory_isConsistent(swigCPtr, this);
  }

  /**
   *  Weak check for if the trajectory can be used with the given model.<br>
   * Returns true if the trajectory isConsistent() and if the number of speeds<br>
   * in the model matches the number of U's in state.<br>
   * <br>
   * Returns false otherwise. This method **cannot** guarantee that the<br>
   * trajectory will work with the given model, and makes no attempt to<br>
   * determine if the trajectory was generated with the given model.
   */
  public boolean isCompatibleWith(Model model) {
    return opensimSimulationJNI.StatesTrajectory_isCompatibleWith(swigCPtr, this, Model.getCPtr(model), model);
  }

  /**
   *  Export the continuous state variables to a data table, perhaps to write<br>
   * to a file and postprocess in MATLAB/Python/Excel. The names of the<br>
   * columns in the table will be the absolute names of the continuous state<br>
   * variables (e.g., `knee/flexion/angle`).<br>
   * <br>
   * You must provide a model that is compatible with this trajectory,<br>
   * since only the model knows the names of the state variables.<br>
   * <br>
   * By default, all continuous state variables are written to the table<br>
   * (one per column). If you only want some of them to be written to the<br>
   * table, use the `stateVars` argument to specify their absolute names<br>
   * (e.g., `knee/flexion/angle`).<br>
   * <br>
   * {@code 
  auto allStateVars = states.exportToTable(model);
  auto kneeStates = states.exportToTable(model, {"knee/flexion/value",
                                                 "knee/flexion/speed"});
  }<br>
   * <br>
   * @throws IncompatibleModel Thrown if the Model fails the check<br>
   *      isCompatibleWith().<br>
   * <br>
   * See DataAdapter for details on writing to files.
   */
  public TimeSeriesTable exportToTable(Model model, StdVectorString stateVars) {
    return new TimeSeriesTable(opensimSimulationJNI.StatesTrajectory_exportToTable__SWIG_0(swigCPtr, this, Model.getCPtr(model), model, StdVectorString.getCPtr(stateVars), stateVars), true);
  }

  /**
   *  Export the continuous state variables to a data table, perhaps to write<br>
   * to a file and postprocess in MATLAB/Python/Excel. The names of the<br>
   * columns in the table will be the absolute names of the continuous state<br>
   * variables (e.g., `knee/flexion/angle`).<br>
   * <br>
   * You must provide a model that is compatible with this trajectory,<br>
   * since only the model knows the names of the state variables.<br>
   * <br>
   * By default, all continuous state variables are written to the table<br>
   * (one per column). If you only want some of them to be written to the<br>
   * table, use the `stateVars` argument to specify their absolute names<br>
   * (e.g., `knee/flexion/angle`).<br>
   * <br>
   * {@code 
  auto allStateVars = states.exportToTable(model);
  auto kneeStates = states.exportToTable(model, {"knee/flexion/value",
                                                 "knee/flexion/speed"});
  }<br>
   * <br>
   * @throws IncompatibleModel Thrown if the Model fails the check<br>
   *      isCompatibleWith().<br>
   * <br>
   * See DataAdapter for details on writing to files.
   */
  public TimeSeriesTable exportToTable(Model model) {
    return new TimeSeriesTable(opensimSimulationJNI.StatesTrajectory_exportToTable__SWIG_1(swigCPtr, this, Model.getCPtr(model), model), true);
  }

  /**
   *  Thrown when trying to append a state that is not consistent with the<br>
   * rest of the trajectory. 
   */
  static public class InconsistentState extends OpenSimException {
    private transient long swigCPtr;
  
    public InconsistentState(long cPtr, boolean cMemoryOwn) {
      super(opensimSimulationJNI.StatesTrajectory_InconsistentState_SWIGUpcast(cPtr), cMemoryOwn);
      swigCPtr = cPtr;
    }
  
    public static long getCPtr(InconsistentState obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    public static long swigRelease(InconsistentState obj) {
      long ptr = 0;
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new RuntimeException("Cannot release ownership as memory is not owned");
        ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.delete();
      }
      return ptr;
    }
  
    @SuppressWarnings("deprecation")
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          opensimSimulationJNI.delete_StatesTrajectory_InconsistentState(swigCPtr);
        }
        swigCPtr = 0;
      }
      super.delete();
    }
  
    public InconsistentState(String file, long line, String func, double stateTime) {
      this(opensimSimulationJNI.new_StatesTrajectory_InconsistentState(file, line, func, stateTime), true);
    }
  
  }

  /**
   *  Thrown when trying to use a StatesTrajectory with an incompatible model.<br>
   * See isCompatibleWith().  Thrown when trying to create a StatesTrajectory from states data,<br>
   * and the data does not contain a column for every continuous state<br>
   * variable. 
   */
  static public class MissingColumns extends OpenSimException {
    private transient long swigCPtr;
  
    public MissingColumns(long cPtr, boolean cMemoryOwn) {
      super(opensimSimulationJNI.StatesTrajectory_MissingColumns_SWIGUpcast(cPtr), cMemoryOwn);
      swigCPtr = cPtr;
    }
  
    public static long getCPtr(MissingColumns obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    public static long swigRelease(MissingColumns obj) {
      long ptr = 0;
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new RuntimeException("Cannot release ownership as memory is not owned");
        ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.delete();
      }
      return ptr;
    }
  
    @SuppressWarnings("deprecation")
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          opensimSimulationJNI.delete_StatesTrajectory_MissingColumns(swigCPtr);
        }
        swigCPtr = 0;
      }
      super.delete();
    }
  
    public MissingColumns(String file, long line, String func, String modelName, StdVectorString missingStates) {
      this(opensimSimulationJNI.new_StatesTrajectory_MissingColumns(file, line, func, modelName, StdVectorString.getCPtr(missingStates), missingStates), true);
    }
  
  }

  /**
   *  Thrown when trying to create a StatesTrajectory from states data, and<br>
   * the data contains columns that do not correspond to continuous state<br>
   * variables. 
   */
  static public class ExtraColumns extends OpenSimException {
    private transient long swigCPtr;
  
    public ExtraColumns(long cPtr, boolean cMemoryOwn) {
      super(opensimSimulationJNI.StatesTrajectory_ExtraColumns_SWIGUpcast(cPtr), cMemoryOwn);
      swigCPtr = cPtr;
    }
  
    public static long getCPtr(ExtraColumns obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    public static long swigRelease(ExtraColumns obj) {
      long ptr = 0;
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new RuntimeException("Cannot release ownership as memory is not owned");
        ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.delete();
      }
      return ptr;
    }
  
    @SuppressWarnings("deprecation")
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          opensimSimulationJNI.delete_StatesTrajectory_ExtraColumns(swigCPtr);
        }
        swigCPtr = 0;
      }
      super.delete();
    }
  
    public ExtraColumns(String file, long line, String func, String modelName, StdVectorString extraStates) {
      this(opensimSimulationJNI.new_StatesTrajectory_ExtraColumns(file, line, func, modelName, StdVectorString.getCPtr(extraStates), extraStates), true);
    }
  
  }

  /**
   *  Thrown by createFromStatesStorage(). 
   */
  static public class DataIsInDegrees extends OpenSimException {
    private transient long swigCPtr;
  
    public DataIsInDegrees(long cPtr, boolean cMemoryOwn) {
      super(opensimSimulationJNI.StatesTrajectory_DataIsInDegrees_SWIGUpcast(cPtr), cMemoryOwn);
      swigCPtr = cPtr;
    }
  
    public static long getCPtr(DataIsInDegrees obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    public static long swigRelease(DataIsInDegrees obj) {
      long ptr = 0;
      if (obj != null) {
        if (!obj.swigCMemOwn)
          throw new RuntimeException("Cannot release ownership as memory is not owned");
        ptr = obj.swigCPtr;
        obj.swigCMemOwn = false;
        obj.delete();
      }
      return ptr;
    }
  
    @SuppressWarnings("deprecation")
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          opensimSimulationJNI.delete_StatesTrajectory_DataIsInDegrees(swigCPtr);
        }
        swigCPtr = 0;
      }
      super.delete();
    }
  
    public DataIsInDegrees(String file, long line, String func) {
      this(opensimSimulationJNI.new_StatesTrajectory_DataIsInDegrees(file, line, func), true);
    }
  
  }

  /**
   *  <br>
   * This function is identical to createFromStatesTable() except that this<br>
   * function accepts a Storage instead of a TimeSeriesTable.
   */
  public static StatesTrajectory createFromStatesStorage(Model model, Storage sto, boolean allowMissingColumns, boolean allowExtraColumns, boolean assemble) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesStorage__SWIG_0(Model.getCPtr(model), model, Storage.getCPtr(sto), sto, allowMissingColumns, allowExtraColumns, assemble), true);
  }

  /**
   *  <br>
   * This function is identical to createFromStatesTable() except that this<br>
   * function accepts a Storage instead of a TimeSeriesTable.
   */
  public static StatesTrajectory createFromStatesStorage(Model model, Storage sto, boolean allowMissingColumns, boolean allowExtraColumns) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesStorage__SWIG_1(Model.getCPtr(model), model, Storage.getCPtr(sto), sto, allowMissingColumns, allowExtraColumns), true);
  }

  /**
   *  <br>
   * This function is identical to createFromStatesTable() except that this<br>
   * function accepts a Storage instead of a TimeSeriesTable.
   */
  public static StatesTrajectory createFromStatesStorage(Model model, Storage sto, boolean allowMissingColumns) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesStorage__SWIG_2(Model.getCPtr(model), model, Storage.getCPtr(sto), sto, allowMissingColumns), true);
  }

  /**
   *  <br>
   * This function is identical to createFromStatesTable() except that this<br>
   * function accepts a Storage instead of a TimeSeriesTable.
   */
  public static StatesTrajectory createFromStatesStorage(Model model, Storage sto) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesStorage__SWIG_3(Model.getCPtr(model), model, Storage.getCPtr(sto), sto), true);
  }

  /**
   *  Create a partial trajectory of States from a states table.<br>
   * The resulting StatesTrajectory will restore continuous state<br>
   * variable values, but not discrete state variable values, modeling<br>
   * option values, etc. Also, keep in mind that states files usually<br>
   * do not contain the state values to full precision, and thus cannot<br>
   * exactly reproduce results from the initial state trajectory. Lastly,<br>
   * this function optionally modifies each state to obey any constraints in<br>
   * the model (by calling Model::assemble()).<br>
   * <br>
   * The states in the resulting trajectory will be realized to<br>
   * SimTK::Stage::Instance. You should not use the resulting trajectory with<br>
   * an instance of the model other than the one you passed to this function<br>
   * (the state contains Instance-stage cache variables that are pointers to<br>
   * objects in the model; e.g., force elements).<br>
   * <br>
   * Note: The naming convention for state variables changed in OpenSim v4.0;<br>
   * `ankle_r/ankle_angle_r/speed` used to be `ankle_angle_r_u`,<br>
   * `soleus_r/activation` used to be `soleus_r.activation`, etc. This<br>
   * function can handle column labels that use the pre-v4.0 naming<br>
   * convention.<br>
   * <br>
   * @param model The Model to which the states belong. A Model is necessary<br>
   *      because the data file lists the state variables by name.<br>
   * @param table The table containing state values.<br>
   * @param allowMissingColumns If false, throws exception if there are<br>
   *      continuous state variables in the Model for which there is no<br>
   *      column in the table. If true, no exception is thrown but such<br>
   *      state variables are set to NaN.<br>
   * @param allowExtraColumns If false, throws exception if there are<br>
   *      columns in the table that do not correspond to continuous state<br>
   *      variables in the Model. If true, such columns of the table are<br>
   *      ignored.<br>
   * @param assemble Modify state variable values to satisfy<br>
   *      kinematic constraints (by calling Model::assemble()).<br>
   *      Use this option if the provided states are incomplete (for example,<br>
   *      the values for dependent coordinates are unspecified).<br>
   *      Caution: enforcing constraints can drastically alter the<br>
   *      provided states if they do not already obey the constraints.<br>
   *      Do not use this option with results from a forward simulation: the<br>
   *      states trajectory from a forward simulation may not meet the<br>
   *      model's assembly accuracy, and therefore assembling could<br>
   *      alter the trajectory and cause inconsistency between coordinate<br>
   *      values and speeds.<br>
   * <br>
   * Here is how you might use this function in python:<br>
   * {@code 
  import opensim
  model = opensim.Model("subject01.osim")
  table = opensim.TimeSeriesTable("subject01_states.sto")
  states = opensim.StatesTrajectory.createFromStatesTable(model, table)
  print(states[0].getTime())
  print(model.getStateVariableValue(states[0], "knee/flexion/value"))
  }<br>
   * <br>
   * @throws MissingColumns See the description of the<br>
   *      `allowMissingColumns` argument.<br>
   * <br>
   * @throws ExtraColumns See the description of the<br>
   *      `allowExtraColumns` argument.<br>
   * <br>
   * @throws NonUniqueLabels Thrown if multiple columns in<br>
   *      the table have the same name.<br>
   * <br>
   * @throws DataIsInDegrees Thrown if the table is in degrees<br>
   *      (inDegrees=yes); angular quantities must use radians to properly<br>
   *      create the trajectory.
   */
  public static StatesTrajectory createFromStatesTable(Model model, TimeSeriesTable table, boolean allowMissingColumns, boolean allowExtraColumns, boolean assemble) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesTable__SWIG_0(Model.getCPtr(model), model, TimeSeriesTable.getCPtr(table), table, allowMissingColumns, allowExtraColumns, assemble), true);
  }

  /**
   *  Create a partial trajectory of States from a states table.<br>
   * The resulting StatesTrajectory will restore continuous state<br>
   * variable values, but not discrete state variable values, modeling<br>
   * option values, etc. Also, keep in mind that states files usually<br>
   * do not contain the state values to full precision, and thus cannot<br>
   * exactly reproduce results from the initial state trajectory. Lastly,<br>
   * this function optionally modifies each state to obey any constraints in<br>
   * the model (by calling Model::assemble()).<br>
   * <br>
   * The states in the resulting trajectory will be realized to<br>
   * SimTK::Stage::Instance. You should not use the resulting trajectory with<br>
   * an instance of the model other than the one you passed to this function<br>
   * (the state contains Instance-stage cache variables that are pointers to<br>
   * objects in the model; e.g., force elements).<br>
   * <br>
   * Note: The naming convention for state variables changed in OpenSim v4.0;<br>
   * `ankle_r/ankle_angle_r/speed` used to be `ankle_angle_r_u`,<br>
   * `soleus_r/activation` used to be `soleus_r.activation`, etc. This<br>
   * function can handle column labels that use the pre-v4.0 naming<br>
   * convention.<br>
   * <br>
   * @param model The Model to which the states belong. A Model is necessary<br>
   *      because the data file lists the state variables by name.<br>
   * @param table The table containing state values.<br>
   * @param allowMissingColumns If false, throws exception if there are<br>
   *      continuous state variables in the Model for which there is no<br>
   *      column in the table. If true, no exception is thrown but such<br>
   *      state variables are set to NaN.<br>
   * @param allowExtraColumns If false, throws exception if there are<br>
   *      columns in the table that do not correspond to continuous state<br>
   *      variables in the Model. If true, such columns of the table are<br>
   *      ignored.<br>
   * <br>
   * <br>
   * Here is how you might use this function in python:<br>
   * {@code 
  import opensim
  model = opensim.Model("subject01.osim")
  table = opensim.TimeSeriesTable("subject01_states.sto")
  states = opensim.StatesTrajectory.createFromStatesTable(model, table)
  print(states[0].getTime())
  print(model.getStateVariableValue(states[0], "knee/flexion/value"))
  }<br>
   * <br>
   * @throws MissingColumns See the description of the<br>
   *      `allowMissingColumns` argument.<br>
   * <br>
   * @throws ExtraColumns See the description of the<br>
   *      `allowExtraColumns` argument.<br>
   * <br>
   * @throws NonUniqueLabels Thrown if multiple columns in<br>
   *      the table have the same name.<br>
   * <br>
   * @throws DataIsInDegrees Thrown if the table is in degrees<br>
   *      (inDegrees=yes); angular quantities must use radians to properly<br>
   *      create the trajectory.
   */
  public static StatesTrajectory createFromStatesTable(Model model, TimeSeriesTable table, boolean allowMissingColumns, boolean allowExtraColumns) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesTable__SWIG_1(Model.getCPtr(model), model, TimeSeriesTable.getCPtr(table), table, allowMissingColumns, allowExtraColumns), true);
  }

  /**
   *  Create a partial trajectory of States from a states table.<br>
   * The resulting StatesTrajectory will restore continuous state<br>
   * variable values, but not discrete state variable values, modeling<br>
   * option values, etc. Also, keep in mind that states files usually<br>
   * do not contain the state values to full precision, and thus cannot<br>
   * exactly reproduce results from the initial state trajectory. Lastly,<br>
   * this function optionally modifies each state to obey any constraints in<br>
   * the model (by calling Model::assemble()).<br>
   * <br>
   * The states in the resulting trajectory will be realized to<br>
   * SimTK::Stage::Instance. You should not use the resulting trajectory with<br>
   * an instance of the model other than the one you passed to this function<br>
   * (the state contains Instance-stage cache variables that are pointers to<br>
   * objects in the model; e.g., force elements).<br>
   * <br>
   * Note: The naming convention for state variables changed in OpenSim v4.0;<br>
   * `ankle_r/ankle_angle_r/speed` used to be `ankle_angle_r_u`,<br>
   * `soleus_r/activation` used to be `soleus_r.activation`, etc. This<br>
   * function can handle column labels that use the pre-v4.0 naming<br>
   * convention.<br>
   * <br>
   * @param model The Model to which the states belong. A Model is necessary<br>
   *      because the data file lists the state variables by name.<br>
   * @param table The table containing state values.<br>
   * @param allowMissingColumns If false, throws exception if there are<br>
   *      continuous state variables in the Model for which there is no<br>
   *      column in the table. If true, no exception is thrown but such<br>
   *      state variables are set to NaN.<br>
   * <br>
   * <br>
   * <br>
   * Here is how you might use this function in python:<br>
   * {@code 
  import opensim
  model = opensim.Model("subject01.osim")
  table = opensim.TimeSeriesTable("subject01_states.sto")
  states = opensim.StatesTrajectory.createFromStatesTable(model, table)
  print(states[0].getTime())
  print(model.getStateVariableValue(states[0], "knee/flexion/value"))
  }<br>
   * <br>
   * @throws MissingColumns See the description of the<br>
   *      `allowMissingColumns` argument.<br>
   * <br>
   * @throws ExtraColumns See the description of the<br>
   *      `allowExtraColumns` argument.<br>
   * <br>
   * @throws NonUniqueLabels Thrown if multiple columns in<br>
   *      the table have the same name.<br>
   * <br>
   * @throws DataIsInDegrees Thrown if the table is in degrees<br>
   *      (inDegrees=yes); angular quantities must use radians to properly<br>
   *      create the trajectory.
   */
  public static StatesTrajectory createFromStatesTable(Model model, TimeSeriesTable table, boolean allowMissingColumns) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesTable__SWIG_2(Model.getCPtr(model), model, TimeSeriesTable.getCPtr(table), table, allowMissingColumns), true);
  }

  /**
   *  Create a partial trajectory of States from a states table.<br>
   * The resulting StatesTrajectory will restore continuous state<br>
   * variable values, but not discrete state variable values, modeling<br>
   * option values, etc. Also, keep in mind that states files usually<br>
   * do not contain the state values to full precision, and thus cannot<br>
   * exactly reproduce results from the initial state trajectory. Lastly,<br>
   * this function optionally modifies each state to obey any constraints in<br>
   * the model (by calling Model::assemble()).<br>
   * <br>
   * The states in the resulting trajectory will be realized to<br>
   * SimTK::Stage::Instance. You should not use the resulting trajectory with<br>
   * an instance of the model other than the one you passed to this function<br>
   * (the state contains Instance-stage cache variables that are pointers to<br>
   * objects in the model; e.g., force elements).<br>
   * <br>
   * Note: The naming convention for state variables changed in OpenSim v4.0;<br>
   * `ankle_r/ankle_angle_r/speed` used to be `ankle_angle_r_u`,<br>
   * `soleus_r/activation` used to be `soleus_r.activation`, etc. This<br>
   * function can handle column labels that use the pre-v4.0 naming<br>
   * convention.<br>
   * <br>
   * @param model The Model to which the states belong. A Model is necessary<br>
   *      because the data file lists the state variables by name.<br>
   * @param table The table containing state values.<br>
   * <br>
   * <br>
   * <br>
   * <br>
   * Here is how you might use this function in python:<br>
   * {@code 
  import opensim
  model = opensim.Model("subject01.osim")
  table = opensim.TimeSeriesTable("subject01_states.sto")
  states = opensim.StatesTrajectory.createFromStatesTable(model, table)
  print(states[0].getTime())
  print(model.getStateVariableValue(states[0], "knee/flexion/value"))
  }<br>
   * <br>
   * @throws MissingColumns See the description of the<br>
   *      `allowMissingColumns` argument.<br>
   * <br>
   * @throws ExtraColumns See the description of the<br>
   *      `allowExtraColumns` argument.<br>
   * <br>
   * @throws NonUniqueLabels Thrown if multiple columns in<br>
   *      the table have the same name.<br>
   * <br>
   * @throws DataIsInDegrees Thrown if the table is in degrees<br>
   *      (inDegrees=yes); angular quantities must use radians to properly<br>
   *      create the trajectory.
   */
  public static StatesTrajectory createFromStatesTable(Model model, TimeSeriesTable table) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesTable__SWIG_3(Model.getCPtr(model), model, TimeSeriesTable.getCPtr(table), table), true);
  }

  /**
   *  Convenience form of createFromStatesStorage() that takes the path to a<br>
   * Storage file instead of a Storage object. This convenience form uses the<br>
   * default values for `allowMissingColumns` and `allowExtraColumns`. 
   */
  public static StatesTrajectory createFromStatesStorage(Model model, String filepath) {
    return new StatesTrajectory(opensimSimulationJNI.StatesTrajectory_createFromStatesStorage__SWIG_4(Model.getCPtr(model), model, filepath), true);
  }

}
