/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  The values of the variables in an optimal control problem.<br>
 * This can be used for specifying an initial guess, or holding the solution<br>
 * returned by a solver.<br>
 * <br>
 * A MocoTrajectory can be written to and read from an STO (".sto") file. The file<br>
 * format is comprised of a file header followed by a row of column names and the<br>
 * stored data. The file header contains the number of states, controls, Lagrange<br>
 * multipliers (for kinematic constraints), derivatives (non-zero if the dynamics<br>
 * mode is implicit), slacks (for special solver implementations), and parameters<br>
 * (order does not matter). Order does matter for the column names and<br>
 * corresponding data columns. The columns *must* follow this order: time, states,<br>
 * controls, multipliers, derivatives, slacks, parameters.<br>
 * Note: Slack columns may contain real number or NaN values, depending on their<br>
 * use. For example, values for velocity correction variables used in problems<br>
 * with model kinematic constraints are defined only at the midpoint of a Hermite-<br>
 * Simpson mesh interval. The non-midpoint variables are returned as NaN in the<br>
 * slack variable data structure.<br>
 * Note: For parameter columns, the value of the parameter is stored in<br>
 * the first row of the column, while the rest of the rows are filled with<br>
 * NaNs.<br>
 * <br>
 * num_controls=&lt;number-of-control-variables&gt;<br>
 * num_derivatives=&lt;number-of-derivative-variables&gt;<br>
 * num_multipliers=&lt;number-of-multiplier-variables&gt;<br>
 * num_parameters=&lt;number-of-parameter-variables&gt;<br>
 * num_slacks=&lt;number-of-slack-variables&gt;<br>
 * num_states=&lt;number-of-state-variables&gt;<br>
 * time,&lt;state-0-name&gt;,...,&lt;control-0-name&gt;,...,&lt;multiplier-0-name&gt;,..., <br>
 *         &lt;derivative-0-name&gt;,...,&lt;slack-0-name&gt;,...,&lt;parameter-0-name&gt;,...<br>
 * &lt;#&gt;,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#-or-NaN&gt;,...,&lt;#&gt;  ,...<br>
 * &lt;#&gt;,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#-or-NaN&gt;,...,&lt;NaN&gt;,...<br>
 *  : , : ,..., : ,..., : ,..., : ,...,    :     ,...,  :  ,...<br>
 * &lt;#&gt;,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#&gt;,...,&lt;#-or-NaN&gt;,...,&lt;NaN&gt;,...<br>
 * <br>
 * <br>
 * Column labels starting with "lambda" are Lagrange multipliers, and columns<br>
 * starting with "gamma" are slack variables (probably velocity corrections at<br>
 * certain collocation points).<br>
 * <br>
 * <p alt="Matlab and Python"><br>
 * Many of the functions in this class have variants ending with "Mat" that<br>
 * provide convenient access to the data directly in Matlab or Python (NumPy).<br>
 * In Python, the constructors can also accept NumPy matrices in addition to<br>
 * arguments of type SimTK::Matrix.<br>
 * {@code 
trajectory.getStateMat("<state-name>")
trajectory.getStatesTrajectoryMat()
}</p><br>
 * <br>
 * <p alt="Implicit dynamics model"><br>
 * If the solver uses an implicit dynamics mode, then there are "control"<br>
 * variables ("adjunct" variables in tropter's terminology) for the generalized<br>
 * accelerations. These are stored in the trajectory as derivative variables.</p><br>
 * <br>
 * <p alt="Sealed trajectories"><br>
 * If the trajectory is obtained as the failed solution to a problem,<br>
 * the trajectory will be sealed (MocoTrajectory::isSealed()), which means<br>
 * that you cannot do anything with the trajectory (read, edit, or write) until you<br>
 * call MocoTrajectory::unseal(). The sealing forces you to acknowledge that the<br>
 * solver failed.</p>
 */
public class MocoTrajectory {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public MocoTrajectory(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(MocoTrajectory obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimMocoJNI.delete_MocoTrajectory(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

    public void setTime(double[] time) {
        Vector v = new Vector();
        v.resize(time.length);
        for (int i = 0; i < time.length; ++i) { v.set(i, time[i]); }
        setTime(v);
    }
    public void setState(String name, double[] traj) {
        Vector v = new Vector();
        v.resize(traj.length);
        for (int i = 0; i < traj.length; ++i) { v.set(i, traj[i]); }
        setState(name, v);
    }
    public void setControl(String name, double[] traj) {
        Vector v = new Vector();
        v.resize(traj.length);
        for (int i = 0; i < traj.length; ++i) { v.set(i, traj[i]); }
        setControl(name, v);
    }
    public void setMultiplier(String name, double[] traj) {
        Vector v = new Vector();
        v.resize(traj.length);
        for (int i = 0; i < traj.length; ++i) { v.set(i, traj[i]); }
        setMultiplier(name, v);
    }
    public void setDerivative(String name, double[] traj) {
        Vector v = new Vector();
        v.resize(traj.length);
        for (int i = 0; i < traj.length; ++i) { v.set(i, traj[i]); }
        setDerivative(name, v);
    }
    public double[] getTimeMat() {
        Vector time = getTime();
        double[] ret = new double[time.size()];
        for (int i = 0; i < time.size(); ++i) { ret[i] = time.get(i); };
        return ret;
    }
    public double[] getStateMat(String name) {
        VectorView state = getState(name);
        double[] ret = new double[state.size()];
        for (int i = 0; i < state.size(); ++i) { ret[i] = state.get(i); };
        return ret;
    }
    public double[] getControlMat(String name) {
        VectorView control = getControl(name);
        double[] ret = new double[control.size()];
        for (int i = 0; i < control.size(); ++i) { ret[i] = control.get(i); };
        return ret;
    }
    public double[] getMultiplierMat(String name) {
        VectorView mult = getMultiplier(name);
        double[] ret = new double[mult.size()];
        for (int i = 0; i < mult.size(); ++i) { ret[i] = mult.get(i); };
        return ret;
    }
    public double[] getDerivativeMat(String name) {
        VectorView deriv = getDerivative(name);
        double[] ret = new double[deriv.size()];
        for (int i = 0; i < deriv.size(); ++i) { ret[i] = deriv.get(i); };
        return ret;
    }
    public double[] getParametersMat() {
        RowVector params = getParameters();
        double[] ret = new double[params.size()];
        for (int i = 0; i < params.size(); ++i) { ret[i] = params.get(i); };
        return ret;
    }
    public double[][] getStatesTrajectoryMat() {
        Matrix matrix = getStatesTrajectory();
        double[][] ret = new double[matrix.nrow()][matrix.ncol()];
        for (int i = 0; i < matrix.nrow(); ++i) {
            for (int j = 0; j < matrix.ncol(); ++j) {
                ret[i][j] = matrix.getElt(i, j);
            }
        }
        return ret;
    }
    public double[][] getControlsTrajectoryMat() {
        Matrix matrix = getControlsTrajectory();
        double[][] ret = new double[matrix.nrow()][matrix.ncol()];
        for (int i = 0; i < matrix.nrow(); ++i) {
            for (int j = 0; j < matrix.ncol(); ++j) {
                ret[i][j] = matrix.getElt(i, j);
            }
        }
        return ret;
    }
    public double[][] getMultipliersTrajectoryMat() {
        Matrix matrix = getMultipliersTrajectory();
        double[][] ret = new double[matrix.nrow()][matrix.ncol()];
        for (int i = 0; i < matrix.nrow(); ++i) {
            for (int j = 0; j < matrix.ncol(); ++j) {
                ret[i][j] = matrix.getElt(i, j);
            }
        }
        return ret;
    }
    public double[][] getDerivativesTrajectoryMat() {
        Matrix matrix = getDerivativesTrajectory();
        double[][] ret = new double[matrix.nrow()][matrix.ncol()];
        for (int i = 0; i < matrix.nrow(); ++i) {
            for (int j = 0; j < matrix.ncol(); ++j) {
                ret[i][j] = matrix.getElt(i, j);
            }
        }
        return ret;
    }

  public MocoTrajectory() {
    this(opensimMocoJNI.new_MocoTrajectory__SWIG_0(), true);
  }

  /**
   *  Create a trajectory with no data. To add data, use setNumTimes(),<br>
   *  setTime(), and the other setters.
   */
  public MocoTrajectory(StdVectorString state_names, StdVectorString control_names, StdVectorString multiplier_names, StdVectorString parameter_names) {
    this(opensimMocoJNI.new_MocoTrajectory__SWIG_1(StdVectorString.getCPtr(state_names), state_names, StdVectorString.getCPtr(control_names), control_names, StdVectorString.getCPtr(multiplier_names), multiplier_names, StdVectorString.getCPtr(parameter_names), parameter_names), true);
  }

  /**
   *  Create a trajectory (including columns for derivatives) with no data.<br>
   *  To add data, use setNumTimes(), setTime(), and the other setters.
   */
  public MocoTrajectory(StdVectorString state_names, StdVectorString control_names, StdVectorString multiplier_names, StdVectorString derivative_names, StdVectorString parameter_names) {
    this(opensimMocoJNI.new_MocoTrajectory__SWIG_2(StdVectorString.getCPtr(state_names), state_names, StdVectorString.getCPtr(control_names), control_names, StdVectorString.getCPtr(multiplier_names), multiplier_names, StdVectorString.getCPtr(derivative_names), derivative_names, StdVectorString.getCPtr(parameter_names), parameter_names), true);
  }

  public MocoTrajectory(Vector time, StdVectorString state_names, StdVectorString control_names, StdVectorString multiplier_names, StdVectorString parameter_names, Matrix statesTrajectory, Matrix controlsTrajectory, Matrix multipliersTrajectory, RowVector parameters) {
    this(opensimMocoJNI.new_MocoTrajectory__SWIG_3(Vector.getCPtr(time), time, StdVectorString.getCPtr(state_names), state_names, StdVectorString.getCPtr(control_names), control_names, StdVectorString.getCPtr(multiplier_names), multiplier_names, StdVectorString.getCPtr(parameter_names), parameter_names, Matrix.getCPtr(statesTrajectory), statesTrajectory, Matrix.getCPtr(controlsTrajectory), controlsTrajectory, Matrix.getCPtr(multipliersTrajectory), multipliersTrajectory, RowVector.getCPtr(parameters), parameters), true);
  }

  /**
   *  This constructor is for use with the implicit dynamics mode, and<br>
   *  allows specifying a derivativesTrajectory.
   */
  public MocoTrajectory(Vector time, StdVectorString state_names, StdVectorString control_names, StdVectorString multiplier_names, StdVectorString derivative_names, StdVectorString parameter_names, Matrix statesTrajectory, Matrix controlsTrajectory, Matrix multipliersTrajectory, Matrix derivativesTrajectory, RowVector parameters) {
    this(opensimMocoJNI.new_MocoTrajectory__SWIG_4(Vector.getCPtr(time), time, StdVectorString.getCPtr(state_names), state_names, StdVectorString.getCPtr(control_names), control_names, StdVectorString.getCPtr(multiplier_names), multiplier_names, StdVectorString.getCPtr(derivative_names), derivative_names, StdVectorString.getCPtr(parameter_names), parameter_names, Matrix.getCPtr(statesTrajectory), statesTrajectory, Matrix.getCPtr(controlsTrajectory), controlsTrajectory, Matrix.getCPtr(multipliersTrajectory), multipliersTrajectory, Matrix.getCPtr(derivativesTrajectory), derivativesTrajectory, RowVector.getCPtr(parameters), parameters), true);
  }

  /**
   *  Read a MocoTrajectory from an STO file (see STOFileAdapter). See output<br>
   *  of write() for the correct format.
   */
  public MocoTrajectory(String filepath) {
    this(opensimMocoJNI.new_MocoTrajectory__SWIG_5(filepath), true);
  }

  /**
   *  Returns a dynamically-allocated copy of this trajectory. You must manage<br>
   *  the memory for return value.<br>
   *  Note: This works even if the trajectory is sealed.
   */
  public MocoTrajectory clone() {
    long cPtr = opensimMocoJNI.MocoTrajectory_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new MocoTrajectory(cPtr, true);
  }

  public boolean empty() {
    return opensimMocoJNI.MocoTrajectory_empty(swigCPtr, this);
  }

  public boolean hasCoordinateStates() {
    return opensimMocoJNI.MocoTrajectory_hasCoordinateStates(swigCPtr, this);
  }

  /**
   *  <br>
   *  Resize the time vector and the time dimension of the states, controls,<br>
   *  multipliers, and derivatives trajectories, and set all times, states,<br>
   *  controls, multipliers, and derivatives to NaN.<br>
   *  Note: Parameters are NOT set to NaN.
   */
  public void setNumTimes(int numTimes) {
    opensimMocoJNI.MocoTrajectory_setNumTimes(swigCPtr, this, numTimes);
  }

  /**
   *  Uniformly resample (interpolate) the trajectory so that it retains the<br>
   *  same initial and final times but now has the provided number of time<br>
   *  points.<br>
   *  Resampling is done by creating a 5-th degree GCV spline of the states<br>
   *  and controls and evaluating the spline at the `numTimes` time points.<br>
   *  The degree is reduced as necessary if getNumTimes() &lt; 6, and<br>
   *  resampling is not possible if getNumTimes() &lt; 2.<br>
   *  @return the resulting time interval between time points.
   */
  public double resampleWithNumTimes(int numTimes) {
    return opensimMocoJNI.MocoTrajectory_resampleWithNumTimes(swigCPtr, this, numTimes);
  }

  /**
   *  Uniformly resample (interpolate) the trajectory to try to achieve the<br>
   *  provided time interval between mesh points, while preserving the<br>
   *  initial and final times. The resulting time interval may be shorter<br>
   *  than what you request (in order to preserve initial and<br>
   *  final times), and is returned by this function.<br>
   *  Resampling is done by creating a 5-th degree GCV spline of the states<br>
   *  and controls and evaluating the spline at the new time points.<br>
   *  The degree is reduced as necessary if getNumTimes() &lt; 6, and<br>
   *  resampling is not possible if getNumTimes() &lt; 2.
   */
  public double resampleWithInterval(double desiredTimeInterval) {
    return opensimMocoJNI.MocoTrajectory_resampleWithInterval(swigCPtr, this, desiredTimeInterval);
  }

  /**
   *  Uniformly resample (interpolate) the trajectory to try to achieve the<br>
   *  provided frequency of time points per second of the trajectory, while<br>
   *  preserving the initial and final times. The resulting frequency may be<br>
   *  higher than what you request (in order to preserve initial and final<br>
   *  times), and is returned by this function.<br>
   *  Resampling is done by creating a 5-th degree GCV spline of the states<br>
   *  and controls and evaluating the spline at the new time points.<br>
   *  The degree is reduced as necessary if getNumTimes() &lt; 6, and<br>
   *  resampling is not possible if getNumTimes() &lt; 2.
   */
  public double resampleWithFrequency(double desiredNumTimePointsPerSecond) {
    return opensimMocoJNI.MocoTrajectory_resampleWithFrequency(swigCPtr, this, desiredNumTimePointsPerSecond);
  }

  /**
   *  Resample (interpolate) the data in this trajectory at the provided<br>
   *  times. If all times have the same value (e.g., 0.0), then the value of<br>
   *  each variable for all time is its previous value at the initial time.<br>
   *  @throws Exception if new times are not within existing initial and final<br>
   *  times, if the new times are decreasing, or if getNumTimes() &lt; 2.
   */
  public void resample(Vector newTime) {
    opensimMocoJNI.MocoTrajectory_resample(swigCPtr, this, Vector.getCPtr(newTime), newTime);
  }

  /**
   *  <br>
   *  <br>
   *  Set the time vector. The provided vector must have the same number of<br>
   *  elements as the pre-existing time vector; use setNumTimes() or the<br>
   *  "resample..." functions to change the number of times.<br>
   *  Note: Using `setTime({5, 10})` uses the initializer list overload<br>
   *  below; it does *not* construct a 5-element vector with the value 10.
   */
  public void setTime(Vector time) {
    opensimMocoJNI.MocoTrajectory_setTime(swigCPtr, this, Vector.getCPtr(time), time);
  }

  /**
   *  Set the value of a single state variable across time. The provided<br>
   *  vector must have length getNumTimes().<br>
   *  Note: Using `setState(name, {5, 10})` uses the initializer list<br>
   *  overload below; it does *not* construct a 5-element vector with the<br>
   *  value 10.
   */
  public void setState(String name, Vector trajectory) {
    opensimMocoJNI.MocoTrajectory_setState(swigCPtr, this, name, Vector.getCPtr(trajectory), trajectory);
  }

  /**
   *  Set the value of a single control variable across time. The provided<br>
   *  vector must have length getNumTimes().<br>
   *  Note: Using `setControl(name, {5, 10})` uses the initializer list<br>
   *  overload below; it does *not* construct a 5-element vector with the<br>
   *  value 10.
   */
  public void setControl(String name, Vector trajectory) {
    opensimMocoJNI.MocoTrajectory_setControl(swigCPtr, this, name, Vector.getCPtr(trajectory), trajectory);
  }

  /**
   *  Set the value of a single Lagrange multiplier variable across time. The<br>
   *  provided vector must have length getNumTimes().<br>
   *  Note: Using `setMultiplier(name, {5, 10})` uses the initializer list<br>
   *  overload below; it does *not* construct a 5-element vector with the<br>
   *  value 10.
   */
  public void setMultiplier(String name, Vector trajectory) {
    opensimMocoJNI.MocoTrajectory_setMultiplier(swigCPtr, this, name, Vector.getCPtr(trajectory), trajectory);
  }

  /**
   *  Set the value of a single state derivative variable across time.<br>
   *  The provided vector must have length getNumTimes().<br>
   *  Note: Using `setDerivative(name, {5, 10})` uses the initializer list<br>
   *  overload below; it does *not* construct a 5-element vector with the<br>
   *  value 10.
   */
  public void setDerivative(String name, Vector trajectory) {
    opensimMocoJNI.MocoTrajectory_setDerivative(swigCPtr, this, name, Vector.getCPtr(trajectory), trajectory);
  }

  /**
   *  Set the value of a single parameter variable. This value is invariant<br>
   *  across time.
   */
  public void setParameter(String name, double value) {
    opensimMocoJNI.MocoTrajectory_setParameter(swigCPtr, this, name, value);
  }

  /**
   *  Set the states trajectory. The provided data is interpolated at the<br>
   *  times contained within this trajectory. The controls trajectory is not<br>
   *  altered. If the table only contains a subset of the states in the<br>
   *  trajectory (and allowMissingColumns is true), the unspecified states<br>
   *  preserve their pre-existing values.<br>
   * <br>
   *  This function might be helpful if you generate a guess using a<br>
   *  forward simulation; you can access the forward simulation's states<br>
   *  trajectory using Manager::getStateStorage() or<br>
   *  Manager::getStatesTable().<br>
   * <br>
   *  @param states<br>
   *      The column labels of the table should match the state<br>
   *      names (see getStateNames()). By default, the table must provide all<br>
   *      state variables. Any data outside the time range of this guess's<br>
   *      times are ignored.<br>
   *  @param allowMissingColumns<br>
   *      If false, an exception is thrown if there are states in the<br>
   *      trajectory that are not in the table.<br>
   *  @param allowExtraColumns<br>
   *      If false, an exception is thrown if there are states in the<br>
   *      table that are not in the trajectory.<br>
   *  @see createFromStatesControlsTables.
   */
  public void setStatesTrajectory(TimeSeriesTable states, boolean allowMissingColumns, boolean allowExtraColumns) {
    opensimMocoJNI.MocoTrajectory_setStatesTrajectory__SWIG_0(swigCPtr, this, TimeSeriesTable.getCPtr(states), states, allowMissingColumns, allowExtraColumns);
  }

  /**
   *  Set the states trajectory. The provided data is interpolated at the<br>
   *  times contained within this trajectory. The controls trajectory is not<br>
   *  altered. If the table only contains a subset of the states in the<br>
   *  trajectory (and allowMissingColumns is true), the unspecified states<br>
   *  preserve their pre-existing values.<br>
   * <br>
   *  This function might be helpful if you generate a guess using a<br>
   *  forward simulation; you can access the forward simulation's states<br>
   *  trajectory using Manager::getStateStorage() or<br>
   *  Manager::getStatesTable().<br>
   * <br>
   *  @param states<br>
   *      The column labels of the table should match the state<br>
   *      names (see getStateNames()). By default, the table must provide all<br>
   *      state variables. Any data outside the time range of this guess's<br>
   *      times are ignored.<br>
   *  @param allowMissingColumns<br>
   *      If false, an exception is thrown if there are states in the<br>
   *      trajectory that are not in the table.<br>
   *  @see createFromStatesControlsTables.
   */
  public void setStatesTrajectory(TimeSeriesTable states, boolean allowMissingColumns) {
    opensimMocoJNI.MocoTrajectory_setStatesTrajectory__SWIG_1(swigCPtr, this, TimeSeriesTable.getCPtr(states), states, allowMissingColumns);
  }

  /**
   *  Set the states trajectory. The provided data is interpolated at the<br>
   *  times contained within this trajectory. The controls trajectory is not<br>
   *  altered. If the table only contains a subset of the states in the<br>
   *  trajectory (and allowMissingColumns is true), the unspecified states<br>
   *  preserve their pre-existing values.<br>
   * <br>
   *  This function might be helpful if you generate a guess using a<br>
   *  forward simulation; you can access the forward simulation's states<br>
   *  trajectory using Manager::getStateStorage() or<br>
   *  Manager::getStatesTable().<br>
   * <br>
   *  @param states<br>
   *      The column labels of the table should match the state<br>
   *      names (see getStateNames()). By default, the table must provide all<br>
   *      state variables. Any data outside the time range of this guess's<br>
   *      times are ignored.<br>
   *  @see createFromStatesControlsTables.
   */
  public void setStatesTrajectory(TimeSeriesTable states) {
    opensimMocoJNI.MocoTrajectory_setStatesTrajectory__SWIG_2(swigCPtr, this, TimeSeriesTable.getCPtr(states), states);
  }

  /**
   *  Add additional state columns. The provided data are interpolated using<br>
   *  GCV splines to match the times in this trajectory. By default, we do not<br>
   *  overwrite data for states that already exist in the trajectory; you can<br>
   *  change this behavior with `overwrite`.
   */
  public void insertStatesTrajectory(TimeSeriesTable subsetOfStates, boolean overwrite) {
    opensimMocoJNI.MocoTrajectory_insertStatesTrajectory__SWIG_0(swigCPtr, this, TimeSeriesTable.getCPtr(subsetOfStates), subsetOfStates, overwrite);
  }

  /**
   *  Add additional state columns. The provided data are interpolated using<br>
   *  GCV splines to match the times in this trajectory. By default, we do not<br>
   *  overwrite data for states that already exist in the trajectory; you can<br>
   *  change this behavior with `overwrite`.
   */
  public void insertStatesTrajectory(TimeSeriesTable subsetOfStates) {
    opensimMocoJNI.MocoTrajectory_insertStatesTrajectory__SWIG_1(swigCPtr, this, TimeSeriesTable.getCPtr(subsetOfStates), subsetOfStates);
  }

  /**
   *  Add additional control columns. The provided data are interpolated using<br>
   *  GCV splines to match the times in this trajectory. By default, we do not<br>
   *  overwrite data for controls that already exist in the trajectory; you<br>
   *  can change this behavior with `overwrite`.
   */
  public void insertControlsTrajectory(TimeSeriesTable subsetOfControls, boolean overwrite) {
    opensimMocoJNI.MocoTrajectory_insertControlsTrajectory__SWIG_0(swigCPtr, this, TimeSeriesTable.getCPtr(subsetOfControls), subsetOfControls, overwrite);
  }

  /**
   *  Add additional control columns. The provided data are interpolated using<br>
   *  GCV splines to match the times in this trajectory. By default, we do not<br>
   *  overwrite data for controls that already exist in the trajectory; you<br>
   *  can change this behavior with `overwrite`.
   */
  public void insertControlsTrajectory(TimeSeriesTable subsetOfControls) {
    opensimMocoJNI.MocoTrajectory_insertControlsTrajectory__SWIG_1(swigCPtr, this, TimeSeriesTable.getCPtr(subsetOfControls), subsetOfControls);
  }

  /**
   *  Compute coordinate speeds based on coordinate position values and append<br>
   *  to the trajectory. Coordinate values must exist in the original<br>
   *  trajectory.<br>
   *  Note: Overrides any existing speed values in the trajectory.
   */
  public void generateSpeedsFromValues() {
    opensimMocoJNI.MocoTrajectory_generateSpeedsFromValues(swigCPtr, this);
  }

  /**
   *  Compute coordinate accelerations based on coordinate position values and<br>
   *  append to the trajectory. Coordinate values must exist in the original<br>
   *  trajectory.<br>
   *  Note: Overrides any existing acceleration values in the trajectory.
   */
  public void generateAccelerationsFromValues() {
    opensimMocoJNI.MocoTrajectory_generateAccelerationsFromValues(swigCPtr, this);
  }

  /**
   *  Compute coordinate accelerations based on coordinate speeds and append<br>
   *  to the trajectory. Coordinate speeds must exist in the original<br>
   *  trajectory.<br>
   *  Note: Overrides any existing acceleration values in the trajectory.
   */
  public void generateAccelerationsFromSpeeds() {
    opensimMocoJNI.MocoTrajectory_generateAccelerationsFromSpeeds(swigCPtr, this);
  }

  /**
   *  <br>
   *  
   */
  public int getNumTimes() {
    return opensimMocoJNI.MocoTrajectory_getNumTimes(swigCPtr, this);
  }

  public Vector getTime() {
    return new Vector(opensimMocoJNI.MocoTrajectory_getTime(swigCPtr, this), false);
  }

  /**
   *  The first time in the time vector.<br>
   *  @throws Exception If numTimes is 0.
   */
  public double getInitialTime() {
    return opensimMocoJNI.MocoTrajectory_getInitialTime(swigCPtr, this);
  }

  /**
   *  The last time in the time vector.<br>
   *  @throws Exception If numTimes is 0.
   */
  public double getFinalTime() {
    return opensimMocoJNI.MocoTrajectory_getFinalTime(swigCPtr, this);
  }

  public int getNumStates() {
    return opensimMocoJNI.MocoTrajectory_getNumStates(swigCPtr, this);
  }

  public int getNumControls() {
    return opensimMocoJNI.MocoTrajectory_getNumControls(swigCPtr, this);
  }

  public int getNumMultipliers() {
    return opensimMocoJNI.MocoTrajectory_getNumMultipliers(swigCPtr, this);
  }

  public int getNumDerivatives() {
    return opensimMocoJNI.MocoTrajectory_getNumDerivatives(swigCPtr, this);
  }

  public int getNumParameters() {
    return opensimMocoJNI.MocoTrajectory_getNumParameters(swigCPtr, this);
  }

  public StdVectorString getStateNames() {
    return new StdVectorString(opensimMocoJNI.MocoTrajectory_getStateNames(swigCPtr, this), false);
  }

  public StdVectorString getControlNames() {
    return new StdVectorString(opensimMocoJNI.MocoTrajectory_getControlNames(swigCPtr, this), false);
  }

  public StdVectorString getMultiplierNames() {
    return new StdVectorString(opensimMocoJNI.MocoTrajectory_getMultiplierNames(swigCPtr, this), false);
  }

  public StdVectorString getDerivativeNames() {
    return new StdVectorString(opensimMocoJNI.MocoTrajectory_getDerivativeNames(swigCPtr, this), false);
  }

  public StdVectorString getParameterNames() {
    return new StdVectorString(opensimMocoJNI.MocoTrajectory_getParameterNames(swigCPtr, this), false);
  }

  public VectorView getState(String name) {
    return new VectorView(opensimMocoJNI.MocoTrajectory_getState(swigCPtr, this, name), true);
  }

  public VectorView getControl(String name) {
    return new VectorView(opensimMocoJNI.MocoTrajectory_getControl(swigCPtr, this, name), true);
  }

  public VectorView getMultiplier(String name) {
    return new VectorView(opensimMocoJNI.MocoTrajectory_getMultiplier(swigCPtr, this, name), true);
  }

  public VectorView getDerivative(String name) {
    return new VectorView(opensimMocoJNI.MocoTrajectory_getDerivative(swigCPtr, this, name), true);
  }

  public double getParameter(String name) {
    return opensimMocoJNI.MocoTrajectory_getParameter(swigCPtr, this, name);
  }

  public Matrix getStatesTrajectory() {
    return new Matrix(opensimMocoJNI.MocoTrajectory_getStatesTrajectory(swigCPtr, this), false);
  }

  public Matrix getControlsTrajectory() {
    return new Matrix(opensimMocoJNI.MocoTrajectory_getControlsTrajectory(swigCPtr, this), false);
  }

  public Matrix getMultipliersTrajectory() {
    return new Matrix(opensimMocoJNI.MocoTrajectory_getMultipliersTrajectory(swigCPtr, this), false);
  }

  public Matrix getDerivativesTrajectory() {
    return new Matrix(opensimMocoJNI.MocoTrajectory_getDerivativesTrajectory(swigCPtr, this), false);
  }

  public RowVector getParameters() {
    return new RowVector(opensimMocoJNI.MocoTrajectory_getParameters(swigCPtr, this), false);
  }

  /**
   *  <br>
   *  <br>
   *  Do the state, control, multiplier, derivative, and parameter names in<br>
   *  this trajectory match those in the problem? This may not catch all<br>
   *  possible incompatibilities. If the trajectory should have generalized<br>
   *  accelerations (for implicit multibody dynamics mode), set<br>
   *  requireAccelerations to true.<br>
   *  To throw an exception with a detailed message if the problem is not<br>
   *  compatible, pass throwOnError as true. To get the detailed message<br>
   *  without an exception, set the Logger level to Debug or a more verbose<br>
   *  setting (e.g., `Logger::setLevel(Logger::Level::Debug)` in C++, and<br>
   *  `Logger.setLevel(Logger.Level_Debug)` in MATLAB/Python).
   */
  public boolean isCompatible(MocoProblemRep arg0, boolean requireAccelerations, boolean throwOnError) {
    return opensimMocoJNI.MocoTrajectory_isCompatible__SWIG_0(swigCPtr, this, MocoProblemRep.getCPtr(arg0), arg0, requireAccelerations, throwOnError);
  }

  /**
   *  <br>
   *  <br>
   *  Do the state, control, multiplier, derivative, and parameter names in<br>
   *  this trajectory match those in the problem? This may not catch all<br>
   *  possible incompatibilities. If the trajectory should have generalized<br>
   *  accelerations (for implicit multibody dynamics mode), set<br>
   *  requireAccelerations to true.<br>
   *  To throw an exception with a detailed message if the problem is not<br>
   *  compatible, pass throwOnError as true. To get the detailed message<br>
   *  without an exception, set the Logger level to Debug or a more verbose<br>
   *  setting (e.g., `Logger::setLevel(Logger::Level::Debug)` in C++, and<br>
   *  `Logger.setLevel(Logger.Level_Debug)` in MATLAB/Python).
   */
  public boolean isCompatible(MocoProblemRep arg0, boolean requireAccelerations) {
    return opensimMocoJNI.MocoTrajectory_isCompatible__SWIG_1(swigCPtr, this, MocoProblemRep.getCPtr(arg0), arg0, requireAccelerations);
  }

  /**
   *  <br>
   *  <br>
   *  Do the state, control, multiplier, derivative, and parameter names in<br>
   *  this trajectory match those in the problem? This may not catch all<br>
   *  possible incompatibilities. If the trajectory should have generalized<br>
   *  accelerations (for implicit multibody dynamics mode), set<br>
   *  requireAccelerations to true.<br>
   *  To throw an exception with a detailed message if the problem is not<br>
   *  compatible, pass throwOnError as true. To get the detailed message<br>
   *  without an exception, set the Logger level to Debug or a more verbose<br>
   *  setting (e.g., `Logger::setLevel(Logger::Level::Debug)` in C++, and<br>
   *  `Logger.setLevel(Logger.Level_Debug)` in MATLAB/Python).
   */
  public boolean isCompatible(MocoProblemRep arg0) {
    return opensimMocoJNI.MocoTrajectory_isCompatible__SWIG_2(swigCPtr, this, MocoProblemRep.getCPtr(arg0), arg0);
  }

  /**
   *  Check if this trajectory is numerically equal to another trajectory.<br>
   *  This uses SimTK::Test::numericallyEqual() internally.<br>
   *  Accordingly, the tolerance is both a relative and absolute tolerance<br>
   *  (depending on the magnitude of quantities being compared).
   */
  public boolean isNumericallyEqual(MocoTrajectory other, double tol) {
    return opensimMocoJNI.MocoTrajectory_isNumericallyEqual__SWIG_0(swigCPtr, this, MocoTrajectory.getCPtr(other), other, tol);
  }

  /**
   *  Check if this trajectory is numerically equal to another trajectory.<br>
   *  This uses SimTK::Test::numericallyEqual() internally.<br>
   *  Accordingly, the tolerance is both a relative and absolute tolerance<br>
   *  (depending on the magnitude of quantities being compared).
   */
  public boolean isNumericallyEqual(MocoTrajectory other) {
    return opensimMocoJNI.MocoTrajectory_isNumericallyEqual__SWIG_1(swigCPtr, this, MocoTrajectory.getCPtr(other), other);
  }

  /**
   *  Compute the root-mean-square error between the continuous variables of<br>
   *  this trajectory and another. The RMS is computed by numerically<br>
   *  integrating the sum of squared error across<br>
   *  states,<br>
   *  controls,<br>
   *  Lagrange multipliers, and<br>
   *  derivatives and dividing by the number of columns and the time duration.<br>
   *  The calculation can be expressed as follows:<br>
   *   
       \epsilon_{\textrm{RMS}} =
       \sqrt{\frac{1}{N(t_f - t_i)} \int_{t_i}^{t_f} \left(
           \sum_{ i \in \textrm{states} } \epsilon_i(t)^2 +
           \sum_{ i \in \textrm{controls} } \epsilon_i(t)^2 +
           \sum_{ i \in \textrm{mult} } \epsilon_i(t)^2 +
           \sum_{ i \in \textrm{deriv} } \epsilon_i(t)^2
       \right) dt  },
   <br>
   *  where   N  is the number of columns,   t_i  is the minimum of<br>
   *  the two initial times,   t_f  is the maximum of the two final<br>
   *  times, and   \epsilon  indicates an error.<br>
   * <br>
   *  When the two trajectories do not cover the same time range, we assume<br>
   *  values of 0 for the trajectory with "missing" time (we do NOT assume<br>
   *  that the error is 0 over the non-overlapping time range).<br>
   * <br>
   *  First, the trajectories are splined and sampled. The number of sampling<br>
   *  points is taken to be the number of times in the trajectory with the<br>
   *  greater number of times. Numerical integration is performed on the<br>
   *  sampled points using the trapezoidal rule.<br>
   * <br>
   *  By default, all states, controls, and multipliers are<br>
   *  compared, and it is expected that both trajectories have the same<br>
   *  states, controls, and multipliers. Alternatively, you can specify the<br>
   *  specific<br>
   *  states,<br>
   *  controls,<br>
   *  multipliers, and<br>
   *  derivatives to compare as keys for `columnsToUse`.<br>
   *  Values are an empty vector to compare all columns for that key,<br>
   *  `{"none"}` (single-entry vector with value "none") to compare none of<br>
   *  the columns for that key, or a vector of column labels to compare<br>
   *  for that key. Leaving out a key means no columns for that<br>
   *  key are compared.<br>
   *  Both trajectories must have at least 6 time nodes.<br>
   *  If the number of columns to compare is 0, this returns 0.
   */
  public double compareContinuousVariablesRMS(MocoTrajectory other, SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t columnsToUse) {
    return opensimMocoJNI.MocoTrajectory_compareContinuousVariablesRMS__SWIG_0(swigCPtr, this, MocoTrajectory.getCPtr(other), other, SWIGTYPE_p_std__mapT_std__string_std__vectorT_std__string_t_std__lessT_std__string_t_t.getCPtr(columnsToUse));
  }

  /**
   *  Compute the root-mean-square error between the continuous variables of<br>
   *  this trajectory and another. The RMS is computed by numerically<br>
   *  integrating the sum of squared error across<br>
   *  states,<br>
   *  controls,<br>
   *  Lagrange multipliers, and<br>
   *  derivatives and dividing by the number of columns and the time duration.<br>
   *  The calculation can be expressed as follows:<br>
   *   
       \epsilon_{\textrm{RMS}} =
       \sqrt{\frac{1}{N(t_f - t_i)} \int_{t_i}^{t_f} \left(
           \sum_{ i \in \textrm{states} } \epsilon_i(t)^2 +
           \sum_{ i \in \textrm{controls} } \epsilon_i(t)^2 +
           \sum_{ i \in \textrm{mult} } \epsilon_i(t)^2 +
           \sum_{ i \in \textrm{deriv} } \epsilon_i(t)^2
       \right) dt  },
   <br>
   *  where   N  is the number of columns,   t_i  is the minimum of<br>
   *  the two initial times,   t_f  is the maximum of the two final<br>
   *  times, and   \epsilon  indicates an error.<br>
   * <br>
   *  When the two trajectories do not cover the same time range, we assume<br>
   *  values of 0 for the trajectory with "missing" time (we do NOT assume<br>
   *  that the error is 0 over the non-overlapping time range).<br>
   * <br>
   *  First, the trajectories are splined and sampled. The number of sampling<br>
   *  points is taken to be the number of times in the trajectory with the<br>
   *  greater number of times. Numerical integration is performed on the<br>
   *  sampled points using the trapezoidal rule.<br>
   * <br>
   *  By default, all states, controls, and multipliers are<br>
   *  compared, and it is expected that both trajectories have the same<br>
   *  states, controls, and multipliers. Alternatively, you can specify the<br>
   *  specific<br>
   *  states,<br>
   *  controls,<br>
   *  multipliers, and<br>
   *  derivatives to compare as keys for `columnsToUse`.<br>
   *  Values are an empty vector to compare all columns for that key,<br>
   *  `{"none"}` (single-entry vector with value "none") to compare none of<br>
   *  the columns for that key, or a vector of column labels to compare<br>
   *  for that key. Leaving out a key means no columns for that<br>
   *  key are compared.<br>
   *  Both trajectories must have at least 6 time nodes.<br>
   *  If the number of columns to compare is 0, this returns 0.
   */
  public double compareContinuousVariablesRMS(MocoTrajectory other) {
    return opensimMocoJNI.MocoTrajectory_compareContinuousVariablesRMS__SWIG_1(swigCPtr, this, MocoTrajectory.getCPtr(other), other);
  }

  /**
   *  This is an alternative interface for compareContinuousVariablesRMS()<br>
   *  that uses regular expression patterns to select columns. The parameter<br>
   *  columnType is "states", "controls", "multipliers", or "derivatives".<br>
   *  All columns for the provided column type whose entire name matches the<br>
   *  provided regular expression are included in the root-mean-square.
   */
  public double compareContinuousVariablesRMSPattern(MocoTrajectory other, String columnType, String pattern) {
    return opensimMocoJNI.MocoTrajectory_compareContinuousVariablesRMSPattern(swigCPtr, this, MocoTrajectory.getCPtr(other), other, columnType, pattern);
  }

  /**
   *  Compute the root-mean-square error between the parameters in this<br>
   *  trajectory and another. The RMS is computed by dividing the sum of<br>
   *  the squared errors between corresponding parameters and then dividing by<br>
   *  the number of parameters compared.<br>
   *  By default, all parameters are compared, and it is expected that both<br>
   *  trajectories have the same parameters. Alternatively, you can specify<br>
   *  the specific parameters to compare.
   */
  public double compareParametersRMS(MocoTrajectory other, StdVectorString parameterNames) {
    return opensimMocoJNI.MocoTrajectory_compareParametersRMS__SWIG_0(swigCPtr, this, MocoTrajectory.getCPtr(other), other, StdVectorString.getCPtr(parameterNames), parameterNames);
  }

  /**
   *  Compute the root-mean-square error between the parameters in this<br>
   *  trajectory and another. The RMS is computed by dividing the sum of<br>
   *  the squared errors between corresponding parameters and then dividing by<br>
   *  the number of parameters compared.<br>
   *  By default, all parameters are compared, and it is expected that both<br>
   *  trajectories have the same parameters. Alternatively, you can specify<br>
   *  the specific parameters to compare.
   */
  public double compareParametersRMS(MocoTrajectory other) {
    return opensimMocoJNI.MocoTrajectory_compareParametersRMS__SWIG_1(swigCPtr, this, MocoTrajectory.getCPtr(other), other);
  }

  /**
   *  <br>
   *  <br>
   *  Save the trajectory to a STO file. Use the ."sto" file extension.
   */
  public void write(String filepath) {
    opensimMocoJNI.MocoTrajectory_write(swigCPtr, this, filepath);
  }

  /**
   *  This table can be saved as a Storage file that can be used in the<br>
   *  OpenSim GUI to visualize a motion, or as input to OpenSim's conventional<br>
   *  tools (e.g., AnalyzeTool).<br>
   * <br>
   *  Controls are not carried over to the states storage.
   */
  public TimeSeriesTable exportToStatesTable() {
    return new TimeSeriesTable(opensimMocoJNI.MocoTrajectory_exportToStatesTable(swigCPtr, this), true);
  }

  /**
   *  Export the controls trajectory to a TimeSeriesTable.
   */
  public TimeSeriesTable exportToControlsTable() {
    return new TimeSeriesTable(opensimMocoJNI.MocoTrajectory_exportToControlsTable(swigCPtr, this), true);
  }

  /**
   *  Controls are not carried over to the StatesTrajectory.<br>
   *  The MocoProblem is necessary because we need the underlying Model to<br>
   *  order the state variables correctly.
   */
  public StatesTrajectory exportToStatesTrajectory(MocoProblem arg0) {
    return new StatesTrajectory(opensimMocoJNI.MocoTrajectory_exportToStatesTrajectory__SWIG_0(swigCPtr, this, MocoProblem.getCPtr(arg0), arg0), true);
  }

  /**
   *  This is similar to the above function but requires only a model, not<br>
   *  a MocoProblem.
   */
  public StatesTrajectory exportToStatesTrajectory(Model arg0) {
    return new StatesTrajectory(opensimMocoJNI.MocoTrajectory_exportToStatesTrajectory__SWIG_1(swigCPtr, this, Model.getCPtr(arg0), arg0), true);
  }

  /**
   *  <br>
   *  <br>
   *  Randomize all data except time using the provided random number<br>
   *  generator. All data is replaced with the random numbers. Use this to<br>
   *  create a completely (pseudo-)random trajectory, probably for a<br>
   *  MocoSolver guess.<br>
   *  The default random number generator samples uniformly within [-0.1,<br>
   *  0.1].
   */
  public void randomizeReplace(SWIGTYPE_p_SimTK__Random randGen) {
    opensimMocoJNI.MocoTrajectory_randomizeReplace__SWIG_0(swigCPtr, this, SWIGTYPE_p_SimTK__Random.getCPtr(randGen));
  }

  /**
   *  <br>
   *  <br>
   *  Randomize all data except time using the provided random number<br>
   *  generator. All data is replaced with the random numbers. Use this to<br>
   *  create a completely (pseudo-)random trajectory, probably for a<br>
   *  MocoSolver guess.<br>
   *  The default random number generator samples uniformly within [-0.1,<br>
   *  0.1].
   */
  public void randomizeReplace() {
    opensimMocoJNI.MocoTrajectory_randomizeReplace__SWIG_1(swigCPtr, this);
  }

  /**
   *  Randomize all data except time using the provided random number<br>
   *  generator. The random numbers are added to the existing data. Use this<br>
   *  to perturb an existing solution, probably for a MocoSolver guess.<br>
   *  The default random number generator samples uniformly within [-0.1,<br>
   *  0.1].
   */
  public void randomizeAdd(SWIGTYPE_p_SimTK__Random randGen) {
    opensimMocoJNI.MocoTrajectory_randomizeAdd__SWIG_0(swigCPtr, this, SWIGTYPE_p_SimTK__Random.getCPtr(randGen));
  }

  /**
   *  Randomize all data except time using the provided random number<br>
   *  generator. The random numbers are added to the existing data. Use this<br>
   *  to perturb an existing solution, probably for a MocoSolver guess.<br>
   *  The default random number generator samples uniformly within [-0.1,<br>
   *  0.1].
   */
  public void randomizeAdd() {
    opensimMocoJNI.MocoTrajectory_randomizeAdd__SWIG_1(swigCPtr, this);
  }

  /**
   *  <br>
   *  <br>
   *  (Experimental) Create a trajectory from a states trajectory and controls<br>
   *  trajectory (i.e, from Manager::getStatesTable() and<br>
   *  Model::getControlsTable()). The time columns from the two tables must<br>
   *  match exactly. The times in the trajectory will be those from the<br>
   *  tables. This does not (yet) handle parameters.
   */
  public static MocoTrajectory createFromStatesControlsTables(MocoProblemRep arg0, TimeSeriesTable statesTrajectory, TimeSeriesTable controlsTrajectory) {
    return new MocoTrajectory(opensimMocoJNI.MocoTrajectory_createFromStatesControlsTables(MocoProblemRep.getCPtr(arg0), arg0, TimeSeriesTable.getCPtr(statesTrajectory), statesTrajectory, TimeSeriesTable.getCPtr(controlsTrajectory), controlsTrajectory), true);
  }

}
