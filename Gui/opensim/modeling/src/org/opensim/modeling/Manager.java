/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * A class that manages the execution of a simulation. This class uses a<br>
 * SimTK::Integrator and SimTK::TimeStepper to perform the simulation. By<br>
 * default, a Runge-Kutta-Merson integrator is used, but can be changed by<br>
 * using setIntegratorMethod().<br>
 * <br>
 * In order to prevent an inconsistency between the Integrator and TimeStepper,<br>
 * we only create a TimeStepper once, specifically when we call<br>
 * initialize(). To ensure this, the Manager will throw<br>
 * an exception if initialize() is called more than once. Note<br>
 * that editing the SimTK::State after calling initialize()<br>
 * will not affect the simulation.<br>
 * <br>
 * Note that this interface means that you cannot "reinitialize" a Manager.<br>
 * If you make changes to the SimTK::State, a new Manager must be created<br>
 * before integrating again.
 */
public class Manager {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public Manager(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(Manager obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_Manager(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Constructor that takes a model only and internally uses a<br>
   * SimTK::RungeKuttaMersonIntegrator with default settings (accuracy,<br>
   * constraint tolerance, etc.). 
   */
  public Manager(Model model) {
    this(opensimSimulationJNI.new_Manager__SWIG_0(Model.getCPtr(model), model), true);
  }

  /**
   *  Convenience constructor for creating and initializing a Manager (by<br>
   * calling initialize()).<br>
   * Do not use this constructor if you intend to change integrator settings;<br>
   * changes to the integrator may not take effect after initializing. 
   */
  public Manager(Model model, State state) {
    this(opensimSimulationJNI.new_Manager__SWIG_1(Model.getCPtr(model), model, State.getCPtr(state), state), true);
  }

  /**
   *  <b>(Deprecated)</b> A Constructor that does not take a model or<br>
   * controllerSet. This constructor also does not set an integrator; you<br>
   * must call setIntegrator() on your own. You should use one of the other<br>
   * constructors. 
   */
  public Manager() {
    this(opensimSimulationJNI.new_Manager__SWIG_2(), true);
  }

  public void setSessionName(String name) {
    opensimSimulationJNI.Manager_setSessionName(swigCPtr, this, name);
  }

  public void setModel(Model model) {
    opensimSimulationJNI.Manager_setModel(swigCPtr, this, Model.getCPtr(model), model);
  }

  public String getSessionName() {
    return opensimSimulationJNI.Manager_getSessionName(swigCPtr, this);
  }

  public String toString() {
    return opensimSimulationJNI.Manager_toString(swigCPtr, this);
  }

  public void setPerformAnalyses(boolean performAnalyses) {
    opensimSimulationJNI.Manager_setPerformAnalyses(swigCPtr, this, performAnalyses);
  }

  public void setWriteToStorage(boolean writeToStorage) {
    opensimSimulationJNI.Manager_setWriteToStorage(swigCPtr, this, writeToStorage);
  }

  /**
   *  Sets the integrator method used via IntegratorMethod enum. The <br>
   * integrator will be set to its default options, even if the caller<br>
   * requests the same integrator method. Note that this function must<br>
   * be called before `Manager::initialize()`.<br>
   * <br>
   *       <b>C++ example</b><br>
   *       {@code 
        auto manager = Manager(model);
        manager.setIntegratorMethod(Manager::IntegratorMethod::SemiExplicitEuler2);
        }<br>
   * <br>
   *       <b>Python example</b><br>
   *       {@code 
        import opensim
        manager = opensim.Manager(model)
        manager.setIntegratorMethod(opensim.Manager.IntegratorMethod_SemiExplicitEuler2)
        }<br>
   * <br>
   *       <b>MATLAB example</b><br>
   *       {@code 
        import org.opensim.modeling.*
        manager = Manager(model);
        manager.setIntegratorMethod(5);
        }
   */
  public void setIntegratorMethod(Manager.IntegratorMethod integMethod) {
    opensimSimulationJNI.Manager_setIntegratorMethod(swigCPtr, this, integMethod.swigValue());
  }

  public SWIGTYPE_p_SimTK__Integrator getIntegrator() {
    return new SWIGTYPE_p_SimTK__Integrator(opensimSimulationJNI.Manager_getIntegrator(swigCPtr, this), false);
  }

  /**
   *  Sets the accuracy of the integrator. <br>
   * For more details, see `SimTK::Integrator::setAccuracy(SimTK::Real)`. 
   */
  public void setIntegratorAccuracy(double accuracy) {
    opensimSimulationJNI.Manager_setIntegratorAccuracy(swigCPtr, this, accuracy);
  }

  /**
   *  Sets the minimum step size of the integrator.<br>
   * For more details, see `SimTK::Integrator::setMinimumStepSize(SimTK::Real)`. 
   */
  public void setIntegratorMinimumStepSize(double hmin) {
    opensimSimulationJNI.Manager_setIntegratorMinimumStepSize(swigCPtr, this, hmin);
  }

  /**
   *  Sets the maximum step size of the integrator.<br>
   * For more details, see `SimTK::Integrator::setMaximumStepSize(SimTK::Real)`. 
   */
  public void setIntegratorMaximumStepSize(double hmax) {
    opensimSimulationJNI.Manager_setIntegratorMaximumStepSize(swigCPtr, this, hmax);
  }

  /**
   *  Sets the limit of steps the integrator can take per call of `stepTo()`.<br>
   * Note that Manager::integrate() calls `stepTo()` for each interval when a fixed<br>
   * step size is used.<br>
   * For more details, see SimTK::Integrator::setInternalStepLimit(int). 
   */
  public void setIntegratorInternalStepLimit(int nSteps) {
    opensimSimulationJNI.Manager_setIntegratorInternalStepLimit(swigCPtr, this, nSteps);
  }

  /**
   *  
   */
  public void setUseSpecifiedDT(boolean aTrueFalse) {
    opensimSimulationJNI.Manager_setUseSpecifiedDT(swigCPtr, this, aTrueFalse);
  }

  public boolean getUseSpecifiedDT() {
    return opensimSimulationJNI.Manager_getUseSpecifiedDT(swigCPtr, this);
  }

  public void setUseConstantDT(boolean aTrueFalse) {
    opensimSimulationJNI.Manager_setUseConstantDT(swigCPtr, this, aTrueFalse);
  }

  public boolean getUseConstantDT() {
    return opensimSimulationJNI.Manager_getUseConstantDT(swigCPtr, this);
  }

  public ArrayDouble getDTArray() {
    return new ArrayDouble(opensimSimulationJNI.Manager_getDTArray(swigCPtr, this), false);
  }

  public void setDTArray(Vector aDT, double aTI) {
    opensimSimulationJNI.Manager_setDTArray__SWIG_0(swigCPtr, this, Vector.getCPtr(aDT), aDT, aTI);
  }

  public void setDTArray(Vector aDT) {
    opensimSimulationJNI.Manager_setDTArray__SWIG_1(swigCPtr, this, Vector.getCPtr(aDT), aDT);
  }

  public double getDTArrayDT(int aStep) {
    return opensimSimulationJNI.Manager_getDTArrayDT(swigCPtr, this, aStep);
  }

  public void printDTArray(String aFileName) {
    opensimSimulationJNI.Manager_printDTArray__SWIG_0(swigCPtr, this, aFileName);
  }

  public void printDTArray() {
    opensimSimulationJNI.Manager_printDTArray__SWIG_1(swigCPtr, this);
  }

  public ArrayDouble getTimeArray() {
    return new ArrayDouble(opensimSimulationJNI.Manager_getTimeArray(swigCPtr, this), false);
  }

  public double getTimeArrayTime(int aStep) {
    return opensimSimulationJNI.Manager_getTimeArrayTime(swigCPtr, this, aStep);
  }

  public int getTimeArrayStep(double aTime) {
    return opensimSimulationJNI.Manager_getTimeArrayStep(swigCPtr, this, aTime);
  }

  public void printTimeArray(String aFileName) {
    opensimSimulationJNI.Manager_printTimeArray__SWIG_0(swigCPtr, this, aFileName);
  }

  public void printTimeArray() {
    opensimSimulationJNI.Manager_printTimeArray__SWIG_1(swigCPtr, this);
  }

  public void resetTimeAndDTArrays(double aTime) {
    opensimSimulationJNI.Manager_resetTimeAndDTArrays(swigCPtr, this, aTime);
  }

  public double getNextTimeArrayTime(double aTime) {
    return opensimSimulationJNI.Manager_getNextTimeArrayTime(swigCPtr, this, aTime);
  }

  /**
   * Initializes the Manager by creating and initializing the underlying <br>
   * SimTK::TimeStepper. This must be called before calling <br>
   * Manager::integrate() Subsequent changes to the State object passed in <br>
   * here will not affect the simulation. Calling this function multiple <br>
   * times with the same Manager will trigger an Exception.<br>
   * <br>
   * Changes to the integrator (e.g., setIntegratorAccuracy()) after calling<br>
   * initialize() may not have any effect.
   */
  public void initialize(State s) {
    opensimSimulationJNI.Manager_initialize(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   * Integrate the equations of motion for the specified model, given the current<br>
   * state (at which the integration will start) and a finalTime. You must call<br>
   * Manager::initialize() before calling this function.<br>
   * <br>
   * If you must update states or controls in a loop, you must recreate the <br>
   * manager within the loop (such discontinuous changes are considered "events"<br>
   * and cannot be handled during integration of the otherwise continuous system).<br>
   * The proper way to handle this situation is to create a SimTK::EventHandler.<br>
   * <br>
   * Example: Integrating from time = 1s to time = 2s<br>
   * {@code 
  SimTK::State state = model.initSystem();
  Manager manager(model);
  state.setTime(1.0);
  manager.initialize(state);
  state = manager.integrate(2.0);
  }<br>
   * <br>
   * Example: Integrating from time = 1s to time = 2s using the<br>
   *          convenience constructor<br>
   * {@code 
  SimTK::State state = model.initSystem();
  state.setTime(1.0);
  Manager manager(model, state);
  state = manager.integrate(2.0);
  }<br>
   * <br>
   * Example: Integrate from time = 0s to time = 10s, in 2s increments<br>
   * {@code 
  dTime = 2.0;
  finalTime = 10.0;
  int n = int(round(finalTime/dTime));
  state.setTime(0.0);
  manager.initialize(state);
  for (int i = 1; i <= n; ++i) {
      state = manager.integrate(i*dTime);
  }
  }<br>
   * <br>
   * Example: Integrate from time = 0s to time = 10s, updating the state<br>
   *          (e.g., the model's first coordinate value) every 2s<br>
   * {@code 
  dTime = 2.0;
  finalTime = 10.0;
  int n = int(round(finalTime/dTime));
  state.setTime(0.0);
  for (int i = 0; i < n; ++i) {
      model.getCoordinateSet().get(0).setValue(state, 0.1*i);
      Manager manager(model);
      state.setTime(i*dTime);
      manager.initialize(state);
      state = manager.integrate((i+1)*dTime);
  }
  }
   */
  public State integrate(double finalTime) {
    return new State(opensimSimulationJNI.Manager_integrate(swigCPtr, this, finalTime), false);
  }

  /**
   *  Get the current State from the Integrator associated with this <br>
   * Manager. 
   */
  public State getState() {
    return new State(opensimSimulationJNI.Manager_getState(swigCPtr, this), false);
  }

  public double getFixedStepSize(int tArrayStep) {
    return opensimSimulationJNI.Manager_getFixedStepSize(swigCPtr, this, tArrayStep);
  }

  public boolean hasStateStorage() {
    return opensimSimulationJNI.Manager_hasStateStorage(swigCPtr, this);
  }

  /**
   *  Set the Storage object to be used for storing states. The Manager takes<br>
   *     ownership of the passed-in Storage. 
   */
  public void setStateStorage(Storage aStorage) {
    opensimSimulationJNI.Manager_setStateStorage(swigCPtr, this, Storage.getCPtr(aStorage), aStorage);
  }

  public Storage getStateStorage() {
    return new Storage(opensimSimulationJNI.Manager_getStateStorage(swigCPtr, this), false);
  }

  public TimeSeriesTable getStatesTable() {
    return new TimeSeriesTable(opensimSimulationJNI.Manager_getStatesTable(swigCPtr, this), true);
  }

  public void halt() {
    opensimSimulationJNI.Manager_halt(swigCPtr, this);
  }

  public void clearHalt() {
    opensimSimulationJNI.Manager_clearHalt(swigCPtr, this);
  }

  public boolean checkHalt() {
    return opensimSimulationJNI.Manager_checkHalt(swigCPtr, this);
  }

  /**
   *  Supported integrator methods. For MATLAB, int's must be used rather<br>
   *         than enum's (see example in setIntegratorMethod(IntegratorMethod)). 
   */
  public final static class IntegratorMethod {
    /**
     *  0 : For details, see SimTK::ExplicitEulerIntegrator.
     */
    public final static Manager.IntegratorMethod ExplicitEuler = new Manager.IntegratorMethod("ExplicitEuler", opensimSimulationJNI.Manager_IntegratorMethod_ExplicitEuler_get());
    /**
     *  1 : For details, see SimTK::RungeKutta2Integrator.
     */
    public final static Manager.IntegratorMethod RungeKutta2 = new Manager.IntegratorMethod("RungeKutta2", opensimSimulationJNI.Manager_IntegratorMethod_RungeKutta2_get());
    /**
     *  2 : For details, see SimTK::RungeKutta3Integrator. 
     */
    public final static Manager.IntegratorMethod RungeKutta3 = new Manager.IntegratorMethod("RungeKutta3", opensimSimulationJNI.Manager_IntegratorMethod_RungeKutta3_get());
    /**
     *  3 : For details, see SimTK::RungeKuttaFeldbergIntegrator.
     */
    public final static Manager.IntegratorMethod RungeKuttaFeldberg = new Manager.IntegratorMethod("RungeKuttaFeldberg", opensimSimulationJNI.Manager_IntegratorMethod_RungeKuttaFeldberg_get());
    /**
     *  4 : For details, see SimTK::RungeKuttaMersonIntegrator.
     */
    public final static Manager.IntegratorMethod RungeKuttaMerson = new Manager.IntegratorMethod("RungeKuttaMerson", opensimSimulationJNI.Manager_IntegratorMethod_RungeKuttaMerson_get());
    /**
     *  5 : For details, see SimTK::SemiExplicitEuler2Integrator.
     */
    public final static Manager.IntegratorMethod SemiExplicitEuler2 = new Manager.IntegratorMethod("SemiExplicitEuler2", opensimSimulationJNI.Manager_IntegratorMethod_SemiExplicitEuler2_get());
    /**
     *  6 : For details, see SimTK::VerletIntegrator.
     */
    public final static Manager.IntegratorMethod Verlet = new Manager.IntegratorMethod("Verlet", opensimSimulationJNI.Manager_IntegratorMethod_Verlet_get());

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static IntegratorMethod swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + IntegratorMethod.class + " with value " + swigValue);
    }

    private IntegratorMethod(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private IntegratorMethod(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private IntegratorMethod(String swigName, IntegratorMethod swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static IntegratorMethod[] swigValues = { ExplicitEuler, RungeKutta2, RungeKutta3, RungeKuttaFeldberg, RungeKuttaMerson, SemiExplicitEuler2, Verlet };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

}
