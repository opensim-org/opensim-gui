/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * This class implements a configurable equilibrium muscle model, as described in<br>
 * Millard et al.\ (2013). An equilibrium model assumes that the forces generated<br>
 * by the fiber and tendon are equal:<br>
 * <br>
 *  
 f_{ISO}\Big(\mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE}) \mathbf{f}_V(\hat{v}_{CE})
+ \mathbf{f}_{PE}(\hat{l}_{CE}) + \beta \hat{v}_{CE}\Big) \cos \phi
-  f_{ISO}\mathbf{f}_{SE}(\hat{l}_{T}) = 0
<br>
 * <br>
 * <img src=fig_Millard2012EquilibriumMuscle.png/><br>
 * <br>
 * This model can be simulated in several configurations by adjusting three flags:<br>
 * <br>
 * <li>ignore_tendon_compliance: set to <i>true</i> to make the tendon rigid. This<br>
 * assumption is usually reasonable for short tendons, and can result in a<br>
 * performance improvement by eliminating high-frequency dynamics and removing the<br>
 * fiber length from the state vector.</li><br>
 * <br>
 * <li>ignore_activation_dynamics: set to <i>true</i> to use the excitation input<br>
 * as the activation signal. This results in faster simulations by reducing the<br>
 * size of the state vector.</li><br>
 * <br>
 * <li>fiber_damping: set to a value greater than 0.001 to include fiber damping in<br>
 * the model. The addition of damping reduces simulation time while allowing the<br>
 * muscle model to be more physiological (it can have an activation of zero, its<br>
 * active-force-length curve can go to zero, and its force-velocity curve can be<br>
 * asymptotic).</li><br>
 * <br>
 * <b>Elastic Tendon, No Fiber Damping</b><br>
 * <br>
 * The most typical configuration used in the literature is to simulate a muscle<br>
 * with an elastic tendon, full fiber dynamics, and activation dynamics. The<br>
 * resulting formulation suffers from three singularities:  \mathbf{a}(t)
\rightarrow 0,  \phi \rightarrow 90^\circ, and<br>
 *   \mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0 . These situations are all<br>
 * handled in this model to ensure that it does not produce singularities and does<br>
 * not result in intolerably long simulation times.<br>
 * <br>
 * Numerical singularities arise from the manner in which the equilibrium equation<br>
 * is rearranged to yield an ordinary differential equation (ODE). The above<br>
 * equation is rearranged to isolate   \mathbf{f}_V(\hat{v}_{CE}) . We then<br>
 * invert to solve for   \hat{v}_{CE} , which is then numerically integrated<br>
 * during a simulation:<br>
 *  
 \hat{v}_{CE} = \mathbf{f}_V ^{-1} \Big(
 \frac{ ( \mathbf{f}_{SE}(\hat{l}_{T}) ) /
 \cos \phi
  -  \mathbf{f}_{PE}(\hat{l}_{CE}) }
  { \mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE})} \Big)
<br>
 * <br>
 * The above equation becomes numerically stiff when terms in the denominator<br>
 * approach zero (when  \mathbf{a}(t) \rightarrow 0,  \phi
\rightarrow 90^\circ, or   \mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0 )<br>
 * or, additionally, when the slope of  \mathbf{f}_V ^{-1} is steep (which<br>
 * occurs at fiber velocities close to the maximum concentric and maximum<br>
 * eccentric fiber velocities).<br>
 * <br>
 * Singularities can be managed by ensuring that the muscle model is always<br>
 * activated ( \mathbf{a}(t) > 0), the fiber will stop contracting when a<br>
 * pennation angle of 90 degrees is approached ( \phi < 90^\circ), and the<br>
 * fiber will also stop contracting as its length approaches a lower bound<br>
 * (  \hat{l}_{CE} > lowerbound), which is typically around half the fiber's<br>
 * resting length (to ensure   \mathbf{f}_L(\hat{l}_{CE}) > 0 ). The fiber is<br>
 * prevented from reaching unphysiological lengths or its maximum pennation angle<br>
 * using a unilateral constraint. Additionally, the force-velocity curve is<br>
 * modified so that it is invertible.<br>
 * <br>
 * When an elastic tendon without fiber damping is selected, the minimum<br>
 * active-force-length value is set to 0.1, the minimum permissible activation is<br>
 * set to 0.01, and the maximum permissible pennation angle is set to acos(0.1) or<br>
 * 84.3 degrees. This is done as a convenience for the user to prevent the model<br>
 * from taking an unreasonable amount of time to simulate.<br>
 * <br>
 * <b>(Rigid Tendon) or (Elastic Tendon with Fiber Damping)</b><br>
 * <br>
 * Neither of these formulations has any singularities. The lower bound of the<br>
 * active-force-length curve can be zero (min(   \mathbf{f}_L(\hat{l}_{CE})) = 0
), activation can be zero (i.e., the muscle can be turned off completely),<br>
 * and the force-velocity curve need not be invertible.<br>
 * <br>
 * The rigid tendon formulation removes the singularities by ignoring the<br>
 * elasticity of the tendon. This assumption is reasonable for many muscles, but it<br>
 * is up to the user to determine whether this assumption is valid.<br>
 * <br>
 * The formulation that uses an elastic tendon with fiber damping removes<br>
 * singularities by solving the equilibrium equation with Newton's method. This is<br>
 * possible because the partial derivative of the equilibrium equation with respect<br>
 * to fiber velocity is always positive if   \beta > 0 and, thus, Newton's<br>
 * method can find a solution to the equilibrium equation.<br>
 * <br>
 * When either of these singularity-free formulations is selected, the minimum<br>
 * active-force-length value and the minimum permissible activation are set to<br>
 * zero. This is done as a convenience for the user, as these changes make the<br>
 * results of the model more realistic yet incur no performance penalty. The<br>
 * maximum pennation angle is left as acos(0.1) or 84.3 degrees, as allowing higher<br>
 * pennation angles results in an increasingly stiff fiber velocity state as<br>
 * pennation angle increases.<br>
 * <br>
 * <b>Usage</b><br>
 * <br>
 * This object should be updated through the <i>set</i> methods provided.<br>
 * <br>
 * <b>Example</b><br>
 * {@code 
double maxIsometricForce  = 5000;   //N
double optimalFiberLength = 0.025;  //m
double tendonSlackLength  = 0.25;   //m
double pennationAngle     = 0.5;    //rad

bool ignoreTendonCompliance   = false;
bool ignoreActivationDynamics = false;
double dampingCoefficient     = 0.001;

Millard2012EquilibriumMuscle myMuscle("myMuscle",
                                      maxIsometricForce,
                                      optimalFiberLength,
                                      tendonSlackLength,
                                      pennationAngle);

myMuscle.setMuscleConfiguration(ignoreTendonCompliance,
                                ignoreActivationDynamics,
                                dampingCoefficient);
}<br>
 * <br>
 * Please refer to the doxygen for more information on the properties that are<br>
 * objects themselves (MuscleFixedWidthPennationModel, ActiveForceLengthCurve,<br>
 * FiberForceLengthCurve, TendonForceLengthCurve, and ForceVelocityInverseCurve).<br>
 * <br>
 * <b>Reference</b><br>
 * <br>
 * Millard, M., Uchida, T., Seth, A., Delp, S.L. (2013) Flexing computational<br>
 * muscle: modeling and simulation of musculotendon dynamics. ASME Journal of<br>
 * Biomechanical Engineering 135(2):021005. http://dx.doi.org/10.1115/1.4023390.<br>
 * <br>
 * @author Matt Millard<br>
 * @author Tom Uchida<br>
 * @author Ajay Seth
 */
public class Millard2012EquilibriumMuscle extends Muscle {
  private transient long swigCPtr;

  public Millard2012EquilibriumMuscle(long cPtr, boolean cMemoryOwn) {
    super(opensimSimulationJNI.Millard2012EquilibriumMuscle_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(Millard2012EquilibriumMuscle obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_Millard2012EquilibriumMuscle(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static Millard2012EquilibriumMuscle safeDownCast(OpenSimObject obj) {
    long cPtr = opensimSimulationJNI.Millard2012EquilibriumMuscle_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new Millard2012EquilibriumMuscle(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.Millard2012EquilibriumMuscle_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Millard2012EquilibriumMuscle(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getConcreteClassName(swigCPtr, this);
  }

  public void copyProperty_fiber_damping(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_fiber_damping(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public double get_fiber_damping(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_fiber_damping__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_fiber_damping(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_fiber_damping__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_fiber_damping(int i, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_fiber_damping__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_fiber_damping(double value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_fiber_damping(swigCPtr, this, value);
  }

  public void constructProperty_fiber_damping(double initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_fiber_damping(swigCPtr, this, initValue);
  }

  public double get_fiber_damping() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_fiber_damping__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_fiber_damping() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_fiber_damping__SWIG_1(swigCPtr, this), false);
  }

  public void set_fiber_damping(double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_fiber_damping__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_default_activation(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_default_activation(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public double get_default_activation(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_default_activation__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_default_activation(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_default_activation__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_default_activation(int i, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_default_activation__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_default_activation(double value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_default_activation(swigCPtr, this, value);
  }

  public void constructProperty_default_activation(double initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_default_activation(swigCPtr, this, initValue);
  }

  public double get_default_activation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_default_activation__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_default_activation() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_default_activation__SWIG_1(swigCPtr, this), false);
  }

  public void set_default_activation(double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_default_activation__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_default_fiber_length(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_default_fiber_length(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public double get_default_fiber_length(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_default_fiber_length__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_default_fiber_length(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_default_fiber_length__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_default_fiber_length(int i, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_default_fiber_length__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_default_fiber_length(double value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_default_fiber_length(swigCPtr, this, value);
  }

  public void constructProperty_default_fiber_length(double initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_default_fiber_length(swigCPtr, this, initValue);
  }

  public double get_default_fiber_length() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_default_fiber_length__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_default_fiber_length() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_default_fiber_length__SWIG_1(swigCPtr, this), false);
  }

  public void set_default_fiber_length(double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_default_fiber_length__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_activation_time_constant(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_activation_time_constant(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public double get_activation_time_constant(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_activation_time_constant__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_activation_time_constant(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_activation_time_constant__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_activation_time_constant(int i, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_activation_time_constant__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_activation_time_constant(double value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_activation_time_constant(swigCPtr, this, value);
  }

  public void constructProperty_activation_time_constant(double initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_activation_time_constant(swigCPtr, this, initValue);
  }

  public double get_activation_time_constant() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_activation_time_constant__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_activation_time_constant() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_activation_time_constant__SWIG_1(swigCPtr, this), false);
  }

  public void set_activation_time_constant(double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_activation_time_constant__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_deactivation_time_constant(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_deactivation_time_constant(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public double get_deactivation_time_constant(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_deactivation_time_constant__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_deactivation_time_constant(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_deactivation_time_constant__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_deactivation_time_constant(int i, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_deactivation_time_constant__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_deactivation_time_constant(double value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_deactivation_time_constant(swigCPtr, this, value);
  }

  public void constructProperty_deactivation_time_constant(double initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_deactivation_time_constant(swigCPtr, this, initValue);
  }

  public double get_deactivation_time_constant() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_deactivation_time_constant__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_deactivation_time_constant() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_deactivation_time_constant__SWIG_1(swigCPtr, this), false);
  }

  public void set_deactivation_time_constant(double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_deactivation_time_constant__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_minimum_activation(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_minimum_activation(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public double get_minimum_activation(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_minimum_activation__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_minimum_activation(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_minimum_activation__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_minimum_activation(int i, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_minimum_activation__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_minimum_activation(double value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_minimum_activation(swigCPtr, this, value);
  }

  public void constructProperty_minimum_activation(double initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_minimum_activation(swigCPtr, this, initValue);
  }

  public double get_minimum_activation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_minimum_activation__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_minimum_activation() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_minimum_activation__SWIG_1(swigCPtr, this), false);
  }

  public void set_minimum_activation(double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_minimum_activation__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_maximum_pennation_angle(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_maximum_pennation_angle(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public double get_maximum_pennation_angle(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_maximum_pennation_angle__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_maximum_pennation_angle(int i) {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_maximum_pennation_angle__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_maximum_pennation_angle(int i, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_maximum_pennation_angle__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_maximum_pennation_angle(double value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_maximum_pennation_angle(swigCPtr, this, value);
  }

  public void constructProperty_maximum_pennation_angle(double initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_maximum_pennation_angle(swigCPtr, this, initValue);
  }

  public double get_maximum_pennation_angle() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_get_maximum_pennation_angle__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_maximum_pennation_angle() {
    return new SWIGTYPE_p_double(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_maximum_pennation_angle__SWIG_1(swigCPtr, this), false);
  }

  public void set_maximum_pennation_angle(double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_maximum_pennation_angle__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_ActiveForceLengthCurve(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_ActiveForceLengthCurve(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public ActiveForceLengthCurve get_ActiveForceLengthCurve(int i) {
    return new ActiveForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_get_ActiveForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public ActiveForceLengthCurve upd_ActiveForceLengthCurve(int i) {
    return new ActiveForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_ActiveForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_ActiveForceLengthCurve(int i, ActiveForceLengthCurve value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_ActiveForceLengthCurve__SWIG_0(swigCPtr, this, i, ActiveForceLengthCurve.getCPtr(value), value);
  }

  public int append_ActiveForceLengthCurve(ActiveForceLengthCurve value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_ActiveForceLengthCurve(swigCPtr, this, ActiveForceLengthCurve.getCPtr(value), value);
  }

  public void constructProperty_ActiveForceLengthCurve(ActiveForceLengthCurve initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_ActiveForceLengthCurve(swigCPtr, this, ActiveForceLengthCurve.getCPtr(initValue), initValue);
  }

  public ActiveForceLengthCurve get_ActiveForceLengthCurve() {
    return new ActiveForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_get_ActiveForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public ActiveForceLengthCurve upd_ActiveForceLengthCurve() {
    return new ActiveForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_ActiveForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_ActiveForceLengthCurve(ActiveForceLengthCurve value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_ActiveForceLengthCurve__SWIG_1(swigCPtr, this, ActiveForceLengthCurve.getCPtr(value), value);
  }

  public void copyProperty_ForceVelocityCurve(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_ForceVelocityCurve(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public ForceVelocityCurve get_ForceVelocityCurve(int i) {
    return new ForceVelocityCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_get_ForceVelocityCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public ForceVelocityCurve upd_ForceVelocityCurve(int i) {
    return new ForceVelocityCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_ForceVelocityCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_ForceVelocityCurve(int i, ForceVelocityCurve value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_ForceVelocityCurve__SWIG_0(swigCPtr, this, i, ForceVelocityCurve.getCPtr(value), value);
  }

  public int append_ForceVelocityCurve(ForceVelocityCurve value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_ForceVelocityCurve(swigCPtr, this, ForceVelocityCurve.getCPtr(value), value);
  }

  public void constructProperty_ForceVelocityCurve(ForceVelocityCurve initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_ForceVelocityCurve(swigCPtr, this, ForceVelocityCurve.getCPtr(initValue), initValue);
  }

  public ForceVelocityCurve get_ForceVelocityCurve() {
    return new ForceVelocityCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_get_ForceVelocityCurve__SWIG_1(swigCPtr, this), false);
  }

  public ForceVelocityCurve upd_ForceVelocityCurve() {
    return new ForceVelocityCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_ForceVelocityCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_ForceVelocityCurve(ForceVelocityCurve value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_ForceVelocityCurve__SWIG_1(swigCPtr, this, ForceVelocityCurve.getCPtr(value), value);
  }

  public void copyProperty_FiberForceLengthCurve(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_FiberForceLengthCurve(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public FiberForceLengthCurve get_FiberForceLengthCurve(int i) {
    return new FiberForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_get_FiberForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public FiberForceLengthCurve upd_FiberForceLengthCurve(int i) {
    return new FiberForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_FiberForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_FiberForceLengthCurve(int i, FiberForceLengthCurve value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_FiberForceLengthCurve__SWIG_0(swigCPtr, this, i, FiberForceLengthCurve.getCPtr(value), value);
  }

  public int append_FiberForceLengthCurve(FiberForceLengthCurve value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_FiberForceLengthCurve(swigCPtr, this, FiberForceLengthCurve.getCPtr(value), value);
  }

  public void constructProperty_FiberForceLengthCurve(FiberForceLengthCurve initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_FiberForceLengthCurve(swigCPtr, this, FiberForceLengthCurve.getCPtr(initValue), initValue);
  }

  public FiberForceLengthCurve get_FiberForceLengthCurve() {
    return new FiberForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_get_FiberForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public FiberForceLengthCurve upd_FiberForceLengthCurve() {
    return new FiberForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_FiberForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_FiberForceLengthCurve(FiberForceLengthCurve value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_FiberForceLengthCurve__SWIG_1(swigCPtr, this, FiberForceLengthCurve.getCPtr(value), value);
  }

  public void copyProperty_TendonForceLengthCurve(Millard2012EquilibriumMuscle source) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_copyProperty_TendonForceLengthCurve(swigCPtr, this, Millard2012EquilibriumMuscle.getCPtr(source), source);
  }

  public TendonForceLengthCurve get_TendonForceLengthCurve(int i) {
    return new TendonForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_get_TendonForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public TendonForceLengthCurve upd_TendonForceLengthCurve(int i) {
    return new TendonForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_TendonForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_TendonForceLengthCurve(int i, TendonForceLengthCurve value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_TendonForceLengthCurve__SWIG_0(swigCPtr, this, i, TendonForceLengthCurve.getCPtr(value), value);
  }

  public int append_TendonForceLengthCurve(TendonForceLengthCurve value) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_append_TendonForceLengthCurve(swigCPtr, this, TendonForceLengthCurve.getCPtr(value), value);
  }

  public void constructProperty_TendonForceLengthCurve(TendonForceLengthCurve initValue) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_constructProperty_TendonForceLengthCurve(swigCPtr, this, TendonForceLengthCurve.getCPtr(initValue), initValue);
  }

  public TendonForceLengthCurve get_TendonForceLengthCurve() {
    return new TendonForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_get_TendonForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public TendonForceLengthCurve upd_TendonForceLengthCurve() {
    return new TendonForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_upd_TendonForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public void set_TendonForceLengthCurve(TendonForceLengthCurve value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_set_TendonForceLengthCurve__SWIG_1(swigCPtr, this, TendonForceLengthCurve.getCPtr(value), value);
  }

  public void set_has_output_passive_fiber_elastic_force(boolean value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_elastic_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_elastic_force_along_tendon(boolean value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_along_tendon_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_elastic_force_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle__has_output_passive_fiber_elastic_force_along_tendon_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_damping_force(boolean value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_damping_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_damping_force_along_tendon(boolean value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_along_tendon_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_damping_force_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle__has_output_passive_fiber_damping_force_along_tendon_get(swigCPtr, this);
  }

  /**
   *  Default constructor. Produces a non-functional empty muscle. 
   */
  public Millard2012EquilibriumMuscle() {
    this(opensimSimulationJNI.new_Millard2012EquilibriumMuscle__SWIG_0(), true);
  }

  /**
   *  Constructs a functional muscle using default curves and activation model<br>
   *     parameters. The tendon is assumed to be elastic, full fiber dynamics are<br>
   *     solved, and activation dynamics are included.<br>
   *         @param aName The name of the muscle.<br>
   *         @param aMaxIsometricForce The force generated by the muscle when fully<br>
   *     activated at its optimal resting length with a contraction velocity of zero.<br>
   *         @param aOptimalFiberLength The optimal length of the muscle fiber.<br>
   *         @param aTendonSlackLength The resting length of the tendon.<br>
   *         @param aPennationAngle The angle of the fiber (in radians) relative to<br>
   *     the tendon when the fiber is at its optimal resting length. 
   */
  public Millard2012EquilibriumMuscle(String aName, double aMaxIsometricForce, double aOptimalFiberLength, double aTendonSlackLength, double aPennationAngle) {
    this(opensimSimulationJNI.new_Millard2012EquilibriumMuscle__SWIG_1(aName, aMaxIsometricForce, aOptimalFiberLength, aTendonSlackLength, aPennationAngle), true);
  }

  /**
   *  @return A boolean indicating whether fiber damping is being used. 
   */
  public boolean getUseFiberDamping() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getUseFiberDamping(swigCPtr, this);
  }

  /**
   *  @return The fiber damping coefficient. 
   */
  public double getFiberDamping() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getFiberDamping(swigCPtr, this);
  }

  /**
   *  @return The default activation level that is used as an initial<br>
   *     condition if none is provided by the user. 
   */
  public double getDefaultActivation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getDefaultActivation(swigCPtr, this);
  }

  /**
   *  @return The default fiber length that is used as an initial condition<br>
   *     if none is provided by the user. 
   */
  public double getDefaultFiberLength() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getDefaultFiberLength(swigCPtr, this);
  }

  /**
   *  @return The activation time constant (in seconds). 
   */
  public double getActivationTimeConstant() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getActivationTimeConstant(swigCPtr, this);
  }

  /**
   *  @return The deactivation time constant (in seconds). 
   */
  public double getDeactivationTimeConstant() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getDeactivationTimeConstant(swigCPtr, this);
  }

  /**
   *  @return The minimum activation level permitted by the muscle model.<br>
   *     Note that this equilibrium model, like all equilibrium models, has a<br>
   *     singularity when activation approaches 0, which means that a non-zero lower<br>
   *     bound is required. 
   */
  public double getMinimumActivation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getMinimumActivation(swigCPtr, this);
  }

  /**
   *  @return The ActiveForceLengthCurve used by this model. 
   */
  public ActiveForceLengthCurve getActiveForceLengthCurve() {
    return new ActiveForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_getActiveForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *  @return The ForceVelocityCurve used by this model. 
   */
  public ForceVelocityCurve getForceVelocityCurve() {
    return new ForceVelocityCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_getForceVelocityCurve(swigCPtr, this), false);
  }

  /**
   *  @return The FiberForceLengthCurve used by this model. 
   */
  public FiberForceLengthCurve getFiberForceLengthCurve() {
    return new FiberForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_getFiberForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *  @return The TendonForceLengthCurve used by this model. 
   */
  public TendonForceLengthCurve getTendonForceLengthCurve() {
    return new TendonForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscle_getTendonForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *  @return The MuscleFixedWidthPennationModel owned by this model. 
   */
  public MuscleFixedWidthPennationModel getPennationModel() {
    return new MuscleFixedWidthPennationModel(opensimSimulationJNI.Millard2012EquilibriumMuscle_getPennationModel(swigCPtr, this), false);
  }

  /**
   *  @return The MuscleFirstOrderActivationDynamicModel owned by this<br>
   *     model. 
   */
  public MuscleFirstOrderActivationDynamicModel getActivationModel() {
    return new MuscleFirstOrderActivationDynamicModel(opensimSimulationJNI.Millard2012EquilibriumMuscle_getActivationModel(swigCPtr, this), false);
  }

  /**
   *  @return The minimum fiber length, which is the maximum of two values:<br>
   *     the smallest fiber length allowed by the pennation model, and the minimum<br>
   *     fiber length on the active-force-length curve. When the fiber reaches this<br>
   *     length, it is constrained to this value until the fiber velocity becomes<br>
   *     positive. 
   */
  public double getMinimumFiberLength() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getMinimumFiberLength(swigCPtr, this);
  }

  /**
   *  @return The minimum fiber length along the tendon, which is the maximum<br>
   *     of two values: the smallest fiber length along the tendon permitted by the<br>
   *     pennation model, and the minimum fiber length along the tendon on the<br>
   *     active-force-length curve. When the fiber length reaches this value, it is<br>
   *     constrained to this length along the tendon until the fiber velocity becomes<br>
   *     positive. 
   */
  public double getMinimumFiberLengthAlongTendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getMinimumFiberLengthAlongTendon(swigCPtr, this);
  }

  /**
   *  @param s The state of the system.<br>
   *         @return The normalized force term associated with the tendon element,<br>
   *      \mathbf{f}_{SE}(\hat{l}_{T}), in the equilibrium equation. 
   */
  public double getTendonForceMultiplier(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getTendonForceMultiplier(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  @return The stiffness of the muscle fibers along the tendon (N/m). 
   */
  public double getFiberStiffnessAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getFiberStiffnessAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  @param s The state of the system.<br>
   *     @return The velocity of the fiber (m/s). 
   */
  public double getFiberVelocity(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getFiberVelocity(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  @param s The state of the system.<br>
   *     @return The time derivative of activation. 
   */
  public double getActivationDerivative(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getActivationDerivative(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the portion of the passive fiber force generated by the elastic<br>
   *         element only (N) 
   */
  public double getPassiveFiberElasticForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getPassiveFiberElasticForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the portion of the passive fiber force generated by the elastic<br>
   *         element only, projected onto the tendon direction (N) 
   */
  public double getPassiveFiberElasticForceAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getPassiveFiberElasticForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the portion of the passive fiber force generated by the damping<br>
   *         element only (N) 
   */
  public double getPassiveFiberDampingForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getPassiveFiberDampingForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the portion of the passive fiber force generated by the damping<br>
   *         element only, projected onto the tendon direction (N) 
   */
  public double getPassiveFiberDampingForceAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_getPassiveFiberDampingForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  @param ignoreTendonCompliance Use a rigid (true) or elastic tendon.<br>
   *         @param ignoreActivationDynamics Treat the excitation input as the<br>
   *     activation signal (true) or use a first-order activation dynamic model.<br>
   *         @param dampingCoefficient Specify the amount of damping to include in<br>
   *     the model (must be either 0 or greater than 0.001). 
   */
  public void setMuscleConfiguration(boolean ignoreTendonCompliance, boolean ignoreActivationDynamics, double dampingCoefficient) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setMuscleConfiguration(swigCPtr, this, ignoreTendonCompliance, ignoreActivationDynamics, dampingCoefficient);
  }

  /**
   *  @param dampingCoefficient Define the fiber damping coefficient. 
   */
  public void setFiberDamping(double dampingCoefficient) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setFiberDamping(swigCPtr, this, dampingCoefficient);
  }

  /**
   *  @param activation The default activation level that is used to<br>
   *     initialize the muscle. 
   */
  public void setDefaultActivation(double activation) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setDefaultActivation(swigCPtr, this, activation);
  }

  /**
   *  @param s The state of the system.<br>
   *         @param activation The desired activation level. 
   */
  public void setActivation(State s, double activation) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setActivation(swigCPtr, this, State.getCPtr(s), s, activation);
  }

  /**
   *  @param fiberLength The default fiber length that is used to initialize<br>
   *     the muscle. 
   */
  public void setDefaultFiberLength(double fiberLength) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setDefaultFiberLength(swigCPtr, this, fiberLength);
  }

  /**
   *  @param activationTimeConstant The activation time constant (in<br>
   *     seconds). 
   */
  public void setActivationTimeConstant(double activationTimeConstant) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setActivationTimeConstant(swigCPtr, this, activationTimeConstant);
  }

  /**
   *  @param deactivationTimeConstant The deactivation time constant (in<br>
   *     seconds). 
   */
  public void setDeactivationTimeConstant(double deactivationTimeConstant) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setDeactivationTimeConstant(swigCPtr, this, deactivationTimeConstant);
  }

  /**
   *  @param minimumActivation The minimum permissible activation level. 
   */
  public void setMinimumActivation(double minimumActivation) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setMinimumActivation(swigCPtr, this, minimumActivation);
  }

  /**
   *  @param aActiveForceLengthCurve The ActiveForceLengthCurve used by the<br>
   *     muscle model to scale active fiber force as a function of fiber length. 
   */
  public void setActiveForceLengthCurve(ActiveForceLengthCurve aActiveForceLengthCurve) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setActiveForceLengthCurve(swigCPtr, this, ActiveForceLengthCurve.getCPtr(aActiveForceLengthCurve), aActiveForceLengthCurve);
  }

  /**
   *  @param aForceVelocityCurve The ForceVelocityCurve used by the muscle<br>
   *     model to calculate the derivative of fiber length. 
   */
  public void setForceVelocityCurve(ForceVelocityCurve aForceVelocityCurve) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setForceVelocityCurve(swigCPtr, this, ForceVelocityCurve.getCPtr(aForceVelocityCurve), aForceVelocityCurve);
  }

  /**
   *  @param aFiberForceLengthCurve The FiberForceLengthCurve used by the<br>
   *     muscle model to calculate the passive force the muscle fiber generates as a<br>
   *     function of fiber length. 
   */
  public void setFiberForceLengthCurve(FiberForceLengthCurve aFiberForceLengthCurve) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setFiberForceLengthCurve(swigCPtr, this, FiberForceLengthCurve.getCPtr(aFiberForceLengthCurve), aFiberForceLengthCurve);
  }

  /**
   *  @param aTendonForceLengthCurve The TendonForceLengthCurve used by the<br>
   *     muscle model to calculate the force exerted by the tendon as a function of<br>
   *     tendon length. 
   */
  public void setTendonForceLengthCurve(TendonForceLengthCurve aTendonForceLengthCurve) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setTendonForceLengthCurve(swigCPtr, this, TendonForceLengthCurve.getCPtr(aTendonForceLengthCurve), aTendonForceLengthCurve);
  }

  /**
   *  @param s The state of the system.<br>
   *         @param fiberLength The desired fiber length (m). 
   */
  public void setFiberLength(State s, double fiberLength) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_setFiberLength(swigCPtr, this, State.getCPtr(s), s, fiberLength);
  }

  /**
   *  @param s The state of the system.<br>
   *         @return The tensile force the muscle is generating (N). 
   */
  public double computeActuation(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_computeActuation(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Computes the fiber length such that the fiber and tendon are developing<br>
   *     the same force, distributing the velocity of the entire musculotendon<br>
   *     actuator between the fiber and tendon according to their relative<br>
   *     stiffnesses.<br>
   *         @param s The state of the system.<br>
   *         @throws MuscleCannotEquilibrate
   */
  public void computeInitialFiberEquilibrium(State s) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_computeInitialFiberEquilibrium(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Computes the fiber length such that the fiber and tendon are developing<br>
   *         the same force, either assuming muscle-tendon velocity as provided<br>
   *         by the state or zero as designated by the useZeroVelocity flag.<br>
   *         @param s         The state of the system.<br>
   *         @param solveForVelocity  Flag indicating to solve for fiber velocity,<br>
   *                                  which by default is false (zero fiber-velocity)<br>
   *         @throws MuscleCannotEquilibrate
   */
  public void computeFiberEquilibrium(State s, boolean solveForVelocity) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_computeFiberEquilibrium__SWIG_0(swigCPtr, this, State.getCPtr(s), s, solveForVelocity);
  }

  /**
   *  Computes the fiber length such that the fiber and tendon are developing<br>
   *         the same force, either assuming muscle-tendon velocity as provided<br>
   *         by the state or zero as designated by the useZeroVelocity flag.<br>
   *         @param s         The state of the system.<br>
   *         @throws MuscleCannotEquilibrate
   */
  public void computeFiberEquilibrium(State s) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_computeFiberEquilibrium__SWIG_1(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   * Conditional comment: DEPRECATED
   */
  public double calcActiveFiberForceAlongTendon(double activation, double fiberLength, double fiberVelocity) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_calcActiveFiberForceAlongTendon(swigCPtr, this, activation, fiberLength, fiberVelocity);
  }

  public Vec4 calcFiberStateGivenBoundaryCond(double lengthMT, double velocityMT, double tendonForce, double dTendonForceDT) {
    return new Vec4(opensimSimulationJNI.Millard2012EquilibriumMuscle_calcFiberStateGivenBoundaryCond(swigCPtr, this, lengthMT, velocityMT, tendonForce, dTendonForceDT), true);
  }

  public double calcInextensibleTendonActiveFiberForce(State s, double aActivation) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscle_calcInextensibleTendonActiveFiberForce(swigCPtr, this, State.getCPtr(s), s, aActivation);
  }

  /**
   * End of conditional comment. Adjust the properties of the muscle after the model has been scaled. The<br>
   *         optimal fiber length and tendon slack length are each multiplied by the<br>
   *         ratio of the current path length and the path length before scaling. 
   */
  public void extendPostScale(State s, ScaleSet scaleSet) {
    opensimSimulationJNI.Millard2012EquilibriumMuscle_extendPostScale(swigCPtr, this, State.getCPtr(s), s, ScaleSet.getCPtr(scaleSet), scaleSet);
  }

}
