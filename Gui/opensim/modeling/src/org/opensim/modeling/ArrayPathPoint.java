/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * A class for storing an array of values of type T.  The capacity of the class<br>
 * grows as needed.  To use this template for a class of type T, class T should<br>
 * implement the following methods:  default constructor, copy constructor,<br>
 * assignment operator (=), equality operator (==), and less than<br>
 * operator (&lt;).<br>
 * <br>
 * @version 1.0<br>
 * @author Frank C. Anderson
 */
public class ArrayPathPoint {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public ArrayPathPoint(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(ArrayPathPoint obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_ArrayPathPoint(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   * Default constructor.<br>
   * <br>
   * @param aDefaultValue Default value of an array element.  This value<br>
   * is used to initialize array elements as the size of the array is<br>
   * changed.<br>
   * @param aSize Initial size of the array.  The array elements are<br>
   * initialized to aDefaultValue.<br>
   * @param aCapacity Initial capacity of the array.  The initial capacity<br>
   * is guaranteed to be at least as large as aSize + 1.
   */
  public ArrayPathPoint(AbstractPathPoint aDefaultValue, int aSize, int aCapacity) {
    this(opensimSimulationJNI.new_ArrayPathPoint__SWIG_0(AbstractPathPoint.getCPtr(aDefaultValue), aDefaultValue, aSize, aCapacity), true);
  }

  /**
   * Default constructor.<br>
   * <br>
   * @param aDefaultValue Default value of an array element.  This value<br>
   * is used to initialize array elements as the size of the array is<br>
   * changed.<br>
   * @param aSize Initial size of the array.  The array elements are<br>
   * initialized to aDefaultValue.<br>
   * 
   */
  public ArrayPathPoint(AbstractPathPoint aDefaultValue, int aSize) {
    this(opensimSimulationJNI.new_ArrayPathPoint__SWIG_1(AbstractPathPoint.getCPtr(aDefaultValue), aDefaultValue, aSize), true);
  }

  /**
   * Default constructor.<br>
   * <br>
   * @param aDefaultValue Default value of an array element.  This value<br>
   * is used to initialize array elements as the size of the array is<br>
   * changed.<br>
   * <br>
   * 
   */
  public ArrayPathPoint(AbstractPathPoint aDefaultValue) {
    this(opensimSimulationJNI.new_ArrayPathPoint__SWIG_2(AbstractPathPoint.getCPtr(aDefaultValue), aDefaultValue), true);
  }

  /**
   * Default constructor.<br>
   * <br>
   * <br>
   * <br>
   * 
   */
  public ArrayPathPoint() {
    this(opensimSimulationJNI.new_ArrayPathPoint__SWIG_3(), true);
  }

  /**
   * Copy constructor.<br>
   * <br>
   * @param aArray Array to be copied.
   */
  public ArrayPathPoint(ArrayPathPoint aArray) {
    this(opensimSimulationJNI.new_ArrayPathPoint__SWIG_4(ArrayPathPoint.getCPtr(aArray), aArray), true);
  }

  public boolean arrayEquals(ArrayPathPoint aArray) {
    return opensimSimulationJNI.ArrayPathPoint_arrayEquals(swigCPtr, this, ArrayPathPoint.getCPtr(aArray), aArray);
  }

  /**
   * Trim the capacity of this array so that it is one larger than the size<br>
   * of this array.  This is useful for reducing the amount of memory used<br>
   * by this array.  This capacity is kept at one larger than the size so<br>
   * that, for example, an array of characters can be treated as a NULL<br>
   * terminated string.
   */
  public void trim() {
    opensimSimulationJNI.ArrayPathPoint_trim(swigCPtr, this);
  }

  /**
   * %Set the size of the array.  This method can be used to either increase<br>
   * or decrease the size of the array.  If this size of the array is<br>
   * increased, the new elements are initialized to the default value<br>
   * that was specified at the time of construction.<br>
   * <br>
   * Note that the size of an array is different than its capacity.  The size<br>
   * indicates how many valid elements are stored in an array.  The capacity<br>
   * indicates how much the size of the array can be increased without<br>
   * allocated more memory.  At all times size &lt;= capacity.<br>
   * <br>
   * @param aSize Desired size of the array.  The size must be greater than<br>
   * or equal to zero.
   */
  public boolean setSize(int aSize) {
    return opensimSimulationJNI.ArrayPathPoint_setSize(swigCPtr, this, aSize);
  }

  /**
   * Get the size of the array.<br>
   * <br>
   * @return Size of the array.
   */
  public int getSize() {
    return opensimSimulationJNI.ArrayPathPoint_getSize(swigCPtr, this);
  }

  /**
   *  Alternate name for getSize(). *
   */
  public int size() {
    return opensimSimulationJNI.ArrayPathPoint_size(swigCPtr, this);
  }

  /**
   * Append a value onto the array.<br>
   * <br>
   * @param aValue Value to be appended.<br>
   * @return New size of the array, or, equivalently, the index to the new<br>
   * first empty element of the array.
   */
  public int append(AbstractPathPoint aValue) {
    return opensimSimulationJNI.ArrayPathPoint_append__SWIG_0(swigCPtr, this, AbstractPathPoint.getCPtr(aValue), aValue);
  }

  /**
   * Append an array of values.<br>
   * <br>
   * @param aArray Array of values to append.<br>
   * @return New size of the array, or, equivalently, the index to the new<br>
   * first empty element of the array.
   */
  public int append(ArrayPathPoint aArray) {
    return opensimSimulationJNI.ArrayPathPoint_append__SWIG_1(swigCPtr, this, ArrayPathPoint.getCPtr(aArray), aArray);
  }

  /**
   * Insert a value into the array at a specified index.<br>
   * <br>
   * This method is relatively computationally costly since many of the array<br>
   * elements may need to be shifted.<br>
   * <br>
   * @param aValue Value to be inserted.<br>
   * @param aIndex Index at which to insert the new value.  All current elements<br>
   * from aIndex to the end of the array are shifted one place in the direction<br>
   * of the end of the array.  If the specified index is greater than the<br>
   * current size of the array, the size of the array is increased to aIndex+1<br>
   * and the intervening new elements are initialized to the default value that<br>
   * was specified at the time of construction.<br>
   * @return Size of the array after the insertion.
   */
  public int insert(int aIndex, AbstractPathPoint aValue) {
    return opensimSimulationJNI.ArrayPathPoint_insert(swigCPtr, this, aIndex, AbstractPathPoint.getCPtr(aValue), aValue);
  }

  /**
   * Remove a value from the array at a specified index.<br>
   * <br>
   * This method is relatively computationally costly since many of the array<br>
   * elements may need to be shifted.<br>
   * <br>
   * @param aIndex Index of the value to remove.  All elements from aIndex to<br>
   * the end of the array are shifted one place toward the beginning of<br>
   * the array.  If aIndex is less than 0 or greater than or equal to the<br>
   * current size of the array, no element is removed.<br>
   * @return Size of the array after the removal.
   */
  public int remove(int aIndex) {
    return opensimSimulationJNI.ArrayPathPoint_remove(swigCPtr, this, aIndex);
  }

  /**
   * %Set the value at a specified index.<br>
   * <br>
   * @param aIndex Index of the array element to be set.  It is permissible<br>
   * for aIndex to be past the current end of the array- the capacity will<br>
   * be increased if necessary.  Values between the current end of the array<br>
   * and aIndex are not initialized.<br>
   * @param aValue Value.
   */
  public void set(int aIndex, AbstractPathPoint aValue) {
    opensimSimulationJNI.ArrayPathPoint_set(swigCPtr, this, aIndex, AbstractPathPoint.getCPtr(aValue), aValue);
  }

  /**
   * Get a const reference to the value at a specified array index.<br>
   * <br>
   * If the index is negative or passed the end of the array, an exception<br>
   * is thrown.<br>
   * <br>
   * For faster execution, the array elements can be accessed through the<br>
   * overloaded operator[], which does no bounds checking.<br>
   * <br>
   * @param aIndex Index of the desired array element.<br>
   * @return const reference to the array element.<br>
   * @throws Exception if (aIndex&lt;0)||(aIndex&gt;=_size).<br>
   * @see operator[].
   */
  public AbstractPathPoint get(int aIndex) {
    long cPtr = opensimSimulationJNI.ArrayPathPoint_get(swigCPtr, this, aIndex);
    return (cPtr == 0) ? null : new AbstractPathPoint(cPtr, false);
  }

  public AbstractPathPoint getitem(int index) {
    long cPtr = opensimSimulationJNI.ArrayPathPoint_getitem(swigCPtr, this, index);
    return (cPtr == 0) ? null : new AbstractPathPoint(cPtr, false);
  }

  public void setitem(int index, AbstractPathPoint val) {
    opensimSimulationJNI.ArrayPathPoint_setitem(swigCPtr, this, index, AbstractPathPoint.getCPtr(val), val);
  }

  /**
   * Get the last value in the array.<br>
   * <br>
   * @return Last value in the array.<br>
   * @throws Exception if the array is empty.
   */
  public AbstractPathPoint getLast() {
    long cPtr = opensimSimulationJNI.ArrayPathPoint_getLast(swigCPtr, this);
    return (cPtr == 0) ? null : new AbstractPathPoint(cPtr, false);
  }

  /**
   * Linear search for an element matching a given value.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @return Index of the array element matching aValue. If there is more than<br>
   * one such elements with the same value the index of the first of these elements<br>
   * is returned.  If no match is found, -1 is returned.
   */
  public int findIndex(AbstractPathPoint aValue) {
    return opensimSimulationJNI.ArrayPathPoint_findIndex(swigCPtr, this, AbstractPathPoint.getCPtr(aValue), aValue);
  }

  /**
   * Linear search in reverse for an element matching a given value.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @return Index of the array element matching aValue. If there is more than<br>
   * one such elements with the same value the index of the last of these elements<br>
   * is returned.  If no match is found, -1 is returned.
   */
  public int rfindIndex(AbstractPathPoint aValue) {
    return opensimSimulationJNI.ArrayPathPoint_rfindIndex(swigCPtr, this, AbstractPathPoint.getCPtr(aValue), aValue);
  }

  /**
   * Search for the largest value in the array that is less than or<br>
   * equal to a specified value.  If there is more than one element with this<br>
   * largest value, the index of the first of these elements can optionally be<br>
   * found, but this can be up to twice as costly.<br>
   * <br>
   * This method assumes that the array element values monotonically<br>
   * increase as the array index increases.  Note that monotonically<br>
   * increase means never decrease, so it is permissible for elements to<br>
   * <br>
   * A binary search is performed (i.e., the array is repeatedly subdivided<br>
   * into two bins one of which must contain the specified until the<br>
   * appropriate element is identified), so the performance of this method<br>
   * is approximately ln(n), where n is the size of the array.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @param aFindFirst If true, find the first element that satisfies<br>
   * the search.  If false, the index of any element that satisfies the<br>
   * search can be returned- which index will be returned depends on the<br>
   * length of the array and is therefore somewhat arbitrary. By default,<br>
   * this flag is false.<br>
   * @param aLo Lowest array index to consider in the search.<br>
   * @param aHi Highest array index to consider in the search.<br>
   * @return Index of the array element that has the largest value that is less<br>
   * than or equal to aValue.  If there is more than one such elements with the<br>
   * same value and aFindFirst is set to true, the index of the first of<br>
   * these elements is returned.  If an error is encountered (e.g., the array<br>
   * is empty), or the array contains no element that is less than or equal<br>
   * to aValue, -1 is returned.
   */
  public int searchBinary(AbstractPathPoint aValue, boolean aFindFirst, int aLo, int aHi) {
    return opensimSimulationJNI.ArrayPathPoint_searchBinary__SWIG_0(swigCPtr, this, AbstractPathPoint.getCPtr(aValue), aValue, aFindFirst, aLo, aHi);
  }

  /**
   * Search for the largest value in the array that is less than or<br>
   * equal to a specified value.  If there is more than one element with this<br>
   * largest value, the index of the first of these elements can optionally be<br>
   * found, but this can be up to twice as costly.<br>
   * <br>
   * This method assumes that the array element values monotonically<br>
   * increase as the array index increases.  Note that monotonically<br>
   * increase means never decrease, so it is permissible for elements to<br>
   * <br>
   * A binary search is performed (i.e., the array is repeatedly subdivided<br>
   * into two bins one of which must contain the specified until the<br>
   * appropriate element is identified), so the performance of this method<br>
   * is approximately ln(n), where n is the size of the array.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @param aFindFirst If true, find the first element that satisfies<br>
   * the search.  If false, the index of any element that satisfies the<br>
   * search can be returned- which index will be returned depends on the<br>
   * length of the array and is therefore somewhat arbitrary. By default,<br>
   * this flag is false.<br>
   * @param aLo Lowest array index to consider in the search.<br>
   * <br>
   * @return Index of the array element that has the largest value that is less<br>
   * than or equal to aValue.  If there is more than one such elements with the<br>
   * same value and aFindFirst is set to true, the index of the first of<br>
   * these elements is returned.  If an error is encountered (e.g., the array<br>
   * is empty), or the array contains no element that is less than or equal<br>
   * to aValue, -1 is returned.
   */
  public int searchBinary(AbstractPathPoint aValue, boolean aFindFirst, int aLo) {
    return opensimSimulationJNI.ArrayPathPoint_searchBinary__SWIG_1(swigCPtr, this, AbstractPathPoint.getCPtr(aValue), aValue, aFindFirst, aLo);
  }

  /**
   * Search for the largest value in the array that is less than or<br>
   * equal to a specified value.  If there is more than one element with this<br>
   * largest value, the index of the first of these elements can optionally be<br>
   * found, but this can be up to twice as costly.<br>
   * <br>
   * This method assumes that the array element values monotonically<br>
   * increase as the array index increases.  Note that monotonically<br>
   * increase means never decrease, so it is permissible for elements to<br>
   * <br>
   * A binary search is performed (i.e., the array is repeatedly subdivided<br>
   * into two bins one of which must contain the specified until the<br>
   * appropriate element is identified), so the performance of this method<br>
   * is approximately ln(n), where n is the size of the array.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * @param aFindFirst If true, find the first element that satisfies<br>
   * the search.  If false, the index of any element that satisfies the<br>
   * search can be returned- which index will be returned depends on the<br>
   * length of the array and is therefore somewhat arbitrary. By default,<br>
   * this flag is false.<br>
   * <br>
   * <br>
   * @return Index of the array element that has the largest value that is less<br>
   * than or equal to aValue.  If there is more than one such elements with the<br>
   * same value and aFindFirst is set to true, the index of the first of<br>
   * these elements is returned.  If an error is encountered (e.g., the array<br>
   * is empty), or the array contains no element that is less than or equal<br>
   * to aValue, -1 is returned.
   */
  public int searchBinary(AbstractPathPoint aValue, boolean aFindFirst) {
    return opensimSimulationJNI.ArrayPathPoint_searchBinary__SWIG_2(swigCPtr, this, AbstractPathPoint.getCPtr(aValue), aValue, aFindFirst);
  }

  /**
   * Search for the largest value in the array that is less than or<br>
   * equal to a specified value.  If there is more than one element with this<br>
   * largest value, the index of the first of these elements can optionally be<br>
   * found, but this can be up to twice as costly.<br>
   * <br>
   * This method assumes that the array element values monotonically<br>
   * increase as the array index increases.  Note that monotonically<br>
   * increase means never decrease, so it is permissible for elements to<br>
   * <br>
   * A binary search is performed (i.e., the array is repeatedly subdivided<br>
   * into two bins one of which must contain the specified until the<br>
   * appropriate element is identified), so the performance of this method<br>
   * is approximately ln(n), where n is the size of the array.<br>
   * <br>
   * @param aValue Value to which the array elements are compared.<br>
   * <br>
   * <br>
   * <br>
   * @return Index of the array element that has the largest value that is less<br>
   * than or equal to aValue.  If there is more than one such elements with the<br>
   * same value and aFindFirst is set to true, the index of the first of<br>
   * these elements is returned.  If an error is encountered (e.g., the array<br>
   * is empty), or the array contains no element that is less than or equal<br>
   * to aValue, -1 is returned.
   */
  public int searchBinary(AbstractPathPoint aValue) {
    return opensimSimulationJNI.ArrayPathPoint_searchBinary__SWIG_3(swigCPtr, this, AbstractPathPoint.getCPtr(aValue), aValue);
  }

}
