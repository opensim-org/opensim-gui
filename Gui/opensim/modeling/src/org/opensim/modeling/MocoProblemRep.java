/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  The primary intent of this class is for use by MocoSolver%s, but users<br>
 *  can also use this class to apply parameter values to the model<br>
 *  and evaluate cost terms.<br>
 *  This class also checks the MocoProblem for various errors.<br>
 *  To get an instance of this class, use MocoProblem::createRep().<br>
 *  This interface currently supports only single-phase problems.<br>
 *  This class stores a reference (not a copy) to the original MocoProblem<br>
 *  from which it was created.<br>
 * <br>
 *  <p alt="ModelBase and ModelDisabledConstraints"><br>
 *  This class provides access to two models: ModelBase is obtained by<br>
 *  processing the ModelProcessor that the user gives to MocoProblem.<br>
 *  ModelDisabledConstraints is a copy of ModelBase in which all kinematic<br>
 *  constraints are disabled.<br>
 *  ModelDisabledConstraints contains a DiscreteForces component, which<br>
 *  is used to apply constraint forces computed using ModelBase.<br>
 *  If kinematics are not prescribed (with PositionMotion),<br>
 *  ModelDisabledConstraints also contains an AccelerationMotion component,<br>
 *  which is used by solvers that rely on implicit multibody dynamics.<br>
 *  The initialize() function adds a ControlDistributor component<br>
 *  to both models; this component is used by a solver to set the control<br>
 *  signals for actuators to use.<br>
 *  To learn the need for and use of these two models, see <a href="#impldiverse">impldiverse</a>.</p>
 */
public class MocoProblemRep {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public MocoProblemRep(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(MocoProblemRep obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(MocoProblemRep obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimMocoJNI.delete_MocoProblemRep(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  public MocoProblemRep() {
    this(opensimMocoJNI.new_MocoProblemRep__SWIG_0(), true);
  }

  public MocoProblemRep(MocoProblemRep source) {
    this(opensimMocoJNI.new_MocoProblemRep__SWIG_1(MocoProblemRep.swigRelease(source), source), true);
  }

  public String getName() {
    return opensimMocoJNI.MocoProblemRep_getName(swigCPtr, this);
  }

  /**
   *  Get a reference to the copy of the model being used by this<br>
   *  MocoProblemRep. This model is obtained by processing the ModelProcessor<br>
   *  the user gives to MocoProblem. This model is *not* the model given to<br>
   *  MocoGoal or MocoPathConstraint, but can be used within solvers to<br>
   *  compute constraint forces and constraint errors (see<br>
   *  getModelDisabledConstraints() for more details). Any parameter updates<br>
   *  via a MocoParameter added to the problem will be applied to this model.
   */
  public Model getModelBase() {
    return new Model(opensimMocoJNI.MocoProblemRep_getModelBase(swigCPtr, this), false);
  }

  /**
   *  This is a state object that solvers can use along with ModelBase.
   */
  public State updStateBase() {
    return new State(opensimMocoJNI.MocoProblemRep_updStateBase(swigCPtr, this), false);
  }

  /**
   *  This is a component inside ModelBase that you can use to<br>
   *  set the value of control signals.
   */
  public SWIGTYPE_p_OpenSim__ControlDistributor getControlDistributorBase() {
    return new SWIGTYPE_p_OpenSim__ControlDistributor(opensimMocoJNI.MocoProblemRep_getControlDistributorBase(swigCPtr, this), false);
  }

  /**
   *  Get a reference to a copy of the model being used by this<br>
   *  MocoProblemRep, but with all constraints disabled and an additional<br>
   *  DiscreteForces component. This new component can be used to apply<br>
   *  constraint forces computed from the base model to this model, which<br>
   *  updates the discrete variables in the state associated with these<br>
   *  forces. You should use this model to compute accelerations via<br>
   *  getModelDisabledConstraints().realizeAccleration(state), making sure to<br>
   *  add any constraint forces to the model preceding the realization. This<br>
   *  model is the same instance as that given to MocoGoal and<br>
   *  MocoPathConstraint, ensuring that realizing to Stage::Acceleration<br>
   *  in these classes produces the same accelerations computed by the solver.<br>
   *  Any parameter updates via a MocoParameter added to the problem<br>
   *  will be applied to this model.
   */
  public Model getModelDisabledConstraints() {
    return new Model(opensimMocoJNI.MocoProblemRep_getModelDisabledConstraints(swigCPtr, this), false);
  }

  /**
   *  This is a state object that solvers can use with<br>
   *  ModelDisabledConstraints. Some solvers may need to use 2 state objects<br>
   *  at once; you can supply an index of 1 to get a second state object.
   */
  public State updStateDisabledConstraints(int index) {
    return new State(opensimMocoJNI.MocoProblemRep_updStateDisabledConstraints__SWIG_0(swigCPtr, this, index), false);
  }

  /**
   *  This is a state object that solvers can use with<br>
   *  ModelDisabledConstraints. Some solvers may need to use 2 state objects<br>
   *  at once; you can supply an index of 1 to get a second state object.
   */
  public State updStateDisabledConstraints() {
    return new State(opensimMocoJNI.MocoProblemRep_updStateDisabledConstraints__SWIG_1(swigCPtr, this), false);
  }

  /**
   *  This is a component inside ModelDisabledConstraints that you can use to<br>
   *  set the value of control signals.
   */
  public SWIGTYPE_p_OpenSim__ControlDistributor getControlDistributorDisabledConstraints() {
    return new SWIGTYPE_p_OpenSim__ControlDistributor(opensimMocoJNI.MocoProblemRep_getControlDistributorDisabledConstraints(swigCPtr, this), false);
  }

  /**
   *  This is a component inside ModelDisabledConstraints that you can use<br>
   *  to set the value of discrete forces, intended to hold the constraint<br>
   *  forces obtained from ModelBase.
   */
  public SWIGTYPE_p_OpenSim__DiscreteForces getConstraintForces() {
    return new SWIGTYPE_p_OpenSim__DiscreteForces(opensimMocoJNI.MocoProblemRep_getConstraintForces(swigCPtr, this), false);
  }

  /**
   *  This is a component inside ModelDisabledConstraints that you can use<br>
   *  to set the value of generalized accelerations UDot, for use in<br>
   *  implicit dynamics formulations. The motion is not necessarily enabled.
   */
  public SWIGTYPE_p_OpenSim__AccelerationMotion getAccelerationMotion() {
    return new SWIGTYPE_p_OpenSim__AccelerationMotion(opensimMocoJNI.MocoProblemRep_getAccelerationMotion(swigCPtr, this), false);
  }

  public int getNumStates() {
    return opensimMocoJNI.MocoProblemRep_getNumStates(swigCPtr, this);
  }

  public int getNumControls() {
    return opensimMocoJNI.MocoProblemRep_getNumControls(swigCPtr, this);
  }

  public int getNumParameters() {
    return opensimMocoJNI.MocoProblemRep_getNumParameters(swigCPtr, this);
  }

  /**
   *  Get the number of goals in cost mode.
   */
  public int getNumCosts() {
    return opensimMocoJNI.MocoProblemRep_getNumCosts(swigCPtr, this);
  }

  /**
   *  Get the number of goals in endpoint constraint mode.
   */
  public int getNumEndpointConstraints() {
    return opensimMocoJNI.MocoProblemRep_getNumEndpointConstraints(swigCPtr, this);
  }

  public int getNumKinematicConstraints() {
    return opensimMocoJNI.MocoProblemRep_getNumKinematicConstraints(swigCPtr, this);
  }

  /**
   *  Does the model contain a PositionMotion to prescribe all generalized<br>
   *  coordinates, speeds, and accelerations?
   */
  public boolean isPrescribedKinematics() {
    return opensimMocoJNI.MocoProblemRep_isPrescribedKinematics(swigCPtr, this);
  }

  /**
   *  Do we need to compute controls from the model (e.g., because the model<br>
   *  contains user-defined controllers)? If the model does not contain<br>
   *  user-defined controls, then we prefer to use the controls directly from<br>
   *  the optimal control problem, for efficiency.
   */
  public boolean getComputeControlsFromModel() {
    return opensimMocoJNI.MocoProblemRep_getComputeControlsFromModel(swigCPtr, this);
  }

  public int getNumImplicitAuxiliaryResiduals() {
    return opensimMocoJNI.MocoProblemRep_getNumImplicitAuxiliaryResiduals(swigCPtr, this);
  }

  /**
   *  This excludes generalized coordinate and speed states if<br>
   *  isPrescribedKinematics() is true.
   */
  public StdVectorString createStateVariableNamesInSystemOrder(SWIGTYPE_p_std__unordered_mapT_int_int_t yIndexMap) {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createStateVariableNamesInSystemOrder(swigCPtr, this, SWIGTYPE_p_std__unordered_mapT_int_int_t.getCPtr(yIndexMap)), true);
  }

  /**
   *  Get the state names of all the state infos.
   */
  public StdVectorString createStateInfoNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createStateInfoNames(swigCPtr, this), true);
  }

  /**
   *  Get the control names of all the control infos.
   */
  public StdVectorString createControlInfoNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createControlInfoNames(swigCPtr, this), true);
  }

  /**
   *  Get the control names of all the Input control infos.
   */
  public StdVectorString createInputControlInfoNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createInputControlInfoNames(swigCPtr, this), true);
  }

  /**
   *  Get the names of all the parameters.
   */
  public StdVectorString createParameterNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createParameterNames(swigCPtr, this), true);
  }

  /**
   *  Get the names of all the goals in cost mode.
   */
  public StdVectorString createCostNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createCostNames(swigCPtr, this), true);
  }

  /**
   *  Get the names of all the goals in endpoint constraint mode.
   */
  public StdVectorString createEndpointConstraintNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createEndpointConstraintNames(swigCPtr, this), true);
  }

  /**
   *  Get the names of all the MocoPathConstraint%s.
   */
  public StdVectorString createPathConstraintNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createPathConstraintNames(swigCPtr, this), true);
  }

  /**
   *  Get the names of all the Lagrange multiplier infos.
   */
  public StdVectorString createMultiplierInfoNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createMultiplierInfoNames(swigCPtr, this), true);
  }

  /**
   *  Get the constraint names of all the kinematic constraints. Note: this<br>
   *  should only be called after initialize().
   */
  public StdVectorString createKinematicConstraintNames() {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_createKinematicConstraintNames(swigCPtr, this), true);
  }

  /**
   *  Get a vector of names for all kinematic constraint equations.<br>
   *  Kinematic constraint equations are ordered as so:<br>
   *  - position-level constraints<br>
   *  - velocity-level constraints<br>
   *  - acceleration-level constraints<br>
   *  If includeDerivatives is true, the ordering is:<br>
   *  - position-level constraints<br>
   *  - first derivative of position-level constraints (denoted by suffix "d")<br>
   *  - velocity-level constraints<br>
   *  - second derivative of position-level constraints (suffix "dd")<br>
   *  - first derivative of velocity-level constraints (suffix "d")<br>
   *  - acceleration-level constraints
   */
  public StdVectorString getKinematicConstraintEquationNames(boolean includeDerivatives) {
    return new StdVectorString(opensimMocoJNI.MocoProblemRep_getKinematicConstraintEquationNames(swigCPtr, this, includeDerivatives), true);
  }

  /**
   *  Note: the return value is constructed fresh on every call from<br>
   *  the internal property. Avoid repeated calls to this function.
   */
  public MocoInitialBounds getTimeInitialBounds() {
    return new MocoInitialBounds(opensimMocoJNI.MocoProblemRep_getTimeInitialBounds(swigCPtr, this), true);
  }

  /**
   *  
   */
  public MocoFinalBounds getTimeFinalBounds() {
    return new MocoFinalBounds(opensimMocoJNI.MocoProblemRep_getTimeFinalBounds(swigCPtr, this), true);
  }

  /**
   *  Get information for state variables. See MocoPhase::setStateInfo().
   */
  public MocoVariableInfo getStateInfo(String name) {
    return new MocoVariableInfo(opensimMocoJNI.MocoProblemRep_getStateInfo(swigCPtr, this, name), false);
  }

  /**
   *  Get information for actuator controls.<br>
   *  If the control is associated with a non-scalar actuator (i.e. uses<br>
   *  multiple control variables), then the control name will be the actuator<br>
   *  path appended by the control index (e.g. "/actuator_0");<br>
   *  See MocoPhase::setControlInfo().
   */
  public MocoVariableInfo getControlInfo(String name) {
    return new MocoVariableInfo(opensimMocoJNI.MocoProblemRep_getControlInfo(swigCPtr, this, name), false);
  }

  /**
   *  Get information for Input control variables. <br>
   *  See MocoPhase::setInputControlInfo().
   */
  public MocoVariableInfo getInputControlInfo(String name) {
    return new MocoVariableInfo(opensimMocoJNI.MocoProblemRep_getInputControlInfo(swigCPtr, this, name), false);
  }

  /**
   *  Get whether an info object exists for an Input control.
   */
  public boolean hasInputControlInfo(String name) {
    return opensimMocoJNI.MocoProblemRep_hasInputControlInfo(swigCPtr, this, name);
  }

  /**
   *  Get information for a control or Input control variable. This internally<br>
   *  resolves whether the variable is a control or Input control based on <br>
   *  the variable name. This is intend for use by solvers, where both<br>
   *  controls and Input controls are treated as algebraic variables.
   */
  public MocoVariableInfo getSolverControlInfo(String name) {
    return new MocoVariableInfo(opensimMocoJNI.MocoProblemRep_getSolverControlInfo(swigCPtr, this, name), false);
  }

  /**
   *  Get information for a parameter. See MocoPhase::addParameter().
   */
  public MocoParameter getParameter(String name) {
    return new MocoParameter(opensimMocoJNI.MocoProblemRep_getParameter(swigCPtr, this, name), false);
  }

  /**
   *  Get a cost by name. This returns a MocoGoal in cost mode.
   */
  public MocoGoal getCost(String name) {
    return new MocoGoal(opensimMocoJNI.MocoProblemRep_getCost(swigCPtr, this, name), false);
  }

  /**
   *  Get a cost by index. The order is the same as in getCostNames().<br>
   *  Note: this does not perform a bounds check.
   */
  public MocoGoal getCostByIndex(int index) {
    return new MocoGoal(opensimMocoJNI.MocoProblemRep_getCostByIndex(swigCPtr, this, index), false);
  }

  /**
   *  Get an endpoint constraint by name. This returns a MocoGoal in endpoint<br>
   *  constraint mode.
   */
  public MocoGoal getEndpointConstraint(String name) {
    return new MocoGoal(opensimMocoJNI.MocoProblemRep_getEndpointConstraint(swigCPtr, this, name), false);
  }

  /**
   *  Get an endpoint constraint by index.<br>
   *  The order is the same as in getEndpointConstraintNames().<br>
   *  Note: this does not perform a bounds check.
   */
  public MocoGoal getEndpointConstraintByIndex(int index) {
    return new MocoGoal(opensimMocoJNI.MocoProblemRep_getEndpointConstraintByIndex(swigCPtr, this, index), false);
  }

  /**
   *  Get a MocoPathConstraint. Note: this does not<br>
   *  include MocoKinematicConstraints, use getKinematicConstraint() instead.
   */
  public MocoPathConstraint getPathConstraint(String name) {
    return new MocoPathConstraint(opensimMocoJNI.MocoProblemRep_getPathConstraint(swigCPtr, this, name), false);
  }

  /**
   *  Get a path constraint by index. The order is the same as<br>
   *  in getPathConstraintNames(). Note: this does not perform a bounds check.
   */
  public MocoPathConstraint getPathConstraintByIndex(int index) {
    return new MocoPathConstraint(opensimMocoJNI.MocoProblemRep_getPathConstraintByIndex(swigCPtr, this, index), false);
  }

  /**
   *  Get the number of scalar path constraints in the MocoProblem. This does<br>
   *  not include kinematic constraints equations.
   */
  public int getNumPathConstraintEquations() {
    return opensimMocoJNI.MocoProblemRep_getNumPathConstraintEquations(swigCPtr, this);
  }

  /**
   *  Get a MocoKinematicConstraint from this MocoPhase. Note: this does not<br>
   *  include MocoPathConstraints, use getPathConstraint() instead.
   */
  public MocoKinematicConstraint getKinematicConstraint(String name) {
    return new MocoKinematicConstraint(opensimMocoJNI.MocoProblemRep_getKinematicConstraint(swigCPtr, this, name), false);
  }

  /**
   *  Get the number of scalar kinematic constraints in the MocoProblem. This<br>
   *  does not include path constraints equations.
   */
  public int getNumKinematicConstraintEquations() {
    return opensimMocoJNI.MocoProblemRep_getNumKinematicConstraintEquations(swigCPtr, this);
  }

  /**
   *  Print a description of this problem, including costs and variable<br>
   *  bounds. Printing is done using OpenSim::log_info().
   */
  public void printDescription() {
    opensimMocoJNI.MocoProblemRep_printDescription(swigCPtr, this);
  }

  /**
   *  These functions are for use by MocoSolver%s, but can also be called<br>
   *  by users for debugging.<br>
   *  <br>
   *  Calculate the errors in all the scalar path constraint equations in this<br>
   *  phase.
   */
  public void calcPathConstraintErrors(State state, Vector errors) {
    opensimMocoJNI.MocoProblemRep_calcPathConstraintErrors(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(errors), errors);
  }

  /**
   *  Calculate the errors in all the scalar kinematic constraint equations in<br>
   *  this phase. This may not be the most efficient solution for solvers, but<br>
   *  is rather intended as a convenience method for a quick implementation or<br>
   *  for debugging model constraints causing issues in an optimal control<br>
   *  problem.
   */
  public Vector calcKinematicConstraintErrors(State state) {
    return new Vector(opensimMocoJNI.MocoProblemRep_calcKinematicConstraintErrors(swigCPtr, this, State.getCPtr(state), state), true);
  }

  /**
   *  Apply paramater values to the models created from the model passed to<br>
   *  initialize() within the current MocoProblem. Values must be consistent<br>
   *  with the order of parameters returned from createParameterNames().<br>
   * <br>
   *  Note: initSystem() must be called on each model after calls to this<br>
   *  method in order for provided parameter values to be applied to the<br>
   *  model. You can pass `true` to have initSystem() called for you, and to<br>
   *  also re-disable any constraints re-enabled by the initSystem() call<br>
   *  (see getModelDisabledConstraints()).
   */
  public void applyParametersToModelProperties(Vector parameterValues, boolean initSystemAndDisableConstraints) {
    opensimMocoJNI.MocoProblemRep_applyParametersToModelProperties__SWIG_0(swigCPtr, this, Vector.getCPtr(parameterValues), parameterValues, initSystemAndDisableConstraints);
  }

  /**
   *  Apply paramater values to the models created from the model passed to<br>
   *  initialize() within the current MocoProblem. Values must be consistent<br>
   *  with the order of parameters returned from createParameterNames().<br>
   * <br>
   *  Note: initSystem() must be called on each model after calls to this<br>
   *  method in order for provided parameter values to be applied to the<br>
   *  model. You can pass `true` to have initSystem() called for you, and to<br>
   *  also re-disable any constraints re-enabled by the initSystem() call<br>
   *  (see getModelDisabledConstraints()).
   */
  public void applyParametersToModelProperties(Vector parameterValues) {
    opensimMocoJNI.MocoProblemRep_applyParametersToModelProperties__SWIG_1(swigCPtr, this, Vector.getCPtr(parameterValues), parameterValues);
  }

  /**
   *  Get a vector of reference pointers to model outputs that return residual<br>
   *  values for any components with dynamics in implicit forms. The <br>
   *  references returned are from the model returned by <br>
   *  getModelDisabledConstraints(). 
   */
  public SWIGTYPE_p_std__vectorT_SimTK__ReferencePtrT_OpenSim__OutputT_double_t_const_t_t getImplicitResidualReferencePtrs() {
    return new SWIGTYPE_p_std__vectorT_SimTK__ReferencePtrT_OpenSim__OutputT_double_t_const_t_t(opensimMocoJNI.MocoProblemRep_getImplicitResidualReferencePtrs(swigCPtr, this), false);
  }

  /**
   *  Get reference pointers to components that enforce dynamics in implicit <br>
   *  form. This returns a vector of pairs including the name of the discrete<br>
   *  derivative variable and the component reference pointer.
   */
  public SWIGTYPE_p_std__vectorT_std__pairT_std__string_SimTK__ReferencePtrT_OpenSim__Component_const_t_t_t getImplicitComponentReferencePtrs() {
    return new SWIGTYPE_p_std__vectorT_std__pairT_std__string_SimTK__ReferencePtrT_OpenSim__Component_const_t_t_t(opensimMocoJNI.MocoProblemRep_getImplicitComponentReferencePtrs(swigCPtr, this), false);
  }

  /**
   *  Get the vector of all InputController controls. This includes both <br>
   *  controls from InputController%s added by the user and controls from the <br>
   *  ActuatorInputController added by MocoProblemRep. The SimTK::State <br>
   *  argument should be obtained from `updStateDisabledConstraints()`.
   */
  public Vector getInputControls(State stateDisabledConstraints) {
    return new Vector(opensimMocoJNI.MocoProblemRep_getInputControls(swigCPtr, this, State.getCPtr(stateDisabledConstraints), stateDisabledConstraints), false);
  }

  /**
   *  Get the vector of model controls. If the model contains user-defined<br>
   *  controllers, this function will compute the controls from the model.<br>
   *  Otherwise, it will return the controls directly from the<br>
   *  ControlDistributor. This function is intended for use by solvers to<br>
   *  compute controls needed by MocoGoal%s and MocoPathConstraint%s. The<br>
   *  SimTK::State argument should be obtain from<br>
   *  `updStateDisabledConstraints()`.
   */
  public Vector getControls(State stateDisabledConstraints) {
    return new Vector(opensimMocoJNI.MocoProblemRep_getControls(swigCPtr, this, State.getCPtr(stateDisabledConstraints), stateDisabledConstraints), false);
  }

  /**
   *  Get a vector of integers representing the indexes of Input controls in<br>
   *  the ControlDistributor's 'controls' Output. This function is intended<br>
   *  for use by solvers to account for Input controls when converting between<br>
   *  a MocoTrajectory and solver-specific trajectory types.
   */
  public StdVectorInt getInputControlIndexes() {
    return new StdVectorInt(opensimMocoJNI.MocoProblemRep_getInputControlIndexes(swigCPtr, this), true);
  }

}
