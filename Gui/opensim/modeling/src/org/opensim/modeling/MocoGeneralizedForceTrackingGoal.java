/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * <br>
 * Minimize the squared difference between a model generalized coordinate force and<br>
 * a reference force trajectory, summed over the generalized coordinates forces for<br>
 * which a reference is provided, and integrated over the phase. The reference can <br>
 * be provided as a file name to a STO or CSV file (or other file types for which <br>
 * there is a FileAdapter), or programmaticaly as a TimeSeriesTable via a <br>
 * TableProcessor.<br>
 * Tracking problems in direct collocation perform best when tracking smooth<br>
 * data, so it is recommended to filter the data in the reference you provide<br>
 * to the cost.<br>
 * <br>
 * 
 */
public class MocoGeneralizedForceTrackingGoal extends MocoGoal {
  private transient long swigCPtr;

  public MocoGeneralizedForceTrackingGoal(long cPtr, boolean cMemoryOwn) {
    super(opensimMocoJNI.MocoGeneralizedForceTrackingGoal_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(MocoGeneralizedForceTrackingGoal obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(MocoGeneralizedForceTrackingGoal obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimMocoJNI.delete_MocoGeneralizedForceTrackingGoal(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static MocoGeneralizedForceTrackingGoal safeDownCast(OpenSimObject obj) {
    long cPtr = opensimMocoJNI.MocoGeneralizedForceTrackingGoal_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new MocoGeneralizedForceTrackingGoal(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimMocoJNI.MocoGeneralizedForceTrackingGoal_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimMocoJNI.MocoGeneralizedForceTrackingGoal_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new MocoGeneralizedForceTrackingGoal(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimMocoJNI.MocoGeneralizedForceTrackingGoal_getConcreteClassName(swigCPtr, this);
  }

  public MocoGeneralizedForceTrackingGoal() {
    this(opensimMocoJNI.new_MocoGeneralizedForceTrackingGoal__SWIG_0(), true);
  }

  public MocoGeneralizedForceTrackingGoal(String name) {
    this(opensimMocoJNI.new_MocoGeneralizedForceTrackingGoal__SWIG_1(name), true);
  }

  public MocoGeneralizedForceTrackingGoal(String name, double weight) {
    this(opensimMocoJNI.new_MocoGeneralizedForceTrackingGoal__SWIG_2(name, weight), true);
  }

  /**
   *  The table containing reference trajectories for the generalized <br>
   *  coordinate forces to track. The column labels should follow the format<br>
   *  used by the OpenSim Inverse Dynamics Tool: the coordinates names with <br>
   *  suffixes denoting whether they are translational <br>
   *  (e.g. `pelvis_tx_force`) or rotational (e.g., `ankle_angle_r_moment`) <br>
   *  generalized forces. It is assumed that coordinates with <br>
   *  `Coordinate::MotionType::Coupled` are suffixed with `_force` (although <br>
   *  it recommend that these coordinates are ignored via  <br>
   *  `setIgnoreConstrainedCoordinates()`). The table is not loaded until the<br>
   *  MocoProblem initialized. 
   */
  public void setReference(TableProcessor ref) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_setReference(swigCPtr, this, TableProcessor.getCPtr(ref), ref);
  }

  /**
   *   ref)
   */
  public TableProcessor getReference() {
    return new TableProcessor(opensimMocoJNI.MocoGeneralizedForceTrackingGoal_getReference(swigCPtr, this), false);
  }

  /**
   *  The paths to model Force%s whose body and mobility forces will be<br>
   *  applied when computing generalized coordinate forces from inverse<br>
   *  dynamics. Paths should be specified using either full component path <br>
   *  names or regular expressions, but not both for the same Force.
   */
  public void setForcePaths(StdVectorString forcePaths) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_setForcePaths(swigCPtr, this, StdVectorString.getCPtr(forcePaths), forcePaths);
  }

  /**
   *   std::vector&lt;std::string&gt;&amp; forcePaths)
   */
  public StdVectorString getForcePaths() {
    return new StdVectorString(opensimMocoJNI.MocoGeneralizedForceTrackingGoal_getForcePaths(swigCPtr, this), true);
  }

  /**
   *  Set the tracking weight for the generalized force for an individual <br>
   *  coordinate. To remove a coordinate from the cost function, set its <br>
   *  weight to 0. If a weight is not specified for a coordinate, the default <br>
   *  weight is 1.0. If a weight is already set for the requested coordinate, <br>
   *  then the provided weight replaces the previous weight. Weight names <br>
   *  should match the column labels in the reference table (e.g., <br>
   *  `ankle_angle_r_moment`, `pelvis_tx_force`, etc.).
   */
  public void setWeightForGeneralizedForce(String name, double weight) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_setWeightForGeneralizedForce(swigCPtr, this, name, weight);
  }

  /**
   *  Set the tracking weight for all generalized forces whose names match the<br>
   *  regular expression pattern. Multiple pairs of patterns and weights can <br>
   *  be provided by calling this function multiple times. If a generalized<br>
   *  force matches multiple patterns, the weight associated with the last<br>
   *  pattern is used.
   */
  public void setWeightForGeneralizedForcePattern(String pattern, double weight) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_setWeightForGeneralizedForcePattern(swigCPtr, this, pattern, weight);
  }

  /**
   *  Set the MocoWeightSet to weight the generalized coordinate forces in<br>
   *  the cost. Replaces the weight set if it already exists.
   */
  public void setWeightSet(MocoWeightSet weightSet) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_setWeightSet(swigCPtr, this, MocoWeightSet.getCPtr(weightSet), weightSet);
  }

  /**
   *  Specify whether or not extra columns in the reference are allowed.<br>
   *  If set true, the extra references will be ignored by the cost.<br>
   *  If false, extra reference will cause an exception to be raised.
   */
  public void setAllowUnusedReferences(boolean tf) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_setAllowUnusedReferences(swigCPtr, this, tf);
  }

  /**
   *  Normalize the tracking error for each generalized force by the peak <br>
   *  magnitude of the force in the reference tracking data. If the peak <br>
   *  magnitude of the reference generalized force data is close to zero, an <br>
   *  exception is thrown (default: false).
   */
  public void setNormalizeTrackingError(boolean tf) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_setNormalizeTrackingError(swigCPtr, this, tf);
  }

  /**
   *   tf)
   */
  public boolean getNormalizeTrackingError() {
    return opensimMocoJNI.MocoGeneralizedForceTrackingGoal_getNormalizeTrackingError(swigCPtr, this);
  }

  /**
   *  Whether or not to ignore generalized forces for coordinates that are <br>
   *  locked, prescribed, or coupled to other coordinates. This is based on <br>
   *  the value returned from `Coordinate::isConstrained()` (default: true).
   */
  public void setIgnoreConstrainedCoordinates(boolean tf) {
    opensimMocoJNI.MocoGeneralizedForceTrackingGoal_setIgnoreConstrainedCoordinates(swigCPtr, this, tf);
  }

  /**
   *   tf)
   */
  public boolean getIgnoreConstrainedCoordinates() {
    return opensimMocoJNI.MocoGeneralizedForceTrackingGoal_getIgnoreConstrainedCoordinates(swigCPtr, this);
  }

}
