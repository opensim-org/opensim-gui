/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * <br>
 * The squared difference between a control<br>
 * variable value and a reference control variable value, summed over the control variables for which a<br>
 * reference is provided, and integrated over the phase. This can be used to<br>
 * track actuator controls, muscle excitations, etc.<br>
 * <br>
 * This goal is computed as follows:<br>
 * <br>
 *  
\int_{t_i}^{t_f}
        \sum_{c \in C} w_c \|x_{m,c}(t) - x_{e,c})\|^2 ~dt
<br>
 * We use the following notation:<br>
 * -   t_i : the initial time of this phase.<br>
 * -   t_f : the final time of this phase.<br>
 * -   C : the set of control variables being tracked.<br>
 * -   w_c : the weight for control   c .<br>
 * -   x_{m,c}(t) : control signal   c .<br>
 * -   x_{e,c}(t) : reference data for control signal   c .<br>
 * <br>
 * This goal has two labeling modes: 'auto' and 'manual':<br>
 * - 'auto': The column labels of the reference must exactly match the names<br>
 *           of controls, and all controls with a matching column in the<br>
 *           reference data are tracked. By default, all column labels for the<br>
 *           reference data must match the name of a control.<br>
 *           Setting `allow_unused_references` to false allows<br>
 *           the reference to contain columns whose labels do not match a<br>
 *           control; such columns are then ignored.<br>
 * - 'manual': The association between controls and columns of the reference<br>
 *             data is manually specified via the `reference_labels` property.<br>
 *             Only the controls for which a reference label is specified are<br>
 *             tracked.<br>
 *             Enter this mode by providing reference labels through<br>
 *             the `reference_labels` property or the `setReferenceLabel()`<br>
 *             function.<br>
 *             The `allow_unused_references` property does not apply in this<br>
 *             mode.<br>
 * <br>
 * ## Control variable names<br>
 * <br>
 * Control variable names are based on paths to actuators,<br>
 * e.g., `/forceset/soleus_r`. For non-scalar actuators, the control variable<br>
 * name includes the index for the actuator control;<br>
 * e.g., `/forceset/body_actuator_0`, where<br>
 * 'body_actuator' is the name of the actuator and `_0` specifies the<br>
 * control index.<br>
 * <br>
 * ## Reference data<br>
 * <br>
 * The reference can be provided as a file name to a STO or CSV file (or<br>
 * other file types for which there is a FileAdapter), or programmatically<br>
 * as a TimeSeriesTable.<br>
 * <br>
 * ## Scale factors<br>
 * <br>
 * Use `addScaleFactor()` to add a MocoParameter to the MocoProblem that will<br>
 * scale the tracking reference data associated with a control in the tracking cost.<br>
 * Scale factors for this goal can be useful if the magnitude of the tracking<br>
 * reference data is either unknown or unreliable (e.g., electromyography data).<br>
 * Scale factors are applied to the tracking error calculations based on the<br>
 * following equation:<br>
 * <br>
 *     error = modelValue - scaleFactor * referenceValue<br>
 * <br>
 * In other words, scale factors are applied when computing the tracking error for<br>
 * each control, not to the reference data directly. Therefore, if a column in the<br>
 * reference data is tracked by two different controls, the scale factor will only<br>
 * scale the column for the associated control. The tracking error for the other<br>
 * control is unaffected.<br>
 * <br>
 * Adding a scale factor to a MocoControlTrackingGoal.<br>
 * {@code 
auto* controlTrackingGoal = problem.addGoal<MocoControlTrackingGoal>();
...
controlTrackingGoal->addScaleFactor(
        'soleus_scale_factor', '/forceset/soleus_r', {0.01, 1.0});
}<br>
 * <br>
 * ## Helpful tips<br>
 * <br>
 * Tracking problems in direct collocation perform best when tracking smooth<br>
 * data, so it is recommended to filter the data in the reference you provide<br>
 * to the cost.<br>
 * 
 */
public class MocoControlTrackingGoal extends MocoGoal {
  private transient long swigCPtr;

  public MocoControlTrackingGoal(long cPtr, boolean cMemoryOwn) {
    super(opensimMocoJNI.MocoControlTrackingGoal_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(MocoControlTrackingGoal obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimMocoJNI.delete_MocoControlTrackingGoal(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

    public void addScaleFactor(String name, String control, double[] b)
            throws Exception {
            addScaleFactor(name, control, MocoPhase.convertArrayToMB(b));
    }

  public static MocoControlTrackingGoal safeDownCast(OpenSimObject obj) {
    long cPtr = opensimMocoJNI.MocoControlTrackingGoal_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new MocoControlTrackingGoal(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimMocoJNI.MocoControlTrackingGoal_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimMocoJNI.MocoControlTrackingGoal_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimMocoJNI.MocoControlTrackingGoal_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new MocoControlTrackingGoal(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimMocoJNI.MocoControlTrackingGoal_getConcreteClassName(swigCPtr, this);
  }

  public MocoControlTrackingGoal() {
    this(opensimMocoJNI.new_MocoControlTrackingGoal__SWIG_0(), true);
  }

  public MocoControlTrackingGoal(String name) {
    this(opensimMocoJNI.new_MocoControlTrackingGoal__SWIG_1(name), true);
  }

  public MocoControlTrackingGoal(String name, double weight) {
    this(opensimMocoJNI.new_MocoControlTrackingGoal__SWIG_2(name, weight), true);
  }

  /**
   *  Provide a table containing reference values for the<br>
   *  controls you want to track.<br>
   *  In 'auto' labeling mode, each column label must be a control variable<br>
   *  name. In 'manual' labeling mode, the column labels need not be control<br>
   *  variable names; use setReferenceLabel() to associate controls with<br>
   *  columns.<br>
   *  The table is not loaded until the MocoProblem is initialized.
   */
  public void setReference(TableProcessor ref) {
    opensimMocoJNI.MocoControlTrackingGoal_setReference(swigCPtr, this, TableProcessor.getCPtr(ref), ref);
  }

  /**
   *  Set the weight for an individual control variable. If a weight is<br>
   *  already set for the requested control, then the provided weight<br>
   *  replaces the previous weight.<br>
   *  If no weight is specified for a control, a weight of 1.0 is used<br>
   *  internally.<br>
   *  Set the weight to 0 to avoid tracking a given control.<br>
   *  An exception is thrown if a weight for an unknown control is provided.
   */
  public void setWeightForControl(String controlName, double weight) {
    opensimMocoJNI.MocoControlTrackingGoal_setWeightForControl(swigCPtr, this, controlName, weight);
  }

  /**
   *  Provide a MocoWeightSet to weight the control variables in the cost.<br>
   *  Replaces the weight set if it already exists.
   */
  public void setWeightSet(MocoWeightSet weightSet) {
    opensimMocoJNI.MocoControlTrackingGoal_setWeightSet(swigCPtr, this, MocoWeightSet.getCPtr(weightSet), weightSet);
  }

  /**
   *  Set the column of the reference data that a given control should track.<br>
   *  Multiple controls can track the same column of the reference data.<br>
   *  This replaces the reference label for the given control, if one had<br>
   *  already been provided.<br>
   *  If controls are not manually associated with a reference label, then<br>
   *  it is assumed that the column labels for the reference data exactly<br>
   *  match the names of controls.
   */
  public void setReferenceLabel(String control, String label) {
    opensimMocoJNI.MocoControlTrackingGoal_setReferenceLabel(swigCPtr, this, control, label);
  }

  /**
   *  Clear the 'reference_labels' property, which ensures this goal is used<br>
   *  in 'auto' labeling mode.
   */
  public void clearReferenceLabels() {
    opensimMocoJNI.MocoControlTrackingGoal_clearReferenceLabels(swigCPtr, this);
  }

  /**
   *  Specify whether the reference can have columns not associated with<br>
   *  controls.<br>
   *  If set true, then such columns will be ignored by the cost.<br>
   *  If false, such columns will cause an Exception to be raised.<br>
   *  Only takes effect in 'auto' labeling mode.
   */
  public void setAllowUnusedReferences(boolean tf) {
    opensimMocoJNI.MocoControlTrackingGoal_setAllowUnusedReferences(swigCPtr, this, tf);
  }

  /**
   *  If no reference has been provided, this returns an empty processor.
   */
  public TableProcessor getReference() {
    return new TableProcessor(opensimMocoJNI.MocoControlTrackingGoal_getReference(swigCPtr, this), false);
  }

  public boolean hasReferenceLabel(String control) {
    return opensimMocoJNI.MocoControlTrackingGoal_hasReferenceLabel(swigCPtr, this, control);
  }

  public String getReferenceLabel(String control) {
    return opensimMocoJNI.MocoControlTrackingGoal_getReferenceLabel(swigCPtr, this, control);
  }

  public boolean getAllowUnusedReferences() {
    return opensimMocoJNI.MocoControlTrackingGoal_getAllowUnusedReferences(swigCPtr, this);
  }

  /**
   *  Add a MocoParameter to the problem that will scale the tracking reference<br>
   *  data associated with the specified control. Scale factors are applied<br>
   *  to the tracking error calculations based on the following equation:<br>
   * <br>
   *      error = modelValue - scaleFactor * referenceValue<br>
   * <br>
   *  In other words, the scale factor is applied when computing the tracking<br>
   *  error for each control, not to the reference data directly. Therefore, if<br>
   *  a column in the reference data is tracked by two different controls, the<br>
   *  scale factor will only scale the column for the associated control. The<br>
   *  tracking error for the other control is unaffected.
   */
  public void addScaleFactor(String name, String control, MocoBounds bounds) {
    opensimMocoJNI.MocoControlTrackingGoal_addScaleFactor(swigCPtr, this, name, control, MocoBounds.getCPtr(bounds), bounds);
  }

}
