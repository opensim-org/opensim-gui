/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  This muscle model was published in De Groote et al. 2016. <br>
 * <br>
 * The parameters of the active force-length and force-velocity curves have<br>
 * been slightly modified from what was published to ensure the curves go<br>
 * through key points:<br>
 * - Active force-length curve goes through (1, 1).<br>
 * - Force-velocity curve goes through (-1, 0) and (0, 1).<br>
 * The default tendon force curve parameters are modified from that in De<br>
 * Groote et al., 2016: the curve is parameterized by the strain at 1 norm<br>
 * force (rather than "kT"), and the default value for this parameter is<br>
 * 0.049 (same as in TendonForceLengthCurve) rather than 0.0474.<br>
 * <br>
 * This implementation introduces the property 'active_force_width_scale' as <br>
 * an addition to the original model, which allows users to effectively make <br>
 * the active force-length curve wider. This property may be useful for <br>
 * improving the force-generating capacity of a muscle without increasing <br>
 * maximum isometric force. This property works by scaling the normalized<br>
 * fiber length when the active force-length curve is computed. For example, <br>
 * a scale factor of 2 means that the fiber muscle traverses half as far <br>
 * along the force-length curve in either direction.<br>
 * <br>
 * This implementation adds fiber damping as an addition to the original model. <br>
 * Users can specify this via the 'fiber_damping' property, and damping force<br>
 * along the fiber is computed by multiplying the property value by the <br>
 * normalized fiber velocity and max isometric force. If using this muscle for<br>
 * optimization, fiber damping is recommended as it can improve convergence.<br>
 * <br>
 * Note: If converting from Thelen2003Muscles via replaceMuscles(), fiber <br>
 *    damping will be set to zero since there is no damping in that muscle<br>
 *    model.<br>
 * <br>
 * This class supports tendon compliance dynamics in both explicit and implicit <br>
 * form (formulations 1 and 3 from De Groote et al. 2016). Both forms of the <br>
 * dynamics use normalized tendon force as the state variable (rather than the <br>
 * typical fiber length state). The explicit form is handled through the usual <br>
 * Component dynamics interface. The implicit form introduces an additional <br>
 * discrete state variable and cache variable in the SimTK::State for the <br>
 * derivative of normalized tendon force and muscle-tendon equilibrium residual <br>
 * respectively. In general, it is preferable to use the implicit form in <br>
 * optimization since it can be robust to arbitrary initial guesses (see De <br>
 * Groote et al. 2016). However, the implicit form is only for use with solvers <br>
 * that support implicit dynamics (i.e. Moco) and cannot be used to perform a <br>
 * time-stepping forward simulation with Manager; use explicit mode for <br>
 * time-stepping.<br>
 * <br>
 * <br>
 * The acceptable bounds for each property are enforced at model initialization.<br>
 * These bounds are:<br>
 *  - activation_time_constant: (0, inf]<br>
 *  - deactivation_time_constant: (0, inf]<br>
 *  - active_force_width_scale: [1, inf]<br>
 *  - fiber_damping: [0, inf]<br>
 *  - passive_fiber_strain_at_one_norm_force: (0, inf]<br>
 *  - tendon_strain_at_one_norm_force: (0, inf]<br>
 *  - pennation_angle_at_optimal: [0, Pi/2)<br>
 *  - default_activation: (0, inf]<br>
 *  - default_normalized_tendon_force: [0, 5]<br>
 * <br>
 * Note: The methods getMinNormalizedTendonForce() and<br>
 *    getMaxNormalizedTendonForce() provide these bounds for use in custom solvers.<br>
 * <br>
 * Note: Muscle properties can be optimized using MocoParameter. The acceptable<br>
 * bounds for each property are **not** enforced during parameter optimization, so<br>
 * the user must supply these bounds to MocoParameter.<br>
 * <br>
 * Note: The properties `default_activation` and `default_normalized_tendon_force`<br>
 * cannot be optimized because they are applied during model initialization only.<br>
 * <br>
 * <br>
 * <br>
 * The documentation for Muscle::MuscleLengthInfo states that the<br>
 * optimalFiberLength of a muscle is also its resting length, but this is not<br>
 * true for this muscle: there is a non-zero passive fiber force at the<br>
 * optimal fiber length.<br>
 * <br>
 * In the Muscle class, setIgnoreTendonCompliance() and<br>
 * setIngoreActivationDynamics() control modeling options, meaning these<br>
 * settings could theoretically be changed. However, for this class, the<br>
 * modeling option is ignored and the values of the ignore_tendon_compliance<br>
 * and ignore_activation_dynamics properties are used directly.<br>
 * <br>
 * De Groote, F., Kinney, A. L., Rao, A. V., &amp; Fregly, B. J. (2016). Evaluation<br>
 * of Direct Collocation Optimal Control Problem Formulations for Solving the<br>
 * Muscle Redundancy Problem. Annals of Biomedical Engineering, 44(10), 1â€“15.<br>
 * http://doi.org/10.1007/s10439-016-1591-9 
 */
public class DeGrooteFregly2016Muscle extends Muscle {
  private transient long swigCPtr;

  public DeGrooteFregly2016Muscle(long cPtr, boolean cMemoryOwn) {
    super(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(DeGrooteFregly2016Muscle obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(DeGrooteFregly2016Muscle obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimActuatorsAnalysesToolsJNI.delete_DeGrooteFregly2016Muscle(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static DeGrooteFregly2016Muscle safeDownCast(OpenSimObject obj) {
    long cPtr = opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new DeGrooteFregly2016Muscle(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new DeGrooteFregly2016Muscle(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getConcreteClassName(swigCPtr, this);
  }

  public void copyProperty_activation_time_constant(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_activation_time_constant(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public double get_activation_time_constant(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_activation_time_constant__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_activation_time_constant(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_activation_time_constant__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_activation_time_constant(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_activation_time_constant__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_activation_time_constant(double value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_activation_time_constant(swigCPtr, this, value);
  }

  public void constructProperty_activation_time_constant(double initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_activation_time_constant(swigCPtr, this, initValue);
  }

  public double get_activation_time_constant() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_activation_time_constant__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_activation_time_constant() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_activation_time_constant__SWIG_1(swigCPtr, this), false);
  }

  public void set_activation_time_constant(double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_activation_time_constant__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_deactivation_time_constant(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_deactivation_time_constant(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public double get_deactivation_time_constant(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_deactivation_time_constant__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_deactivation_time_constant(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_deactivation_time_constant__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_deactivation_time_constant(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_deactivation_time_constant__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_deactivation_time_constant(double value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_deactivation_time_constant(swigCPtr, this, value);
  }

  public void constructProperty_deactivation_time_constant(double initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_deactivation_time_constant(swigCPtr, this, initValue);
  }

  public double get_deactivation_time_constant() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_deactivation_time_constant__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_deactivation_time_constant() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_deactivation_time_constant__SWIG_1(swigCPtr, this), false);
  }

  public void set_deactivation_time_constant(double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_deactivation_time_constant__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_default_activation(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_default_activation(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public double get_default_activation(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_default_activation__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_default_activation(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_default_activation__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_default_activation(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_default_activation__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_default_activation(double value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_default_activation(swigCPtr, this, value);
  }

  public void constructProperty_default_activation(double initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_default_activation(swigCPtr, this, initValue);
  }

  public double get_default_activation() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_default_activation__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_default_activation() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_default_activation__SWIG_1(swigCPtr, this), false);
  }

  public void set_default_activation(double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_default_activation__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_default_normalized_tendon_force(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_default_normalized_tendon_force(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public double get_default_normalized_tendon_force(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_default_normalized_tendon_force__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_default_normalized_tendon_force(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_default_normalized_tendon_force__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_default_normalized_tendon_force(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_default_normalized_tendon_force__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_default_normalized_tendon_force(double value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_default_normalized_tendon_force(swigCPtr, this, value);
  }

  public void constructProperty_default_normalized_tendon_force(double initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_default_normalized_tendon_force(swigCPtr, this, initValue);
  }

  public double get_default_normalized_tendon_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_default_normalized_tendon_force__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_default_normalized_tendon_force() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_default_normalized_tendon_force__SWIG_1(swigCPtr, this), false);
  }

  public void set_default_normalized_tendon_force(double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_default_normalized_tendon_force__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_active_force_width_scale(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_active_force_width_scale(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public double get_active_force_width_scale(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_active_force_width_scale__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_active_force_width_scale(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_active_force_width_scale__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_active_force_width_scale(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_active_force_width_scale__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_active_force_width_scale(double value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_active_force_width_scale(swigCPtr, this, value);
  }

  public void constructProperty_active_force_width_scale(double initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_active_force_width_scale(swigCPtr, this, initValue);
  }

  public double get_active_force_width_scale() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_active_force_width_scale__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_active_force_width_scale() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_active_force_width_scale__SWIG_1(swigCPtr, this), false);
  }

  public void set_active_force_width_scale(double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_active_force_width_scale__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_fiber_damping(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_fiber_damping(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public double get_fiber_damping(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_fiber_damping__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_fiber_damping(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_fiber_damping__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_fiber_damping(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_fiber_damping__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_fiber_damping(double value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_fiber_damping(swigCPtr, this, value);
  }

  public void constructProperty_fiber_damping(double initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_fiber_damping(swigCPtr, this, initValue);
  }

  public double get_fiber_damping() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_fiber_damping__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_fiber_damping() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_fiber_damping__SWIG_1(swigCPtr, this), false);
  }

  public void set_fiber_damping(double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_fiber_damping__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_ignore_passive_fiber_force(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_ignore_passive_fiber_force(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public boolean get_ignore_passive_fiber_force(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_ignore_passive_fiber_force__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_bool upd_ignore_passive_fiber_force(int i) {
    return new SWIGTYPE_p_bool(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_ignore_passive_fiber_force__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_ignore_passive_fiber_force(int i, boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_ignore_passive_fiber_force__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_ignore_passive_fiber_force(boolean value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_ignore_passive_fiber_force(swigCPtr, this, value);
  }

  public void constructProperty_ignore_passive_fiber_force(boolean initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_ignore_passive_fiber_force(swigCPtr, this, initValue);
  }

  public boolean get_ignore_passive_fiber_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_ignore_passive_fiber_force__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_bool upd_ignore_passive_fiber_force() {
    return new SWIGTYPE_p_bool(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_ignore_passive_fiber_force__SWIG_1(swigCPtr, this), false);
  }

  public void set_ignore_passive_fiber_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_ignore_passive_fiber_force__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_passive_fiber_strain_at_one_norm_force(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public double get_passive_fiber_strain_at_one_norm_force(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_passive_fiber_strain_at_one_norm_force__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_passive_fiber_strain_at_one_norm_force(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_passive_fiber_strain_at_one_norm_force__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_passive_fiber_strain_at_one_norm_force(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_passive_fiber_strain_at_one_norm_force__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_passive_fiber_strain_at_one_norm_force(double value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_passive_fiber_strain_at_one_norm_force(swigCPtr, this, value);
  }

  public void constructProperty_passive_fiber_strain_at_one_norm_force(double initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_passive_fiber_strain_at_one_norm_force(swigCPtr, this, initValue);
  }

  public double get_passive_fiber_strain_at_one_norm_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_passive_fiber_strain_at_one_norm_force__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_passive_fiber_strain_at_one_norm_force() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_passive_fiber_strain_at_one_norm_force__SWIG_1(swigCPtr, this), false);
  }

  public void set_passive_fiber_strain_at_one_norm_force(double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_passive_fiber_strain_at_one_norm_force__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_tendon_strain_at_one_norm_force(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public double get_tendon_strain_at_one_norm_force(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_tendon_strain_at_one_norm_force__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_double upd_tendon_strain_at_one_norm_force(int i) {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_tendon_strain_at_one_norm_force__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_tendon_strain_at_one_norm_force(int i, double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_tendon_strain_at_one_norm_force__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_tendon_strain_at_one_norm_force(double value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_tendon_strain_at_one_norm_force(swigCPtr, this, value);
  }

  public void constructProperty_tendon_strain_at_one_norm_force(double initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_tendon_strain_at_one_norm_force(swigCPtr, this, initValue);
  }

  public double get_tendon_strain_at_one_norm_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_tendon_strain_at_one_norm_force__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_double upd_tendon_strain_at_one_norm_force() {
    return new SWIGTYPE_p_double(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_tendon_strain_at_one_norm_force__SWIG_1(swigCPtr, this), false);
  }

  public void set_tendon_strain_at_one_norm_force(double value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_tendon_strain_at_one_norm_force__SWIG_1(swigCPtr, this, value);
  }

  public void copyProperty_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle source) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_copyProperty_tendon_compliance_dynamics_mode(swigCPtr, this, DeGrooteFregly2016Muscle.getCPtr(source), source);
  }

  public String get_tendon_compliance_dynamics_mode(int i) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_tendon_compliance_dynamics_mode__SWIG_0(swigCPtr, this, i);
  }

  public SWIGTYPE_p_std__string upd_tendon_compliance_dynamics_mode(int i) {
    return new SWIGTYPE_p_std__string(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_tendon_compliance_dynamics_mode__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_tendon_compliance_dynamics_mode(int i, String value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_tendon_compliance_dynamics_mode__SWIG_0(swigCPtr, this, i, value);
  }

  public int append_tendon_compliance_dynamics_mode(String value) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_append_tendon_compliance_dynamics_mode(swigCPtr, this, value);
  }

  public void constructProperty_tendon_compliance_dynamics_mode(String initValue) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_constructProperty_tendon_compliance_dynamics_mode(swigCPtr, this, initValue);
  }

  public String get_tendon_compliance_dynamics_mode() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_get_tendon_compliance_dynamics_mode__SWIG_1(swigCPtr, this);
  }

  public SWIGTYPE_p_std__string upd_tendon_compliance_dynamics_mode() {
    return new SWIGTYPE_p_std__string(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_upd_tendon_compliance_dynamics_mode__SWIG_1(swigCPtr, this), false);
  }

  public void set_tendon_compliance_dynamics_mode(String value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_set_tendon_compliance_dynamics_mode__SWIG_1(swigCPtr, this, value);
  }

  public void set_has_output_passive_fiber_elastic_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_elastic_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_elastic_force_along_tendon(boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_along_tendon_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_elastic_force_along_tendon() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_along_tendon_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_damping_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_damping_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_get(swigCPtr, this);
  }

  public void set_has_output_passive_fiber_damping_force_along_tendon(boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_along_tendon_set(swigCPtr, this, value);
  }

  public boolean get_has_output_passive_fiber_damping_force_along_tendon() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_along_tendon_get(swigCPtr, this);
  }

  public void set_has_output_implicitresidual_normalized_tendon_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_implicitresidual_normalized_tendon_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_implicitresidual_normalized_tendon_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_implicitresidual_normalized_tendon_force_get(swigCPtr, this);
  }

  public void set_has_output_implicitenabled_normalized_tendon_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_implicitenabled_normalized_tendon_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_implicitenabled_normalized_tendon_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_implicitenabled_normalized_tendon_force_get(swigCPtr, this);
  }

  public void set_has_output_statebounds_normalized_tendon_force(boolean value) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_statebounds_normalized_tendon_force_set(swigCPtr, this, value);
  }

  public boolean get_has_output_statebounds_normalized_tendon_force() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle__has_output_statebounds_normalized_tendon_force_get(swigCPtr, this);
  }

  public DeGrooteFregly2016Muscle() {
    this(opensimActuatorsAnalysesToolsJNI.new_DeGrooteFregly2016Muscle(), true);
  }

  /**
   *  <br>
   *  If ignore_activation_dynamics is true, this gets excitation instead.
   */
  public double getActivation(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getActivation(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  If ignore_activation_dynamics is true, this sets excitation instead.
   */
  public void setActivation(State s, double activation) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_setActivation(swigCPtr, this, State.getCPtr(s), s, activation);
  }

  /**
   *  In this method, calcEquilibriumResidual() is used to find a value of the<br>
   *  normalized tendon force state variable that produces muscle-tendon<br>
   *  equilibrium. This relies on the implicit form of tendon compliance since<br>
   *  the explicit form uses the normalized tendon force state variable<br>
   *  directly to compute fiber force, which always produces a zero<br>
   *  muscle-tendon equilibrium residual. The derivative of normalized tendon<br>
   *  force is set to zero since a value is required for the implicit form of<br>
   *  the model.  
   */
  public void computeInitialFiberEquilibrium(State s) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_computeInitialFiberEquilibrium(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  <br>
   *  <br>
   *  Get the portion of the passive fiber force generated by the elastic<br>
   *  element only (N).
   */
  public double getPassiveFiberElasticForce(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getPassiveFiberElasticForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Get the portion of the passive fiber force generated by the elastic<br>
   *  element only, projected onto the tendon direction (N).
   */
  public double getPassiveFiberElasticForceAlongTendon(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getPassiveFiberElasticForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Get the portion of the passive fiber force generated by the damping<br>
   *  element only (N).
   */
  public double getPassiveFiberDampingForce(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getPassiveFiberDampingForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Get the portion of the passive fiber force generated by the damping<br>
   *  element only, projected onto the tendon direction (N).
   */
  public double getPassiveFiberDampingForceAlongTendon(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getPassiveFiberDampingForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Get whether fiber dynamics is in implicit dynamics mode when using <br>
   *  normalized tendon force as the state. This is useful to indicate to <br>
   *  solvers to handle the normalized tendon force derivative and <br>
   *  muscle-tendon equilibrium variables, which are added to the State as <br>
   *  discrete and cache variables, respectively.<br>
   *  This function is intended primarily for the model Output <br>
   *  'implicitenabled_normalized_tendon_force'. We don't need the state, but <br>
   *  the state parameter is a requirement of Output functions.
   */
  public boolean getImplicitEnabledNormalizedTendonForce(State arg0) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getImplicitEnabledNormalizedTendonForce(swigCPtr, this, State.getCPtr(arg0), arg0);
  }

  /**
   *  Compute the muscle-tendon force equilibrium residual value when using<br>
   *  implicit contraction dynamics with normalized tendon force as the<br>
   *  state.<br>
   *  This function is intended primarily for the model Output <br>
   *  'implicitresidual_normalized_tendon_force'. 
   */
  public double getImplicitResidualNormalizedTendonForce(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getImplicitResidualNormalizedTendonForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  If ignore_tendon_compliance is true, this gets normalized fiber force<br>
   *  along the tendon instead.
   */
  public double getNormalizedTendonForce(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getNormalizedTendonForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Obtain the time derivative of the normalized tendon force.<br>
   *  - If ignore_tendon_compliance is false, this returns zero.<br>
   *  - If tendon_compliance_dynamics_mode is 'implicit', this gets the<br>
   *  discrete variable normalized tendon force derivative value.<br>
   *  - If tendon_compliance_dynamics_mode is 'explicit', this gets the value<br>
   *  returned by getStateVariableDerivativeValue() for the<br>
   *  'normalized_tendon_force' state.
   */
  public double getNormalizedTendonForceDerivative(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getNormalizedTendonForceDerivative(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  <br>
   *  This calls calcEquilibriumResidual() using values from the provided <br>
   *  SimTK::State as arguments. While is computed using implicit mode, the <br>
   *  value of normalized tendon force derivative used *is* consistent with <br>
   *  the property `tendon_compliance_dynamics_mode` (see<br>
   *  getNormalizedTendonForceDerivative()).
   */
  public double getEquilibriumResidual(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getEquilibriumResidual(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  
   */
  public double getLinearizedEquilibriumResidualDerivative(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getLinearizedEquilibriumResidualDerivative(swigCPtr, this, State.getCPtr(s), s);
  }

  public static String getActivationStateName() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getActivationStateName();
  }

  public static String getNormalizedTendonForceStateName() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getNormalizedTendonForceStateName();
  }

  public static String getImplicitDynamicsDerivativeName() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getImplicitDynamicsDerivativeName();
  }

  public static String getImplicitDynamicsResidualName() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getImplicitDynamicsResidualName();
  }

  public static double getMinNormalizedTendonForce() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getMinNormalizedTendonForce();
  }

  public static double getMaxNormalizedTendonForce() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getMaxNormalizedTendonForce();
  }

  /**
   *  The first element of the Vec2 is the lower bound, and the second is the<br>
   *  upper bound.<br>
   *  This function is intended primarily for the model Output <br>
   *  'statebounds_normalized_tendon_force'. We don't need the state, but the <br>
   *  state parameter is a requirement of Output functions.
   */
  public Vec2 getBoundsNormalizedTendonForce(State arg0) {
    return new Vec2(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getBoundsNormalizedTendonForce(swigCPtr, this, State.getCPtr(arg0), arg0), true);
  }

  public static double getMinNormalizedFiberLength() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getMinNormalizedFiberLength();
  }

  public static double getMaxNormalizedFiberLength() {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getMaxNormalizedFiberLength();
  }

  /**
   *  The first element of the Vec2 is the lower bound, and the second is the<br>
   *  upper bound.<br>
   *  Note that since fiber length is not used as a state variable, these<br>
   *  bounds cannot be enforced directly. It is upon the user to ensure the<br>
   *  muscle fiber is operating within the specified domain.
   */
  public Vec2 getBoundsNormalizedFiberLength() {
    return new Vec2(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_getBoundsNormalizedFiberLength(swigCPtr, this), true);
  }

  /**
   *  <br>
   *  <br>
   *  If ignore_tendon_compliance is true, this sets nothing.
   */
  public void setNormalizedTendonForce(State s, double normTendonForce) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_setNormalizedTendonForce(swigCPtr, this, State.getCPtr(s), s, normTendonForce);
  }

  /**
   *  <br>
   *  These functions compute the values of normalized/dimensionless curves,<br>
   *  their derivatives and integrals, and other quantities of the muscle.<br>
   *  These do not depend on a SimTK::State.<br>
   *  <br>
   *  The active force-length curve is the sum of 3 Gaussian-like curves. The<br>
   *  width of the curve can be adjusted via the 'active_force_width_scale'<br>
   *  property.
   */
  public double calcActiveForceLengthMultiplier(double normFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcActiveForceLengthMultiplier(swigCPtr, this, normFiberLength);
  }

  /**
   *  The derivative of the active force-length curve with respect to<br>
   *  normalized fiber length. This curve is based on the derivative of the<br>
   *  Gaussian-like curve used in calcActiveForceLengthMultiplier(). The<br>
   *  'active_force_width_scale' property also affects the value of the<br>
   *  derivative curve.
   */
  public double calcActiveForceLengthMultiplierDerivative(double normFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcActiveForceLengthMultiplierDerivative(swigCPtr, this, normFiberLength);
  }

  /**
   *  The parameters of this curve are not modifiable, so this function is<br>
   *  static.<br>
   *  Domain: [-1, 1]<br>
   *  Range: [0, 1.794]<br>
   *  Note: It is upon the user to check that the muscle fiber is acting <br>
   *        within the specified domain. Force computations outside this range<br>
   *        may be incorrect.
   */
  public static double calcForceVelocityMultiplier(double normFiberVelocity) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcForceVelocityMultiplier(normFiberVelocity);
  }

  /**
   *  This is the inverse of the force-velocity multiplier function, and<br>
   *  returns the normalized fiber velocity (in [-1, 1]) as a function of<br>
   *  the force-velocity multiplier.
   */
  public static double calcForceVelocityInverseCurve(double forceVelocityMult) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcForceVelocityInverseCurve(forceVelocityMult);
  }

  /**
   *  This is the passive force-length curve. The curve becomes negative below<br>
   *  the minNormFiberLength.<br>
   * <br>
   *  We modified this equation from that in the supplementary materials of De<br>
   *  Groote et al., 2016, which is the same function used in<br>
   *  Thelen2003Muscle. The version in the supplementary materials passes<br>
   *  through y = 0 at x = 1.0 and allows for negative forces. We do not want<br>
   *  negative forces within the allowed range of fiber lengths, so we<br>
   *  modified the equation to pass through y = 0 at x = minNormFiberLength. <br>
   *  (This is not an issue for Thelen2003Muscle because the curve is not <br>
   *  smooth and returns 0 for lengths less than optimal fiber length.)
   */
  public double calcPassiveForceMultiplier(double normFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcPassiveForceMultiplier(swigCPtr, this, normFiberLength);
  }

  /**
   *  This is the derivative of the passive force-length curve with respect to<br>
   *  the normalized fiber length.
   */
  public double calcPassiveForceMultiplierDerivative(double normFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcPassiveForceMultiplierDerivative(swigCPtr, this, normFiberLength);
  }

  /**
   *  This is the integral of the passive force-length curve with respect to<br>
   *  the normalized fiber length over the domain<br>
   *  [minNormFiberLength normFiberLength], where minNormFiberLength is the<br>
   *  value return by getMinNormalizedFiberLength().
   */
  public double calcPassiveForceMultiplierIntegral(double normFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcPassiveForceMultiplierIntegral(swigCPtr, this, normFiberLength);
  }

  /**
   *  The normalized tendon force as a function of normalized tendon length.<br>
   *  Note that this curve does not go through (1, 0); when<br>
   *  normTendonLength=1, this function returns a slightly negative number.
   */
  public double calcTendonForceMultiplier(double normTendonLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcTendonForceMultiplier(swigCPtr, this, normTendonLength);
  }

  /**
   *  This is the derivative of the tendon-force length curve with respect to<br>
   *  normalized tendon length.
   */
  public double calcTendonForceMultiplierDerivative(double normTendonLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcTendonForceMultiplierDerivative(swigCPtr, this, normTendonLength);
  }

  /**
   *  This is the integral of the tendon-force length curve with respect to<br>
   *  normalized tendon length over the domain<br>
   *  [minNormTendonLength normTendonLength]. The lower bound on the domain<br>
   *  is computed by passing the value return by getMinNormalizedTendonForce()<br>
   *  to calcTendonForceLengthInverseCurve(). 
   */
  public double calcTendonForceMultiplierIntegral(double normTendonLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcTendonForceMultiplierIntegral(swigCPtr, this, normTendonLength);
  }

  /**
   *  This is the inverse of the tendon force-length curve, and returns the<br>
   *  normalized tendon length as a function of the normalized tendon force.
   */
  public double calcTendonForceLengthInverseCurve(double normTendonForce) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcTendonForceLengthInverseCurve(swigCPtr, this, normTendonForce);
  }

  /**
   *  This returns normalized tendon velocity given the derivative of <br>
   *  normalized tendon force and normalized tendon length. This is derived<br>
   *  by taking the derivative of the tendon force multiplier curve with <br>
   *  respect to time and then solving for normalized fiber velocity (see<br>
   *  supplementary information for De Groote et al. 2016).
   */
  public double calcTendonForceLengthInverseCurveDerivative(double derivNormTendonForce, double normTendonLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcTendonForceLengthInverseCurveDerivative(swigCPtr, this, derivNormTendonForce, normTendonLength);
  }

  /**
   *  This computes both the total fiber force and the individual components<br>
   *  of fiber force (active, conservative passive, and non-conservative<br>
   *  passive).<br>
   *  Note: based on Millard2012EquilibriumMuscle::calcFiberForce().
   */
  public void calcFiberForce(double activation, double activeForceLengthMultiplier, double forceVelocityMultiplier, double normPassiveFiberForce, double normFiberVelocity, SWIGTYPE_p_double activeFiberForce, SWIGTYPE_p_double conPassiveFiberForce, SWIGTYPE_p_double nonConPassiveFiberForce, SWIGTYPE_p_double totalFiberForce) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcFiberForce(swigCPtr, this, activation, activeForceLengthMultiplier, forceVelocityMultiplier, normPassiveFiberForce, normFiberVelocity, SWIGTYPE_p_double.getCPtr(activeFiberForce), SWIGTYPE_p_double.getCPtr(conPassiveFiberForce), SWIGTYPE_p_double.getCPtr(nonConPassiveFiberForce), SWIGTYPE_p_double.getCPtr(totalFiberForce));
  }

  /**
   *  The stiffness of the fiber in the direction of the fiber. This includes<br>
   *  both active and passive force contributions to stiffness from the muscle<br>
   *  fiber.<br>
   *  Note: based on Millard2012EquilibriumMuscle::calcFiberStiffness().
   */
  public double calcFiberStiffness(double activation, double normFiberLength, double fiberVelocityMultiplier) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcFiberStiffness(swigCPtr, this, activation, normFiberLength, fiberVelocityMultiplier);
  }

  /**
   *  The stiffness of the tendon in the direction of the tendon.<br>
   *  Note: based on Millard2012EquilibriumMuscle.
   */
  public double calcTendonStiffness(double normTendonLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcTendonStiffness(swigCPtr, this, normTendonLength);
  }

  /**
   *  The stiffness of the whole musculotendon unit in the direction of the<br>
   *  tendon.<br>
   *  Note: based on Millard2012EquilibriumMuscle.
   */
  public double calcMuscleStiffness(double tendonStiffness, double fiberStiffnessAlongTendon) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcMuscleStiffness__SWIG_0(swigCPtr, this, tendonStiffness, fiberStiffnessAlongTendon);
  }

  public double calcMuscleStiffness(State s) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcMuscleStiffness__SWIG_1(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  The derivative of pennation angle with respect to fiber length.<br>
   *  Note: based on<br>
   *  MuscleFixedWidthPennationModel::calc_DPennationAngle_DFiberLength().
   */
  public double calcPartialPennationAnglePartialFiberLength(double fiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcPartialPennationAnglePartialFiberLength(swigCPtr, this, fiberLength);
  }

  /**
   *  The derivative of the fiber force along the tendon with respect to fiber<br>
   *  length.<br>
   *  Note: based on<br>
   *  Millard2012EquilibriumMuscle::calc_DFiberForceAT_DFiberLength().
   */
  public double calcPartialFiberForceAlongTendonPartialFiberLength(double fiberForce, double fiberStiffness, double sinPennationAngle, double cosPennationAngle, double partialPennationAnglePartialFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcPartialFiberForceAlongTendonPartialFiberLength(swigCPtr, this, fiberForce, fiberStiffness, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength);
  }

  /**
   *  The derivative of the fiber force along the tendon with respect to the<br>
   *  fiber length along the tendon.<br>
   *  Note: based on<br>
   *  Millard2012EquilibriumMuscle::calc_DFiberForceAT_DFiberLengthAT.
   */
  public double calcFiberStiffnessAlongTendon(double fiberLength, double partialFiberForceAlongTendonPartialFiberLength, double sinPennationAngle, double cosPennationAngle, double partialPennationAnglePartialFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcFiberStiffnessAlongTendon(swigCPtr, this, fiberLength, partialFiberForceAlongTendonPartialFiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength);
  }

  public double calcPartialTendonLengthPartialFiberLength(double fiberLength, double sinPennationAngle, double cosPennationAngle, double partialPennationAnglePartialFiberLength) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcPartialTendonLengthPartialFiberLength(swigCPtr, this, fiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength);
  }

  public double calcPartialTendonForcePartialFiberLength(double tendonStiffness, double fiberLength, double sinPennationAngle, double cosPennationAngle) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcPartialTendonForcePartialFiberLength(swigCPtr, this, tendonStiffness, fiberLength, sinPennationAngle, cosPennationAngle);
  }

  /**
   *  The residual (i.e. error) in the muscle-tendon equilibrium equation:<br>
   *      residual = normTendonForce - normFiberForce * cosPennationAngle<br>
   *  The residual is unitless (units of normalized force).<br>
   *  This is computed using the muscle in implicit mode, since explicit mode<br>
   *  uses the normalized tendon force state variable directly<br>
   *  to compute fiber force, which always produces a zero muscle-tendon<br>
   *  equilibrium residual. 
   */
  public double calcEquilibriumResidual(double muscleTendonLength, double muscleTendonVelocity, double activation, double normTendonForce, double normTendonForceDerivative) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcEquilibriumResidual(swigCPtr, this, muscleTendonLength, muscleTendonVelocity, activation, normTendonForce, normTendonForceDerivative);
  }

  /**
   *  The residual (i.e. error) in the time derivative of the linearized<br>
   *  muscle-tendon equilibrium equation (Millard et al. 2013, equation A6):<br>
   *      residual = fiberStiffnessAlongTendon * fiberVelocityAlongTendon -<br>
   *                 tendonStiffness *<br>
   *                     (muscleTendonVelocity - fiberVelocityAlongTendon)<br>
   *  This may be useful for finding equilibrium when there is velocity in the<br>
   *  muscle-tendon actuator. Velocity is divided between the muscle and<br>
   *  tendon based on their relative stiffnesses. 
   */
  public double calcLinearizedEquilibriumResidualDerivative(double muscleTendonLength, double muscleTendonVelocity, double activation, double normTendonForce, double normTendonForceDerivative) {
    return opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_calcLinearizedEquilibriumResidualDerivative(swigCPtr, this, muscleTendonLength, muscleTendonVelocity, activation, normTendonForce, normTendonForceDerivative);
  }

  /**
   *  <br>
   *  <br>
   *  Export the active force-length multiplier and passive force multiplier<br>
   *  curves to a DataTable. If the normFiberLengths argument is omitted, we<br>
   *  use createVectorLinspace(200, minNormFiberLength, maxNormFiberLength).
   */
  public DataTable exportFiberLengthCurvesToTable(Vector normFiberLengths) {
    return new DataTable(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_exportFiberLengthCurvesToTable__SWIG_0(swigCPtr, this, Vector.getCPtr(normFiberLengths), normFiberLengths), true);
  }

  /**
   *  <br>
   *  <br>
   *  Export the active force-length multiplier and passive force multiplier<br>
   *  curves to a DataTable. If the normFiberLengths argument is omitted, we<br>
   *  use createVectorLinspace(200, minNormFiberLength, maxNormFiberLength).
   */
  public DataTable exportFiberLengthCurvesToTable() {
    return new DataTable(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_exportFiberLengthCurvesToTable__SWIG_1(swigCPtr, this), true);
  }

  /**
   *  Export the fiber force-velocity multiplier curve to a DataTable. If<br>
   *  the normFiberVelocities argument is omitted, we use<br>
   *  createVectorLinspace(200, -1.1, 1.1).
   */
  public DataTable exportFiberVelocityMultiplierToTable(Vector normFiberVelocities) {
    return new DataTable(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_exportFiberVelocityMultiplierToTable__SWIG_0(swigCPtr, this, Vector.getCPtr(normFiberVelocities), normFiberVelocities), true);
  }

  /**
   *  Export the fiber force-velocity multiplier curve to a DataTable. If<br>
   *  the normFiberVelocities argument is omitted, we use<br>
   *  createVectorLinspace(200, -1.1, 1.1).
   */
  public DataTable exportFiberVelocityMultiplierToTable() {
    return new DataTable(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_exportFiberVelocityMultiplierToTable__SWIG_1(swigCPtr, this), true);
  }

  /**
   *  Export the fiber tendon force multiplier curve to a DataTable. If<br>
   *  the normFiberVelocities argument is omitted, we use<br>
   *  createVectorLinspace(200, 0.95, 1 + &lt;strain at 1 norm force&gt;)
   */
  public DataTable exportTendonForceMultiplierToTable(Vector normTendonLengths) {
    return new DataTable(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_exportTendonForceMultiplierToTable__SWIG_0(swigCPtr, this, Vector.getCPtr(normTendonLengths), normTendonLengths), true);
  }

  /**
   *  Export the fiber tendon force multiplier curve to a DataTable. If<br>
   *  the normFiberVelocities argument is omitted, we use<br>
   *  createVectorLinspace(200, 0.95, 1 + &lt;strain at 1 norm force&gt;)
   */
  public DataTable exportTendonForceMultiplierToTable() {
    return new DataTable(opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_exportTendonForceMultiplierToTable__SWIG_1(swigCPtr, this), true);
  }

  /**
   *  Print the muscle curves to STO files. The files will be named as<br>
   *  `&lt;muscle-name&gt;_&lt;curve_type&gt;.sto`.<br>
   * <br>
   *  @param directory<br>
   *      The directory to which the data files should be written. Do NOT<br>
   *      include the filename. By default, the files are printed to the<br>
   *      current working directory.
   */
  public void printCurvesToSTOFiles(String directory) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_printCurvesToSTOFiles__SWIG_0(swigCPtr, this, directory);
  }

  /**
   *  Print the muscle curves to STO files. The files will be named as<br>
   *  `&lt;muscle-name&gt;_&lt;curve_type&gt;.sto`.<br>
   * <br>
   *  
   */
  public void printCurvesToSTOFiles() {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_printCurvesToSTOFiles__SWIG_1(swigCPtr, this);
  }

  /**
   *  Replace muscles of other types in the model with muscles of this type.<br>
   *  Currently, only Millard2012EquilibriumMuscles and Thelen2003Muscles<br>
   *  are replaced. For these two muscle classes, we copy property values into<br>
   *  equivalent properties of the newly created DeGrooteFregly2016Muscle. <br>
   *  If the model has muscles of other types, an exception is<br>
   *  thrown unless allowUnsupportedMuscles is true, in which a<br>
   *  DeGrooteFregly2016Muscle is created using only the base Muscle class <br>
   *  property values. <br>
   *  Since the DeGrooteFregly2016Muscle implements tendon compliance dynamics<br>
   *  with normalized tendon force as the state variable, this function<br>
   *  ignores the 'default_fiber_length' property in replaced muscles.
   */
  public static void replaceMuscles(Model model, boolean allowUnsupportedMuscles) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_replaceMuscles__SWIG_0(Model.getCPtr(model), model, allowUnsupportedMuscles);
  }

  /**
   *  Replace muscles of other types in the model with muscles of this type.<br>
   *  Currently, only Millard2012EquilibriumMuscles and Thelen2003Muscles<br>
   *  are replaced. For these two muscle classes, we copy property values into<br>
   *  equivalent properties of the newly created DeGrooteFregly2016Muscle. <br>
   *  If the model has muscles of other types, an exception is<br>
   *  thrown unless allowUnsupportedMuscles is true, in which a<br>
   *  DeGrooteFregly2016Muscle is created using only the base Muscle class <br>
   *  property values. <br>
   *  Since the DeGrooteFregly2016Muscle implements tendon compliance dynamics<br>
   *  with normalized tendon force as the state variable, this function<br>
   *  ignores the 'default_fiber_length' property in replaced muscles.
   */
  public static void replaceMuscles(Model model) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_replaceMuscles__SWIG_1(Model.getCPtr(model), model);
  }

  /**
   *  <br>
   *  <br>
   *  Adjust the properties of the muscle after the model has been scaled. The<br>
   *  optimal fiber length and tendon slack length are each multiplied by the<br>
   *  ratio of the current path length and the path length before scaling.
   */
  public void extendPostScale(State s, ScaleSet scaleSet) {
    opensimActuatorsAnalysesToolsJNI.DeGrooteFregly2016Muscle_extendPostScale(swigCPtr, this, State.getCPtr(s), s, ScaleSet.getCPtr(scaleSet), scaleSet);
  }

}
