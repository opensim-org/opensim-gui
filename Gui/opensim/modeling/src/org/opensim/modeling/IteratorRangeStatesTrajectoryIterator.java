/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  Helper class to use range-based for loops with a pair of iterators. This<br>
 * class should only be used when you're sure the iterators are valid. Don't<br>
 * use this class directly; instead, use makeIteratorRange().<br>
 * <br>
 * Here's an example of using iterators `first` and `last` to iterate over the<br>
 * range `[first, last)` (that is, `last` won't be reached):<br>
 * {@code 
std::vector<int> v {5, 10, 15, 20, 22};
auto first = std::lower_bound(v.begin(), v.end(), 10);
auto last = std::lower_bound(v.begin(), v.end(), 15); // actually points to 20.
for (auto& x : makeIteratorRange(first, last)) {
    ...
}
}<br>
 * <br>
 * You can also use this class with an std::pair of iterators, such as that<br>
 * returned by std::multimap::equal_range(). We assume the first iterator in the<br>
 * pair is the first iterator in the range, and the second iterator in the pair is<br>
 * the last iterator in the range.<br>
 * {@code 
std::multimap<std::string, int> map;
...
for (auto& x : makeIteratorRange(map.equal_range("some_key"))) {
    ...
}
}
 */
public class IteratorRangeStatesTrajectoryIterator {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public IteratorRangeStatesTrajectoryIterator(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(IteratorRangeStatesTrajectoryIterator obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_IteratorRangeStatesTrajectoryIterator(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  This constructor allows you to iterate over the range `[first, last)`;<br>
   *     this means `last` won't be reached. 
   */
  public IteratorRangeStatesTrajectoryIterator(SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator first, SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator last) {
    this(opensimSimulationJNI.new_IteratorRangeStatesTrajectoryIterator__SWIG_0(SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator.getCPtr(first), SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator.getCPtr(last)), true);
  }

  public IteratorRangeStatesTrajectoryIterator(SWIGTYPE_p_std__pairT_std__vectorT_SimTK__State_t__const_iterator_std__vectorT_SimTK__State_t__const_iterator_t range) {
    this(opensimSimulationJNI.new_IteratorRangeStatesTrajectoryIterator__SWIG_1(SWIGTYPE_p_std__pairT_std__vectorT_SimTK__State_t__const_iterator_std__vectorT_SimTK__State_t__const_iterator_t.getCPtr(range)), true);
  }

  public SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator begin() {
    return new SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator(opensimSimulationJNI.IteratorRangeStatesTrajectoryIterator_begin(swigCPtr, this), true);
  }

  public SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator end() {
    return new SWIGTYPE_p_std__vectorT_SimTK__State_t__const_iterator(opensimSimulationJNI.IteratorRangeStatesTrajectoryIterator_end(swigCPtr, this), true);
  }

}
