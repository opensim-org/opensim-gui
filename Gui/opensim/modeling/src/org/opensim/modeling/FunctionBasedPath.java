/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * A concrete class representing a path for muscles, ligaments, etc., based on<br>
 * `Function` objects. This class can be used when efficient computations of<br>
 * path length, lengthening speed, and moment arms are a priority (e.g., a<br>
 * direct collocation problem).<br>
 * <br>
 * Each instance of this class requires both a list of model coordinates that<br>
 * the path is dependent on and a function,   l(q) , that computes the<br>
 * length of the path as a function of the coordinate values,   q .<br>
 * Optionally, functions can be provided to compute the moment arms of the path<br>
 * as a function of the coordinate values and a function that computes the speed<br>
 * of the path as a function of the coordinate values and speeds.<br>
 * <br>
 * If the moment arm and/or speed functions are not provided, they will be<br>
 * computed from the length function based on van den Bogert et al. (2013) and<br>
 * Meyer et al. (2017):<br>
 * <br>
 *  
r_i = -\frac{\partial l}{\partial q_i} \quad \forall q_i \in Q
<br>
 * <br>
 *  
\dot{l} = \frac{dl}{dt}
        = \sum_i \frac{\partial l}{\partial q_i} \frac{dq_i}{dt}
        = \sum_i -r_i \dot{q}_i
<br>
 * <br>
 * Where,<br>
 * -   r_i : the moment arm of the path with respect to coordinate<br>
 * _i .
-  l  : the length of the path.
-   : the lengthening speed of the path.
-  q_i  : the i-th coordinate value.
-  _i  : the i-th coordinate value derivative.
-  Q  : the set of all coordinates.

@note The moment arm expression above assumes that all constraints in the
model are workless (i.e., no `MovingPathPoint`s). Other path types (e.g.,
`GeometryPath`) compute moment arms based on the generalized force applied to
joint given a unit force along the path, which does not rely on this
assumption (see `MomentArmSolver`). Please keep this in mind when providing
the path functions. See Sherman et al. (2013) for more details.

@note  _i   is usually, but not necessarily, the same as the
generalized speed of the coordinate,  u_i   (e.g., see `BallJoint`).
Please keep this in mind when providing a speed function. See Sherman et al.
(2013) for more details.

The length function and (if provided) the moment arm functions must have the
same number of arguments as the number of coordinates, where the order of the
arguments matches the order in the `coordinates` property. Each moment arm
function corresponds to a single coordinate, and the order of the functions
in the `moment_arm_functions` property must match the order in `coordinates`.
The speed function (if provided) must have twice as many arguments as the
number of coordinates, where the first half of the arguments are the
coordinate values and the second half are the coordinate speeds. Again, the
order of the value and speed arguments must match the order in the
`coordinates` property.

@note The forces applied to the model by the path are computed by multiplying
the tension in the path by the moment arms. Therefore, this class only
applies mobility (i.e., generalized) forces to the model.

# References
- [1] Meyer AJ, Patten C, Fregly BJ (2017) "Lower extremity EMG-driven
      modeling of walking with automated adjustment of musculoskeletal
      geometry." PLoS ONE 12(7): e0179698.
      https://doi.org/10.1371/journal.pone.0179698
- [2] van den Bogert, A.J., Geijtenbeek, T., Even-Zohar, O. et al. (2013) "A
      real-time system for biomechanical analysis of human movement and
      muscle function." Med Biol Eng Comput 51, 1069â€“1077 (2013).
      https://doi.org/10.1007/s11517-013-1076-z
- [3] Sherman MA, Seth A, Delp SL. (2013) "What is a Moment Arm? Calculating
      Muscle Effectiveness in Biomechanical Models Using Generalized
      Coordinates." ASME. International Design Engineering Technical
      Conferences and Computers and Information in Engineering Conference,
      Volume 7B: 9th International Conference on Multibody Systems,
      Nonlinear Dynamics, and Control.

 */
public class FunctionBasedPath extends AbstractGeometryPath {
  private transient long swigCPtr;

  public FunctionBasedPath(long cPtr, boolean cMemoryOwn) {
    super(opensimSimulationJNI.FunctionBasedPath_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(FunctionBasedPath obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(FunctionBasedPath obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_FunctionBasedPath(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static FunctionBasedPath safeDownCast(OpenSimObject obj) {
    long cPtr = opensimSimulationJNI.FunctionBasedPath_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new FunctionBasedPath(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimSimulationJNI.FunctionBasedPath_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimSimulationJNI.FunctionBasedPath_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.FunctionBasedPath_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new FunctionBasedPath(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.FunctionBasedPath_getConcreteClassName(swigCPtr, this);
  }

  public void copyProperty_coordinate_paths(FunctionBasedPath source) {
    opensimSimulationJNI.FunctionBasedPath_copyProperty_coordinate_paths(swigCPtr, this, FunctionBasedPath.getCPtr(source), source);
  }

  public String get_coordinate_paths(int i) {
    return opensimSimulationJNI.FunctionBasedPath_get_coordinate_paths(swigCPtr, this, i);
  }

  public SWIGTYPE_p_std__string upd_coordinate_paths(int i) {
    return new SWIGTYPE_p_std__string(opensimSimulationJNI.FunctionBasedPath_upd_coordinate_paths(swigCPtr, this, i), false);
  }

  public void set_coordinate_paths(int i, String value) {
    opensimSimulationJNI.FunctionBasedPath_set_coordinate_paths(swigCPtr, this, i, value);
  }

  public int append_coordinate_paths(String value) {
    return opensimSimulationJNI.FunctionBasedPath_append_coordinate_paths(swigCPtr, this, value);
  }

  public void constructProperty_coordinate_paths() {
    opensimSimulationJNI.FunctionBasedPath_constructProperty_coordinate_paths(swigCPtr, this);
  }

  public void copyProperty_length_function(FunctionBasedPath source) {
    opensimSimulationJNI.FunctionBasedPath_copyProperty_length_function(swigCPtr, this, FunctionBasedPath.getCPtr(source), source);
  }

  public Function get_length_function(int i) {
    return new Function(opensimSimulationJNI.FunctionBasedPath_get_length_function__SWIG_0(swigCPtr, this, i), false);
  }

  public Function upd_length_function(int i) {
    return new Function(opensimSimulationJNI.FunctionBasedPath_upd_length_function__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_length_function(int i, Function value) {
    opensimSimulationJNI.FunctionBasedPath_set_length_function__SWIG_0(swigCPtr, this, i, Function.getCPtr(value), value);
  }

  public int append_length_function(Function value) {
    return opensimSimulationJNI.FunctionBasedPath_append_length_function(swigCPtr, this, Function.getCPtr(value), value);
  }

  public void constructProperty_length_function() {
    opensimSimulationJNI.FunctionBasedPath_constructProperty_length_function__SWIG_0(swigCPtr, this);
  }

  public void constructProperty_length_function(Function initValue) {
    opensimSimulationJNI.FunctionBasedPath_constructProperty_length_function__SWIG_1(swigCPtr, this, Function.getCPtr(initValue), initValue);
  }

  public Function get_length_function() {
    return new Function(opensimSimulationJNI.FunctionBasedPath_get_length_function__SWIG_1(swigCPtr, this), false);
  }

  public Function upd_length_function() {
    return new Function(opensimSimulationJNI.FunctionBasedPath_upd_length_function__SWIG_1(swigCPtr, this), false);
  }

  public void set_length_function(Function value) {
    opensimSimulationJNI.FunctionBasedPath_set_length_function__SWIG_1(swigCPtr, this, Function.getCPtr(value), value);
  }

  public void copyProperty_moment_arm_functions(FunctionBasedPath source) {
    opensimSimulationJNI.FunctionBasedPath_copyProperty_moment_arm_functions(swigCPtr, this, FunctionBasedPath.getCPtr(source), source);
  }

  public Function get_moment_arm_functions(int i) {
    return new Function(opensimSimulationJNI.FunctionBasedPath_get_moment_arm_functions(swigCPtr, this, i), false);
  }

  public Function upd_moment_arm_functions(int i) {
    return new Function(opensimSimulationJNI.FunctionBasedPath_upd_moment_arm_functions(swigCPtr, this, i), false);
  }

  public void set_moment_arm_functions(int i, Function value) {
    opensimSimulationJNI.FunctionBasedPath_set_moment_arm_functions(swigCPtr, this, i, Function.getCPtr(value), value);
  }

  public int append_moment_arm_functions(Function value) {
    return opensimSimulationJNI.FunctionBasedPath_append_moment_arm_functions(swigCPtr, this, Function.getCPtr(value), value);
  }

  public void constructProperty_moment_arm_functions() {
    opensimSimulationJNI.FunctionBasedPath_constructProperty_moment_arm_functions(swigCPtr, this);
  }

  public void copyProperty_lengthening_speed_function(FunctionBasedPath source) {
    opensimSimulationJNI.FunctionBasedPath_copyProperty_lengthening_speed_function(swigCPtr, this, FunctionBasedPath.getCPtr(source), source);
  }

  public Function get_lengthening_speed_function(int i) {
    return new Function(opensimSimulationJNI.FunctionBasedPath_get_lengthening_speed_function__SWIG_0(swigCPtr, this, i), false);
  }

  public Function upd_lengthening_speed_function(int i) {
    return new Function(opensimSimulationJNI.FunctionBasedPath_upd_lengthening_speed_function__SWIG_0(swigCPtr, this, i), false);
  }

  public void set_lengthening_speed_function(int i, Function value) {
    opensimSimulationJNI.FunctionBasedPath_set_lengthening_speed_function__SWIG_0(swigCPtr, this, i, Function.getCPtr(value), value);
  }

  public int append_lengthening_speed_function(Function value) {
    return opensimSimulationJNI.FunctionBasedPath_append_lengthening_speed_function(swigCPtr, this, Function.getCPtr(value), value);
  }

  public void constructProperty_lengthening_speed_function() {
    opensimSimulationJNI.FunctionBasedPath_constructProperty_lengthening_speed_function__SWIG_0(swigCPtr, this);
  }

  public void constructProperty_lengthening_speed_function(Function initValue) {
    opensimSimulationJNI.FunctionBasedPath_constructProperty_lengthening_speed_function__SWIG_1(swigCPtr, this, Function.getCPtr(initValue), initValue);
  }

  public Function get_lengthening_speed_function() {
    return new Function(opensimSimulationJNI.FunctionBasedPath_get_lengthening_speed_function__SWIG_1(swigCPtr, this), false);
  }

  public Function upd_lengthening_speed_function() {
    return new Function(opensimSimulationJNI.FunctionBasedPath_upd_lengthening_speed_function__SWIG_1(swigCPtr, this), false);
  }

  public void set_lengthening_speed_function(Function value) {
    opensimSimulationJNI.FunctionBasedPath_set_lengthening_speed_function__SWIG_1(swigCPtr, this, Function.getCPtr(value), value);
  }

  public FunctionBasedPath() {
    this(opensimSimulationJNI.new_FunctionBasedPath(), true);
  }

  /**
   *  Set the list of paths to the model coordinate that are used as arguments<br>
   *  to the length and, if provided, lengthening speed and moment functions.<br>
   *  The order of the coordinates must match the order of the function<br>
   *  arguments.
   */
  public void setCoordinatePaths(StdVectorString coordinatePaths) {
    opensimSimulationJNI.FunctionBasedPath_setCoordinatePaths(swigCPtr, this, StdVectorString.getCPtr(coordinatePaths), coordinatePaths);
  }

  public void appendCoordinatePath(String coordinatePath) {
    opensimSimulationJNI.FunctionBasedPath_appendCoordinatePath(swigCPtr, this, coordinatePath);
  }

  public StdVectorString getCoordinatePaths() {
    return new StdVectorString(opensimSimulationJNI.FunctionBasedPath_getCoordinatePaths(swigCPtr, this), true);
  }

  /**
   *  Set the function that computes the length of the path as a function of<br>
   *  the coordinate values. The function must have the same number of<br>
   *  arguments as the number of coordinates.
   */
  public void setLengthFunction(Function lengthFunction) {
    opensimSimulationJNI.FunctionBasedPath_setLengthFunction(swigCPtr, this, Function.getCPtr(lengthFunction), lengthFunction);
  }

  public Function getLengthFunction() {
    return new Function(opensimSimulationJNI.FunctionBasedPath_getLengthFunction(swigCPtr, this), false);
  }

  /**
   *  Set the list of functions that compute the moment arms of the path as a<br>
   *  function of the coordinate values. The order of the functions must match<br>
   *  the order of the coordinates.
   */
  public void setMomentArmFunctions(SWIGTYPE_p_std__vectorT_OpenSim__Function_t momentArmFunctions) {
    opensimSimulationJNI.FunctionBasedPath_setMomentArmFunctions(swigCPtr, this, SWIGTYPE_p_std__vectorT_OpenSim__Function_t.getCPtr(momentArmFunctions));
  }

  public void appendMomentArmFunction(Function momentArmFunction) {
    opensimSimulationJNI.FunctionBasedPath_appendMomentArmFunction(swigCPtr, this, Function.getCPtr(momentArmFunction), momentArmFunction);
  }

  public Function getMomentArmFunction(String coordinatePath) {
    return new Function(opensimSimulationJNI.FunctionBasedPath_getMomentArmFunction(swigCPtr, this, coordinatePath), false);
  }

  public Vector getMomentArms(State s) {
    return new Vector(opensimSimulationJNI.FunctionBasedPath_getMomentArms(swigCPtr, this, State.getCPtr(s), s), false);
  }

  /**
   *  Set the function that computes the speed of the path as a function of<br>
   *  the coordinate values and speeds. The function must have the same number<br>
   *  of arguments as the number of coordinate values and speeds.
   */
  public void setLengtheningSpeedFunction(Function speedFunction) {
    opensimSimulationJNI.FunctionBasedPath_setLengtheningSpeedFunction(swigCPtr, this, Function.getCPtr(speedFunction), speedFunction);
  }

  public Function getLengtheningSpeedFunction() {
    return new Function(opensimSimulationJNI.FunctionBasedPath_getLengtheningSpeedFunction(swigCPtr, this), false);
  }

  public double getLength(State s) {
    return opensimSimulationJNI.FunctionBasedPath_getLength(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getLengtheningSpeed(State s) {
    return opensimSimulationJNI.FunctionBasedPath_getLengtheningSpeed(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Note: This must check if the path is dependent on the provided<br>
   *  coordinate, which requires a search through the list of coordinates.<br>
   *  To retrieve the moment arms directly from the cache variable in the<br>
   *  SimTK::State, use `getMomentArms()` instead.
   */
  public double computeMomentArm(State s, Coordinate coord) {
    return opensimSimulationJNI.FunctionBasedPath_computeMomentArm(swigCPtr, this, State.getCPtr(s), s, Coordinate.getCPtr(coord), coord);
  }

  public void addInEquivalentForces(State state, double tension, VectorOfSpatialVec bodyForces, Vector mobilityForces) {
    opensimSimulationJNI.FunctionBasedPath_addInEquivalentForces(swigCPtr, this, State.getCPtr(state), state, tension, VectorOfSpatialVec.getCPtr(bodyForces), bodyForces, Vector.getCPtr(mobilityForces), mobilityForces);
  }

  public boolean isVisualPath() {
    return opensimSimulationJNI.FunctionBasedPath_isVisualPath(swigCPtr, this);
  }

}
