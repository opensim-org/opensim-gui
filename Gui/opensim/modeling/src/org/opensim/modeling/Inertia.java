/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  Spatial vectors are used for (rotation,translation) quantities and <br>
 * consist of a pair of Vec3 objects, arranged as a 2-vector of 3-vectors. <br>
 * Quantities represented this way include<br>
 *     - spatial velocity     = (angularVelocity,linearVelocity)<br>
 *     - spatial acceleration = (angularAcceleration,linearAcceleration)<br>
 *     - generalized forces   = (torque,force)<br>
 * <br>
 * Spatial configuration has to be handled differently though since<br>
 * orientation is not a vector quantity. (We use Transform for this concept<br>
 * which includes a Rotation matrix and a translation Vec3.) * The physical meaning of an inertia is the distribution of a rigid body's <br>
 * mass about a <i>particular</i> point. If that point is the center of mass of the <br>
 * body, then the measured inertia is called the "central inertia" of that body. <br>
 * To write down the inertia, we need to calculate the six scalars of the inertia <br>
 * tensor, which is a symmetric 3x3 matrix. These scalars must be expressed in <br>
 * an arbitrary but specified coordinate system. So an Inertia is meaningful only <br>
 * in conjunction with a particular set of axes, fixed to the body, whose origin <br>
 * is the point about which the inertia is being measured, and in whose <br>
 * coordinate system this measurement is being expressed. Note that changing the <br>
 * reference point results in a new physical quantity, but changing the reference <br>
 * axes only affects the measure numbers of that quantity. For any reference <br>
 * point, there is a unique set of reference axes in which the inertia tensor is<br>
 * diagonal; those are called the "principal axes" of the body at that point, and <br>
 * the resulting diagonal elements are the "principal moments of inertia". When <br>
 * we speak of an inertia being "in" a frame, we mean the physical quantity <br>
 * measured about the frame's origin and then expressed in the frame's axes.<br>
 * <br>
 * This low-level Inertia class does not attempt to keep track of <i>which</i> frame <br>
 * it is in. It provides construction and operations involving inertia that can <br>
 * proceed using only an implicit frame F. Clients of this class are responsible <br>
 * for keeping track of that frame. In particular, in order to shift the <br>
 * inertia's "measured-about" point one must know whether either the starting or <br>
 * final inertia is central, because we must always shift inertias by passing <br>
 * through the central inertia. So this class provides operations for doing the <br>
 * shifting, but expects to be told by the client where to find the center of mass.<br>
 * <br>
 * Re-expressing an Inertia in a different coordinate system does not entail a <br>
 * change of physical meaning in the way that shifting it to a different point <br>
 * does. Note that because inertia is a tensor, there is a "left frame" and <br>
 * "right frame". For our purposes, these will always be the same so we'll only <br>
 * indicate the frame once, as in 'I_pt_frame'. This should be understood to mean<br>
 * 'frame_I_pt_frame' and re-expressing an Inertia requires both a left and right <br>
 * multiply by the rotation matrix. So I_OB_B is the inertia about body B's <br>
 * origin point OB, expressed in B, while I_OB_G is the same physical quantity <br>
 * but expressed in Ground (the latter is a component of the Spatial Inertia<br>
 * which we usually want in the Ground frame). Frame conversion is done logically <br>
 * like this:<br>
 * <pre><br>
 *    I_OB_G = R_GB * I_OB_B * R_BG  (R_BG=~R_GB)<br>
 * </pre><br>
 * but we can save computation time by performing this as a single operation.<br>
 * <br>
 * The central inertia would be I_CB_B for body B.<br>
 * <br>
 * A Inertia is a symmetric matrix and is positive definite for nonsingular bodies<br>
 * (that is, a body composed of at least three noncollinear point masses).<br>
 * <br>
 * Some attempt is made to check the validity of an Inertia matrix, at least<br>
 * when running in Debug mode. Some conditions it must satisfy are:<br>
 *  - must be symmetric<br>
 *  - all diagonal elements must be nonnegative<br>
 *  - diagonal elements must satisfy the triangle inequality (sum of any two<br>
 *    is greater than or equal the other one)<br>
 * <br>
 * <h3>Abbreviations</h3><br>
 * Typedefs exist for the most common invocations of Inertia_&lt;P&gt;:<br>
 *  - <a href="#SimTK::Inertia">Inertia</a> for default Real precision (this is <br>
 *    almost always used)<br>
 *  - <a href="#SimTK::fInertia">fInertia</a> for single (float) precision<br>
 *  - <a href="#SimTK::dInertia">dInertia</a> for double precision
 */
public class Inertia {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public Inertia(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(Inertia obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(Inertia obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimbodyJNI.delete_Inertia(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Default is a NaN-ed out mess to avoid accidents, even in Release mode.<br>
   *  Other than this value, an Inertia matrix should always be valid.
   */
  public Inertia() {
    this(opensimSimbodyJNI.new_Inertia__SWIG_0(), true);
  }

  /**
   *  Create a principal inertia matrix with identical diagonal elements,<br>
   *  like a sphere where moment=2/5 m r^2, or a cube where <br>
   *  moment=1/6 m s^2, with m the total mass, r the sphere's radius<br>
   *  and s the length of a side of the cube. Note that many rigid<br>
   *  bodies of different shapes and masses can have the same inertia<br>
   *  matrix.
   */
  public Inertia(double moment) {
    this(opensimSimbodyJNI.new_Inertia__SWIG_1(moment), true);
  }

  /**
   *  Create an Inertia matrix for a point mass at a given location,<br>
   *  measured from the origin OF of the implicit frame F, and expressed<br>
   *  in F. Cost is 14 flops.
   */
  public Inertia(Vec3 p, double mass) {
    this(opensimSimbodyJNI.new_Inertia__SWIG_2(Vec3.getCPtr(p), p, mass), true);
  }

  /**
   *  Create an inertia matrix from a vector of the <i>moments</i> of<br>
   *  inertia (the inertia matrix diagonal) and optionally a vector of<br>
   *  the <i>products</i> of inertia (the off-diagonals). Moments are<br>
   *  in the order xx,yy,zz; products are xy,xz,yz.
   */
  public Inertia(Vec3 moments, Vec3 products) {
    this(opensimSimbodyJNI.new_Inertia__SWIG_3(Vec3.getCPtr(moments), moments, Vec3.getCPtr(products), products), true);
  }

  /**
   *  Create an inertia matrix from a vector of the <i>moments</i> of<br>
   *  inertia (the inertia matrix diagonal) and optionally a vector of<br>
   *  the <i>products</i> of inertia (the off-diagonals). Moments are<br>
   *  in the order xx,yy,zz; products are xy,xz,yz.
   */
  public Inertia(Vec3 moments) {
    this(opensimSimbodyJNI.new_Inertia__SWIG_4(Vec3.getCPtr(moments), moments), true);
  }

  /**
   *  Create a principal inertia matrix (only non-zero on diagonal).
   */
  public Inertia(double xx, double yy, double zz) {
    this(opensimSimbodyJNI.new_Inertia__SWIG_5(xx, yy, zz), true);
  }

  /**
   *  This is a general inertia matrix. Note the order of these<br>
   *  arguments: moments of inertia first, then products of inertia.
   */
  public Inertia(double xx, double yy, double zz, double xy, double xz, double yz) {
    this(opensimSimbodyJNI.new_Inertia__SWIG_6(xx, yy, zz, xy, xz, yz), true);
  }

  /**
   *  Obtain the inertia moments (diagonal of the Inertia matrix) as a Vec3<br>
   *  ordered xx, yy, zz.
   */
  public Vec3 getMoments() {
    return new Vec3(opensimSimbodyJNI.Inertia_getMoments(swigCPtr, this), false);
  }

  /**
   *  Obtain the inertia products (off-diagonals of the Inertia matrix)<br>
   *  as a Vec3 with elements ordered xy, xz, yz.
   */
  public Vec3 getProducts() {
    return new Vec3(opensimSimbodyJNI.Inertia_getProducts(swigCPtr, this), false);
  }

  public boolean isNaN() {
    return opensimSimbodyJNI.Inertia_isNaN(swigCPtr, this);
  }

  public boolean isInf() {
    return opensimSimbodyJNI.Inertia_isInf(swigCPtr, this);
  }

  public boolean isFinite() {
    return opensimSimbodyJNI.Inertia_isFinite(swigCPtr, this);
  }

}
