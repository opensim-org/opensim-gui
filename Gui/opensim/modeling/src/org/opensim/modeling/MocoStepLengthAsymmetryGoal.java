/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  Minimize the error between a model's step time asymmetry and a specified<br>
 * target asymmetry value over a gait cycle.<br>
 * <br>
 * Step Length Asymmetry (SLA) is a ratio and is calculated as follows:<br>
 * The Right Step Length (RSL) is the distance between feet at right foot strike<br>
 * The Left Step Length (LSL) is the distance between feet at left foot strike<br>
 * Step Length Asymmetry = (RSL - LSL) / (RSL + LSL)<br>
 * <br>
 * In this goal, the distance between feet, or "foot frames", is limited throughout<br>
 * the gait cycle. The goal calculates the distance between the left foot and right<br>
 * foot, then limits the distance between feet to not pass beyond minimum (negative)<br>
 * or maximum (positive) bounds. There are two limits used: one that limits the<br>
 * distance between feet when the right foot is in front, and one that limits the<br>
 * distance between feet when the left foot is in front.<br>
 * <br>
 * Users must provide the target asymmetry value via 'setTargetAsymmetry()'.<br>
 * Asymmetry values ranges from -1.0 to 1.0. For example, 0.20 is 20% positive<br>
 * step length asymmetry with greater right step length than left step length. A<br>
 * symmetric step length solution can be achieved by setting this property to zero.<br>
 * This goal can be used only in 'cost' mode. To make this goal suitable for<br>
 * gradient-based optimization, step length values are assigned via a smoothing<br>
 * function which can be controlled via 'setAsymmetrySmoothing()'.<br>
 * <br>
 * Users must also prescribe the stride length via 'setStrideLength()'. The goal<br>
 * then calculates the minimum and maximum bounds on the distance between right<br>
 * and left foot. Users must ensure that this stride length is met via problem<br>
 * bounds or other goals; the value provided to MocoStepLengthAsymmetryGoal is<br>
 * only used to compute the model's asymmetry in the cost function.<br>
 * <br>
 * Note: This goal is designed for simulations of bipedal gait.<br>
 * <br>
 * Note: Since this goal approximates step length asymmetry, users should calculate<br>
 * the true asymmetry value after running an optimization.<br>
 * <br>
 * 
 */
public class MocoStepLengthAsymmetryGoal extends MocoGoal {
  private transient long swigCPtr;

  public MocoStepLengthAsymmetryGoal(long cPtr, boolean cMemoryOwn) {
    super(opensimMocoJNI.MocoStepLengthAsymmetryGoal_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(MocoStepLengthAsymmetryGoal obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(MocoStepLengthAsymmetryGoal obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimMocoJNI.delete_MocoStepLengthAsymmetryGoal(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static MocoStepLengthAsymmetryGoal safeDownCast(OpenSimObject obj) {
    long cPtr = opensimMocoJNI.MocoStepLengthAsymmetryGoal_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new MocoStepLengthAsymmetryGoal(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimMocoJNI.MocoStepLengthAsymmetryGoal_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimMocoJNI.MocoStepLengthAsymmetryGoal_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimMocoJNI.MocoStepLengthAsymmetryGoal_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new MocoStepLengthAsymmetryGoal(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimMocoJNI.MocoStepLengthAsymmetryGoal_getConcreteClassName(swigCPtr, this);
  }

  public MocoStepLengthAsymmetryGoal() {
    this(opensimMocoJNI.new_MocoStepLengthAsymmetryGoal__SWIG_0(), true);
  }

  public MocoStepLengthAsymmetryGoal(String name) {
    this(opensimMocoJNI.new_MocoStepLengthAsymmetryGoal__SWIG_1(name), true);
  }

  public MocoStepLengthAsymmetryGoal(String name, double weight) {
    this(opensimMocoJNI.new_MocoStepLengthAsymmetryGoal__SWIG_2(name, weight), true);
  }

  /**
   *  Set the body frame associated with the left foot.
   */
  public void setLeftFootFrame(String frame) {
    opensimMocoJNI.MocoStepLengthAsymmetryGoal_setLeftFootFrame(swigCPtr, this, frame);
  }

  public String getLeftFootFrame() {
    return opensimMocoJNI.MocoStepLengthAsymmetryGoal_getLeftFootFrame(swigCPtr, this);
  }

  /**
   *  Set the body frame associated with the right foot.
   */
  public void setRightFootFrame(String frame) {
    opensimMocoJNI.MocoStepLengthAsymmetryGoal_setRightFootFrame(swigCPtr, this, frame);
  }

  public String getRightFootFrame() {
    return opensimMocoJNI.MocoStepLengthAsymmetryGoal_getRightFootFrame(swigCPtr, this);
  }

  /**
   *  Set the asymmetry value targeted by this goal. The error between the<br>
   *  target asymmetry and the model asymmetry is squared in the integrand.
   */
  public void setTargetAsymmetry(double asymmetry) {
    opensimMocoJNI.MocoStepLengthAsymmetryGoal_setTargetAsymmetry(swigCPtr, this, asymmetry);
  }

  public double getTargetAsymmetry() {
    return opensimMocoJNI.MocoStepLengthAsymmetryGoal_getTargetAsymmetry(swigCPtr, this);
  }

  /**
   *  Set the known stride length of your walking simulation. This value is<br>
   *  necessary to compute step length asymmetry.
   */
  public void setStrideLength(double length) {
    opensimMocoJNI.MocoStepLengthAsymmetryGoal_setStrideLength(swigCPtr, this, length);
  }

  public double getStrideLength() {
    return opensimMocoJNI.MocoStepLengthAsymmetryGoal_getStrideLength(swigCPtr, this);
  }

  /**
   *  Set the walking direction of the model in the ground frame, which is used<br>
   *  to compute step lengths. Acceptable direction values include<br>
   *  "positive-x", "positive-y", "positive-z", "negative-x", "negative-y", and<br>
   *  "negative-z". Default: "positive-x".
   */
  public void setWalkingDirection(String direction) {
    opensimMocoJNI.MocoStepLengthAsymmetryGoal_setWalkingDirection(swigCPtr, this, direction);
  }

  public String getWalkingDirection() {
    return opensimMocoJNI.MocoStepLengthAsymmetryGoal_getWalkingDirection(swigCPtr, this);
  }

  /**
   *  Set the values that determines the smoothing of the asymmetry<br>
   *  computation. This term is necessary since this computation is non-smooth.<br>
   *  Larger smoothing values mean that larger step length errors are required<br>
   *  for a given step to be counted towards the total asymmetry error<br>
   *  minimized in the cost.
   */
  public void setAsymmetrySmoothing(double smoothing) {
    opensimMocoJNI.MocoStepLengthAsymmetryGoal_setAsymmetrySmoothing(swigCPtr, this, smoothing);
  }

  public double getAsymmetrySmoothing() {
    return opensimMocoJNI.MocoStepLengthAsymmetryGoal_getAsymmetrySmoothing(swigCPtr, this);
  }

}
