/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  This subsystem contains the bodies ("matter") in the multibody system,<br>
 * the mobilizers (joints) that define the generalized coordinates used to <br>
 * represent the motion of those bodies, and constraints that must be satisfied<br>
 * by the values of those coordinates.<br>
 * <br>
 * There are many methods in the API for this class. For whole-system information<br>
 * and calculations, the methods here are the right ones to use. For information<br>
 * associated with individual objects contained in the subsystem, such as <br>
 * MobilizedBody and Constraint objects, it is generally easier to obtain the<br>
 * information through the contained objects' APIs instead.<br>
 * <br>
 * This class is is a "handle" containing only an opaque reference to the <br>
 * underlying implementation class.<br>
 * <br>
 * <h3>Theory discussion</h3><br>
 * The bodies, mobilizers, and constraints are represented mathematically with<br>
 * the following set of equations:<br>
 * <pre><br>
 *                      qdot = N u                 Kinematic differential eqns.<br>
 *                      zdot = zdot(t,q,u,z)       Auxiliary states<br>
 * <br>
 *          M udot + ~G mult = f(t,q,u,z)          Equations of motion<br>
 *          G udot           = b(t,q,u) <br>
 * <br>
 *                  where<br>
 * <br>
 *           [P]    [bp]<br>
 *         G=[V]  b=[bv]  f = T + ~J*(F-C)<br>
 *           [A]    [ba]<br>
 * <br>
 *           pdotdot = P udot - bp(t,q,u) = 0      Acceleration constraints<br>
 *              vdot = V udot - bv(t,q,u) = 0<br>
 *     a(t,q,u,udot) = A udot - ba(t,q,u) = 0<br>
 * <br>
 *                    pdot = P u - c(t,q) = 0      Velocity constraints<br>
 *                               v(t,q,u) = 0<br>
 * <br>
 *                                 p(t,q) = 0      Position constraints<br>
 *                                   n(q) = 0      Normalization constraints<br>
 * </pre><br>
 * where M(q) is the mass matrix, G(t,q,u) the acceleration constraint matrix, <br>
 * C(q,u) the coriolis and gyroscopic forces, T is user-applied joint mobility<br>
 * forces, F is user-applied body forces and torques and gravity. J(q) is the<br>
 * %System Jacobian (partial velocity matrix) whose transpose ~J maps spatial<br>
 * forces to joint mobility forces. p(t,q) are the holonomic (position) <br>
 * constraints, v(t,q,u) the non-holonomic (velocity) constraints, and <br>
 * a(t,q,u,udot) the acceleration-only constraints, which must be linear in udot, <br>
 * with A(t,q,u) the coefficient matrix for a(). pdot, pdotdot are obtained by <br>
 * differentiation of p(), vdot by differentiation of v(). P(t,q)=Dpdot/Du <br>
 * (yes, that's u, not q -- we can get Pq=Dp/Dq when we need it as Pq=P*N^-1) and<br>
 * V(t,q,u)=Dv/Du. (We use capital "D" to indicate partial derivative.) n(q) is <br>
 * the set of quaternion normalization constraints, which exist only at the <br>
 * position level and are uncoupled from everything else.<br>
 * <br>
 * We calculate the constraint multipliers like this:<br>
 * <pre><br>
 *           G M^-1 ~G mult = G udot0 - b<br>
 *           where    udot0 = M^-1 f<br>
 * </pre><br>
 * using the pseudo inverse of G M^-1 ~G to give a least squares solution for<br>
 * mult: mult = pinv(G M^-1 ~G)(G M^-1 f - b). Then the real udot is<br>
 * udot = udot0 - udotC, with udotC = M^-1 ~G mult. Note: M^-1* is an<br>
 * O(n) operator that provides the desired result; it <em>does not</em> require<br>
 * forming or factoring M.<br>
 * <br>
 * NOTE: only the following constraint matrices have to be formed and factored:<br>
 * <pre><br>
 *    [G M^-1 ~G]   to calculate multipliers<br>
 * <br>
 *    [P N^-1]      for projection onto position manifold (a.k.a. Pq)<br>
 * <br>
 *    [ P ]         for projection onto velocity manifold<br>
 *    [ V ]  <br>
 * </pre><br>
 * <br>
 * When working in a weighted norm with weights W on the state variables and<br>
 * weights T (1/tolerance) on the constraint errors, the matrices we need are<br>
 * actually [Tp Pq Wq^-1], [Tpv [P;V] Wu^-1], etc. with T and W diagonal<br>
 * weighting matrices. These can then be used to find least squares solutions<br>
 * in the weighted norms.<br>
 * <br>
 * In many cases these matrices consist of decoupled blocks which can<br>
 * be solved independently. (TODO: take advantage of that whenever possible<br>
 * to solve a set of smaller systems rather than one large one.) Also, in the<br>
 * majority of biosimulation applications we are likely to have only holonomic<br>
 * (position) constraints, so there is no V or A and G=P is the whole story.
 */
public class SimbodyMatterSubsystem {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public SimbodyMatterSubsystem(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(SimbodyMatterSubsystem obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(SimbodyMatterSubsystem obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimbodyJNI.delete_SimbodyMatterSubsystem(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   * * Create an orphan matter subsystem containing only the Ground body <br>
   * (mobilized body 0); normally use the other constructor to place the <br>
   * subsystem in a MultibodySystem. *
   */
  public SimbodyMatterSubsystem() {
    this(opensimSimbodyJNI.new_SimbodyMatterSubsystem(), true);
  }

  /**
   *  <br>
   * These methods perform calculations that yield properties of the system as<br>
   * a whole. These are <i>operators</i>, meaning that they make use of the supplied<br>
   * State but do not modify the State. They simply calculate a result and return<br>
   * it to you without storing it internally. Each method requires that the<br>
   * State has already been realized to at least a particular stage which is <br>
   * documented with the method. ** Calculate the total system mass.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Instance</code> *</p>
   */
  public double calcSystemMass(State s) {
    return opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemMass(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Return the position vector p_GC of the system mass center C, measured from <br>
   * the Ground origin, and expressed in Ground. <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public Vec3 calcSystemMassCenterLocationInGround(State s) {
    return new Vec3(opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemMassCenterLocationInGround(swigCPtr, this, State.getCPtr(s), s), true);
  }

  /**
   *  Return total system mass, mass center location measured from the Ground <br>
   * origin, and system inertia taken about the Ground origin, expressed in Ground.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public MassProperties calcSystemMassPropertiesInGround(State s) {
    return new MassProperties(opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemMassPropertiesInGround(swigCPtr, this, State.getCPtr(s), s), true);
  }

  /**
   *  Return the system inertia matrix taken about the system center of mass,<br>
   * expressed in Ground.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public Inertia calcSystemCentralInertiaInGround(State s) {
    return new Inertia(opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemCentralInertiaInGround(swigCPtr, this, State.getCPtr(s), s), true);
  }

  /**
   *  Return the velocity v_GC = d/dt p_GC of the system mass center C in the<br>
   * Ground frame G, measured from Ground origin and expressed in G.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> *</p>
   */
  public Vec3 calcSystemMassCenterVelocityInGround(State s) {
    return new Vec3(opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemMassCenterVelocityInGround(swigCPtr, this, State.getCPtr(s), s), true);
  }

  /**
   *  Return the acceleration a_GC = d/dt p_GC of the system mass center C in the<br>
   * Ground frame G, measured from Ground origin and expressed in G.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Acceleration</code> *</p>
   */
  public Vec3 calcSystemMassCenterAccelerationInGround(State s) {
    return new Vec3(opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemMassCenterAccelerationInGround(swigCPtr, this, State.getCPtr(s), s), true);
  }

  /**
   *  Return the momentum of the system as a whole (angular, linear) measured<br>
   * in the Ground frame, taken about the Ground origin and expressed in Ground.<br>
   * (The linear component is independent of the "about" point.)<br>
   * @see calcSystemCentralMomentum()<p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> *</p>
   */
  public SpatialVec calcSystemMomentumAboutGroundOrigin(State s) {
    return new SpatialVec(opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemMomentumAboutGroundOrigin(swigCPtr, this, State.getCPtr(s), s), true);
  }

  /**
   *  Return the momentum of the system as a whole (angular, linear) measured<br>
   * in the Ground frame, taken about the current system center of mass<br>
   * location C and expressed in Ground. (The linear component is independent of the<br>
   * "about" point.)<br>
   * @see calcSystemMomentumAboutGroundOrigin()<p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> *</p>
   */
  public SpatialVec calcSystemCentralMomentum(State s) {
    return new SpatialVec(opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemCentralMomentum(swigCPtr, this, State.getCPtr(s), s), true);
  }

  /**
   *  Calculate the total kinetic energy of all the mobilized bodies in this<br>
   * matter subsystem, given the configuration and velocities in <i>state</i>.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> *</p>
   */
  public double calcKineticEnergy(State state) {
    return opensimSimbodyJNI.SimbodyMatterSubsystem_calcKineticEnergy(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   * * <br>
   * The system kinematic Jacobian maps between mobility space (generalized speeds <br>
   * and generalized forces) and Cartesian body space (mobilized body frame spatial <br>
   * velocities and spatial forces). A task space Jacobian maps between mobility <br>
   * space and a specified set of task points or frames fixed to a subset of the <br>
   * bodies, and generally located away from the body frame. A task space Jacobian<br>
   * J can be used to construct various task space matrices such as the task space <br>
   * compliance matrix J M^-1 ~J or its inverse, the task space (or operational<br>
   * space) inertia matrix. <br>
   * <br>
   * The system Jacobian J(q) maps n generalized speeds u to spatial velocities V of <br>
   * each of the nb mobilized bodies (including Ground), measured at the body frame <br>
   * origin relative to Ground, and expressed in the Ground frame. The transpose ~J <br>
   * of this matrix maps nb spatial forces to n generalized forces, where the spatial<br>
   * forces are applied at the body frame origin and expressed in Ground. Similarly, <br>
   * task space Jacobians map from n generalized speeds to nt task frame spatial <br>
   * velocities (expressed in Ground), and transposed task space Jacobians map <br>
   * between task frame spatial forces (or impulses), expressed in Ground, and <br>
   * generalized forces (or generalized impulses).<br>
   * <br>
   * Simbody provides fast O(n) methods ("operators") that can form matrix-vector<br>
   * products like J*u or ~J*F without forming J. The "bias" term Jdot*u (also known<br>
   * as the Coriolis acceleration) is also available; this arises when working at<br>
   * the acceleration level because d/dt J*u = J*udot+Jdot*u (where dot means time<br>
   * derivative). The computational cost of these operators is O(n+nt) so it is <br>
   * <i>much</i> more efficient to work with a group of tasks simultaneously than to <br>
   * process one at a time, which would have complexity O(n*nt). Alternatively, we <br>
   * provide methods that will return all or part of J explicitly; in general it <br>
   * is <i>much</i> more efficient computationally to work with the O(n) matrix-vector <br>
   * multiply operators rather than to form explicit matrices and then perform O(n^2) <br>
   * matrix-vector products. Performance estimates are given with each method so that<br>
   * you can determine which methods to use. If you can, you should use the O(n) <br>
   * methods -- it is a good habit to get into when using an O(n) multibody code like<br>
   * Simbody!<br>
   * <br>
   * Note that the Jacobian is associated with an expressed-in frame for the<br>
   * velocity or force vector and a designated station (point) on each body. We <br>
   * always use the Ground frame for Jacobians. For the system Jacobian, the body <br>
   * origin is always the designated station; for task Jacobians different stations<br>
   * may be specified. We provide three different sets of methods for working with<br>
   *     - the full %System Jacobian: J, nb X n 6-vectors (or 6*nb X n scalars)<br>
   *     - the Station Jacobian for a set of nt task stations (points): JS, nt rows <br>
   *       of n 3-vectors (or a 3*nt X n Matrix of scalars)<br>
   *     - the Frame Jacobian for a set of nt task frames fixed to a body: JF, nt <br>
   *       rows of n 6-vectors (or a 6*nt X n Matrix of scalars)<br>
   * <br>
   * The rotational part of a Jacobian is the same for any frame fixed to the same <br>
   * body. So for Frame Jacobians you need specify only a station on the body (the <br>
   * frame's origin point). That means if you want a 3*nt X n Orientation Jacobian, <br>
   * you can obtain it from alternate rows of a Frame Jacobian. Using the above <br>
   * terminology, the complete %System Jacobian is a Frame Jacobian for which the <br>
   * task frames are the body frames, with each MobilizedBody appearing only once <br>
   * and in order of MobilizedBodyIndex (starting with Ground). <br>
   * <br>
   * It is acceptable for the same body to appear more than once in a list of tasks;<br>
   * these are likely to conflict but that can be dealt with elsewhere. ** Calculate the product of the %System kinematic Jacobian J (also known as the <br>
   * partial velocity matrix) and a mobility-space vector u in O(n) time. If the <br>
   * vector u is a set of generalized speeds, then this produces the body spatial <br>
   * velocities that result from those generalized speeds. That is, the result is <br>
   * V_GB = J*u where V_GB[i] is the spatial velocity of the i'th body's body frame <br>
   * origin (in Ground) that results from the given set of generalized speeds. <br>
   * <br>
   * @param state<br>
   *     A State compatible with this System that has already been realized to<br>
   *     Stage::Position.<br>
   * @param u<br>
   *     A mobility-space Vector, such as a set of generalized speeds. The length<br>
   *     and order must match the mobilities of this system (that is n, the number<br>
   *     of generalized speeds u, <i>not</i> nq, the number of generalized <br>
   *     coordinates q).<br>
   * @param Ju<br>
   *     This is the product V=J*u as described above. Each element is a spatial<br>
   *     vector, one per mobilized body, to be indexed by MobilizedBodyIndex.<br>
   *     If the input vector is a set of generalized speeds u, then the results<br>
   *     are nb spatial velocities V_GBi (that is, a pair of vectors w_GBi and v_GBi <br>
   *     giving angular and linear velocity). Note that Ground is body 0 so the 0th <br>
   *     element V_GB0=V_GG=Ju[0] is always zero on return.<br>
   * <br>
   * The kinematic Jacobian (partial velocity matrix) J is defined as follows:<br>
   * <pre><br>
   *       partial(V)                                 T                        T<br>
   *   J = ----------, V = [V_GB0 V_GB1 ... V_GB nb-1] ,  u = [u0 u1 ... u n-1]<br>
   *       partial(u)<br>
   * </pre><br>
   * Thus the element J(i,j)=partial(V_GBi)/partial(uj) (each element of J is a<br>
   * spatial vector). The transpose of this matrix maps spatial forces to <br>
   * generalized forces; see multiplyBySystemJacobianTranspose().<br>
   * <br>
   * Note that we're using "monogram" notation for the spatial velocities, where<br>
   * <pre><br>
   *             G Bi<br>
   *     V_GBi =  V<br>
   * </pre><br>
   * the spatial velocity of body i's body frame Bi (at its origin), measured and<br>
   * expressed in the Ground frame G.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * This is a very fast operator, costing about 12*(nb+n) flops, where nb is the<br>
   * number of bodies and n the number of mobilities (degrees of freedom) u. In <br>
   * contrast, even if you have already calculated the entire nbXnX6 matrix J, the <br>
   * multiplication J*u would cost 12*nb*n flops. As an example, for a 20 body <br>
   * system with a free flying base and 19 pin joints (25 dofs altogether), this <br>
   * method takes 12*(20+25)=540 flops while the explicit matrix-vector multiply <br>
   * would take 12*20*25=6000 flops. So this method is already &gt;10X faster for <br>
   * that small system; for larger systems the difference grows rapidly.<br>
   * <br>
   * @see multiplyBySystemJacobianTranspose(), calcSystemJacobian() *
   */
  public void multiplyBySystemJacobian(State state, Vector u, VectorOfSpatialVec Ju) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyBySystemJacobian(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(u), u, VectorOfSpatialVec.getCPtr(Ju), Ju);
  }

  /**
   *  Calculate the acceleration bias term for the %System Jacobian, that is, the<br>
   * part of the acceleration that is due only to velocities. This term is also<br>
   * known as the Coriolis acceleration, and it is returned here as a spatial<br>
   * acceleration of each body frame in Ground.<br>
   * <br>
   * @param state<br>
   *     A State that has already been realized through Velocity stage.<br>
   * @param JDotu<br>
   *     The product JDot*u where JDot = d/dt J, and u is the vector of generalized<br>
   *     speeds taken from <i>state</i>. This is a Vector of nb SpatialVec elements.<br>
   * <br>
   * <h3>Theory</h3><br>
   * The spatial velocity V_GBi of each body i can be obtained from the generalized<br>
   * speeds u by V = {V_GBi} = J*u. Taking the time derivative in G gives<br>
   * <pre><br>
   *     A = d/dt V = {A_GBi} = J*udot + JDot*u<br>
   * </pre><br>
   * where JDot=JDot(q,u). This method returns JDot*u, which depends only on <br>
   * configuration q and speeds u. Note that the same u is used to calculate JDot, <br>
   * which is linear in u, so this term is quadratic in u.<br>
   * <br>
   * <h3>Implementation</h3><br>
   * This method simply extracts the total Coriolis acceleration for each body that<br>
   * is already available in the <i>state</i> cache so there is no computation done<br>
   * here.<br>
   * @see getTotalCoriolisAcceleration()
   */
  public void calcBiasForSystemJacobian(State state, VectorOfSpatialVec JDotu) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForSystemJacobian__SWIG_0(swigCPtr, this, State.getCPtr(state), state, VectorOfSpatialVec.getCPtr(JDotu), JDotu);
  }

  /**
   *  Alternate signature that returns the bias as a 6*nb-vector of scalars <br>
   * rather than as an nb-vector of 2x3 spatial vectors. See the other signature for<br>
   * documentation. *
   */
  public void calcBiasForSystemJacobian(State state, Vector JDotu) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForSystemJacobian__SWIG_1(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(JDotu), JDotu);
  }

  /**
   *  Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and<br>
   * a vector F_G of spatial force-like elements, one per body, in O(n) time to <br>
   * produce a generalized force-like result f=~J*F. If F_G is actually a set of<br>
   * spatial forces applied at the body frame origin of each body, and expressed<br>
   * in the Ground frame, then the result is the equivalent set of generalized<br>
   * forces f that would produce the same accelerations as F_G.<br>
   * <br>
   * @param state<br>
   *     A State compatible with this System that has already been realized to<br>
   *     Stage::Position.<br>
   * @param F_G<br>
   *     This is a vector of SpatialVec elements, one per mobilized body and in<br>
   *     order of MobilizedBodyIndex (with the 0th entry a force on Ground; hence<br>
   *     ignored). Each SpatialVec is a spatial force-like pair of 3-vectors <br>
   *     (torque,force) with the force applied at the body origin and the vectors<br>
   *     expressed in Ground.<br>
   * @param f<br>
   *     This is the product f=~J*F_G as described above. This result is in the<br>
   *     generalized force space, that is, it has one scalar entry for each of the<br>
   *     n system mobilities (velocity degrees of freedom). Resized if necessary.<br>
   * <br>
   * The kinematic Jacobian (partial velocity matrix) J is defined as follows:<br>
   * <pre><br>
   *       partial(V)                                 T                        T<br>
   *   J = ----------, V = [V_GB0 V_GB1 ... V_GB nb-1] ,  u = [u0 u1 ... u n-1]<br>
   *       partial(u)<br>
   * </pre><br>
   * Thus the element J(i,j)=partial(V_GBi)/partial(uj) (each element of J is a<br>
   * spatial vector). J maps generalized speeds to spatial velocities (see<br>
   * multiplyBySystemJacobian()); its transpose ~J maps spatial forces <br>
   * to generalized forces.<br>
   * <br>
   * Note that we're using "monogram" notation for the spatial velocities, where<br>
   * <pre><br>
   *             G Bi<br>
   *     V_GBi =  V<br>
   * </pre><br>
   * the spatial velocity of body i's body frame Bi (at its origin), measured and<br>
   * expressed in the Ground frame G.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * This is a very fast operator, costing about 18*nb+11*n flops, where nb is the<br>
   * number of bodies and n the number of mobilities (degrees of freedom) u. In <br>
   * contrast, even if you have already calculated the entire 6*nbXnu matrix J, the<br>
   * multiplication ~J*F would cost 12*nb*n flops. As an example, for a 20 body <br>
   * system with a free flying base and 19 pin joints (25 dofs altogether), this <br>
   * method takes 18*20+11*25=635 flops while the explicit matrix-vector multiply <br>
   * would take 12*20*25=6000 flops. So this method is already &gt;9X faster for <br>
   * that small system; for larger systems the difference grows rapidly. <br>
   * <br>
   * @see multiplyBySystemJacobian(), calcSystemJacobian() *
   */
  public void multiplyBySystemJacobianTranspose(State state, VectorOfSpatialVec F_G, Vector f) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyBySystemJacobianTranspose(swigCPtr, this, State.getCPtr(state), state, VectorOfSpatialVec.getCPtr(F_G), F_G, Vector.getCPtr(f), f);
  }

  /**
   *  Explicitly calculate and return the nb x nu whole-system kinematic <br>
   * Jacobian J_G, with each element a 2x3 spatial vector (SpatialVec). This matrix <br>
   * maps generalized speeds to the spatial velocities of all the bodies, which <br>
   * will be at the body origins, measured and expressed <br>
   * in Ground. That is, if you have a set of n generalized speeds u, you can <br>
   * find the spatial velocities of all nb bodies as V_G = J_G*u. The transpose of <br>
   * this matrix maps a set of spatial forces F_G, applied at the body frame <br>
   * origins and expressed in Ground, to the equivalent set of n generalized <br>
   * forces f: f = ~J_G*F_G. <br>
   * <br>
   * Note: The 0th row of the returned Jacobian is always zero since it represents<br>
   * the spatial velocity of Ground.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * Before using this method, consider whether you really need to form this<br>
   * very large matrix which necessarily will take O(n^2) space and time; it will <br>
   * almost always be <i>much</i> faster to use the multiplyBySystemJacobian() method <br>
   * that directly calculate the matrix-vector product in O(n) time without explicitly <br>
   * forming the matrix. Here are the details:<br>
   * <br>
   * As currently implemented, forming the full Jacobian J costs about<br>
   * 12*n*(nb+n) flops. Assuming nb ~= n, this is about 24*n^2 flops. Then<br>
   * if you want to form a product J*u explicitly, the matrix-vector multiply will <br>
   * cost about 12*n^2 flops each time you do it. In contrast the J*u product is <br>
   * calculated using multiplyBySystemJacobian() in about 24*n flops. Even for<br>
   * very small systems it is cheaper to make repeated calls to <br>
   * multiplyBySystemJacobian() than to form J explicitly and multiply by it.<br>
   * See the Performance section for multiplyBySystemJacobian() for more<br>
   * comparisons.<br>
   * <br>
   * @see multiplyBySystemJacobian(), multiplyBySystemJacobianTranspose()@see calcSystemJacobian() alternate signature using scalar elements *
   */
  public void calcSystemJacobian(State state, MatrixOfSpatialVec J_G) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemJacobian__SWIG_0(swigCPtr, this, State.getCPtr(state), state, MatrixOfSpatialVec.getCPtr(J_G), J_G);
  }

  /**
   *  Alternate signature that returns a system Jacobian as a 6*nb X n Matrix <br>
   * of scalars rather than as an nb X n matrix of 2x3 spatial vectors. See<br>
   * the other signature for documentation and important performance <br>
   * considerations. *
   */
  public void calcSystemJacobian(State state, Matrix J_G) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcSystemJacobian__SWIG_1(swigCPtr, this, State.getCPtr(state), state, Matrix.getCPtr(J_G), J_G);
  }

  /**
   *  Calculate the Cartesian ground-frame velocities of a set of task stations <br>
   * (points fixed on bodies) that results from a particular set of generalized <br>
   * speeds u. The result is the station velocities measured and expressed in Ground.<br>
   * <br>
   * @param state<br>
   *     A State that has already been realized through Position stage.<br>
   * @param onBodyB<br>
   *     An array of nt mobilized bodies (one per task) to which the stations of <br>
   *     interest are fixed.<br>
   * @param stationPInB<br>
   *     The array of nt station points P of interest (one per task), each<br>
   *     corresponding to one of the bodies B from <i>onBodyB</i>, given as vectors <br>
   *     from each body B's origin Bo to its station P, expressed in frame B.<br>
   * @param u<br>
   *     A mobility-space Vector, such as a set of generalized speeds. The length<br>
   *     and order must match the mobilities of this system (that is n, the number<br>
   *     of generalized speeds u, <i>not</i> nq, the number of generalized <br>
   *     coordinates q).<br>
   * @param JSu<br>
   *     The resulting product JS*u, where JS is the station task Jacobian. Resized<br>
   *     to nt if needed.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * It is almost always better to use this method than to form an explicit 3*nt X n <br>
   * station task Jacobian explicitly and then multiply by it. If you have only one <br>
   * or two tasks, so that the matrix is only 3xn or 6xn, and then perform many <br>
   * multiplies with that matrix, it might be slightly cheaper to form it. For <br>
   * example, it is about 4X cheaper to use this method than to form a one-task <br>
   * Station Jacobian JS explicitly and use it once. However, because this would be <br>
   * such a skinny matrix (3 X n) explicit multiplication is cheap so if you will <br>
   * re-use this same Jacobian repeatedly before recalculating (at least 6 times) <br>
   * then it may be worth calculating and saving it. Here are the details:<br>
   * <br>
   * A call to this method costs 27*nt + 12*(nb+n) flops. If you assume that <br>
   * nb ~= n &gt;&gt; 1, you could say this is about 27*nt + 24*n flops. In<br>
   * contrast, assuming you already have the 3*nt X n station Jacobian JS available,<br>
   * you can compute the JS*u product in about 6*nt*n flops, 3X faster for one task,<br>
   * about even for three tasks, and slower for more than three tasks.<br>
   * However forming JS costs about 40*nt+90*n flops (see calcStationJacobian()).<br>
   * So to form a one-task Jacobian and use it once is 4X more expensive (96*n vs<br>
   * 24*n), but if you use it more than 5 times it is cheaper to do it<br>
   * explicitly. Forming a one-task JS and using it 100 times costs about 690*n <br>
   * flops while calling this method 100 times would cost about 2400*n flops.<br>
   * <br>
   * @see multiplyByStationJacobianTranspose(), calcStationJacobian() *
   */
  public void multiplyByStationJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 stationPInB, Vector u, VectorVec3 JSu) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByStationJacobian__SWIG_0(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(stationPInB), stationPInB, Vector.getCPtr(u), u, VectorVec3.getCPtr(JSu), JSu);
  }

  /**
   *  Alternate signature for when you just have a single station task. <br>
   * @return JS*u, where JS is the station task Jacobian. *
   */
  public Vec3 multiplyByStationJacobian(State state, int onBodyB, Vec3 stationPInB, Vector u) {
    return new Vec3(opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByStationJacobian__SWIG_1(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(stationPInB), stationPInB, Vector.getCPtr(u), u), true);
  }

  /**
   *  Calculate the generalized forces resulting from a single force applied<br>
   * to a set of nt station tasks (points fixed to bodies) P. The applied forces <br>
   * f_GP should be 3-vectors expressed in Ground. This is considerably faster than <br>
   * forming the Jacobian explicitly and then performing the matrix-vector multiply.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * Cost is about 30*nt + 18*nb + 11*n. Assuming nb ~= n, this is roughly<br>
   * 30*(n+nt). In contrast, forming the complete 3*nt X n matrix would cost about<br>
   * 90*(n+nt/2), and subsequent explicit matrix-vector multiplies would cost<br>
   * about 6*nt*n each.<br>
   * <br>
   * @see multiplyByStationJacobian(), calcStationJacobian() *
   */
  public void multiplyByStationJacobianTranspose(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 stationPInB, VectorVec3 f_GP, Vector f) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByStationJacobianTranspose__SWIG_0(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(stationPInB), stationPInB, VectorVec3.getCPtr(f_GP), f_GP, Vector.getCPtr(f), f);
  }

  /**
   *  Alternate signature for when you just have a single station task. *
   */
  public void multiplyByStationJacobianTranspose(State state, int onBodyB, Vec3 stationPInB, Vec3 f_GP, Vector f) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByStationJacobianTranspose__SWIG_1(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(stationPInB), stationPInB, Vec3.getCPtr(f_GP), f_GP, Vector.getCPtr(f), f);
  }

  /**
   *  Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a <br>
   * set of nt station tasks P (a station is a point fixed on a particular mobilized <br>
   * body). This matrix maps generalized speeds to the Cartesian velocity of each<br>
   * station, measured and expressed in Ground. That is, if you have a set of n <br>
   * generalized speeds u, you can find the Cartesian velocities of stations P as <br>
   * v_GP = JS*u, where v_GP is a 3*nt column vector. The transpose of this <br>
   * matrix maps a 3*nt vector of forces f_GP (expressed in Ground and applied <br>
   * to P) to the equivalent set of n generalized forces f: f = ~JS*f_GP.<br>
   * <br>
   * Note: It is almost always far more efficient to use multiplyByStationJacobian()<br>
   * or multiplyByStationJacobianTranspose() to form matrix-vector products rather <br>
   * than to use this method to form the Jacobian explicitly. See the performance <br>
   * discussions there.<br>
   * <br>
   * Overloaded signatures of this method are available to allow you to obtain the<br>
   * Jacobian either as an nt X n Matrix with Vec3 elements, or as 3*nt X n Matrix<br>
   * with scalar elements.<br>
   * <br>
   * @param state<br>
   *     A State that has already been realized through Position stage.<br>
   * @param onBodyB<br>
   *     An array of nt mobilized bodies (one per task) to which the stations of <br>
   *     interest are fixed.<br>
   * @param stationPInB<br>
   *     The array of nt station points P of interest (one per task), each<br>
   *     corresponding to one of the bodies B from <i>onBodyB</i>, given as vectors <br>
   *     from each body B's origin Bo to its station P, expressed in frame B.<br>
   * @param JS<br>
   *     The resulting nt X n station task Jacobian. Resized if necessary.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * The cost of a call to this method is about 42*nt + 54*nb + 33*n flops. If we <br>
   * assume that nb ~= n &gt;&gt; 1, this is roughly 90*(n+nt/2) flops. Then once the <br>
   * Station Jacobian JS has been formed, each JS*u matrix-vector product costs<br>
   * 6*nt*n flops to form. When nt is small enough (say one or two tasks), and you<br>
   * plan to re-use it a lot, this can be computationally efficient; but for single<br>
   * use or more than a few tasks you can do much better with <br>
   * multiplyByStationJacobian() or multiplyByStationJacobianTranspose().<br>
   * <br>
   * @see multiplyByStationJacobian(), multiplyByStationJacobianTranspose() *
   */
  public void calcStationJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 stationPInB, MatrixVec3 JS) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcStationJacobian__SWIG_0(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(stationPInB), stationPInB, MatrixVec3.getCPtr(JS), JS);
  }

  /**
   *  Alternate signature for when you just have a single station task. *
   */
  public void calcStationJacobian(State state, int onBodyB, Vec3 stationPInB, RowVectorVec3 JS) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcStationJacobian__SWIG_1(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(stationPInB), stationPInB, RowVectorVec3.getCPtr(JS), JS);
  }

  /**
   *  Alternate signature that returns a station Jacobian as a 3*nt x n Matrix <br>
   * rather than as a Matrix of Vec3 elements. See the other signature for <br>
   * documentation and important performance considerations. *
   */
  public void calcStationJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 stationPInB, Matrix JS) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcStationJacobian__SWIG_2(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(stationPInB), stationPInB, Matrix.getCPtr(JS), JS);
  }

  /**
   *  Alternate signature for when you just have a single station task. *
   */
  public void calcStationJacobian(State state, int onBodyB, Vec3 stationPInB, Matrix JS) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcStationJacobian__SWIG_3(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(stationPInB), stationPInB, Matrix.getCPtr(JS), JS);
  }

  /**
   *  Calculate the acceleration bias term for a station Jacobian, that is, the<br>
   * part of the station's acceleration that is due only to velocities. This term <br>
   * is also known as the Coriolis acceleration, and it is returned here as a linear<br>
   * acceleration of the station in Ground.<br>
   * <br>
   * @param state<br>
   *     A State that has already been realized through Velocity stage.<br>
   * @param onBodyB<br>
   *     An array of nt mobilized bodies (one per task) to which the stations of <br>
   *     interest are fixed.<br>
   * @param stationPInB<br>
   *     The array of nt station points P of interest (one per task), each<br>
   *     corresponding to one of the bodies B from <i>onBodyB</i>, given as vectors <br>
   *     from each body B's origin Bo to its station P, expressed in frame B.<br>
   * @param JSDotu<br>
   *     The resulting product JSDot*u, where JSDot is the time derivative of JS,<br>
   *     the station task Jacobian. Resized to nt if needed.<br>
   * <br>
   * <h3>Theory</h3><br>
   * The velocity v_GP of a station point P in the Ground frame G can be obtained <br>
   * from the generalized speeds u using the station Jacobian for P, as <pre><br>
   *     v_GP = JS_P*u<br>
   * </pre> Taking the time derivative in G gives <pre><br>
   *     a_GP = JS_P*udot + JSDot_P*u<br>
   * </pre><br>
   * This method returns JSDot_P*u, which depends only on configuration and <br>
   * velocities. We allow for a set of task points P so that all their bias terms<br>
   * can be calculated in a single sweep of the multibody tree. Note that u is taken<br>
   * from the <i>state</i> and that the same u shown above is also used to calculate <br>
   * JSDot_P, which is linear in u, so the bias term is quadratic in u.<br>
   * <br>
   * <h3>Implementation</h3><br>
   * This method just obtains body B's total Coriolis acceleration already available<br>
   * in the <i>state</i> cache and shifts it to station point P. Cost is 48*nt flops.<br>
   * @see getTotalCoriolisAcceleration(), shiftAccelerationBy()
   */
  public void calcBiasForStationJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 stationPInB, VectorVec3 JSDotu) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForStationJacobian__SWIG_0(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(stationPInB), stationPInB, VectorVec3.getCPtr(JSDotu), JSDotu);
  }

  /**
   *  Alternate signature that returns the bias as a 3*nt-vector of scalars <br>
   * rather than as an nt-vector of Vec3s. See the other signature for<br>
   * documentation. *
   */
  public void calcBiasForStationJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 stationPInB, Vector JSDotu) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForStationJacobian__SWIG_1(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(stationPInB), stationPInB, Vector.getCPtr(JSDotu), JSDotu);
  }

  /**
   *  Alternate signature for when you just have a single station task. <br>
   * @return JSDot*u, where JSDot is the station Jacobian time derivative. *
   */
  public Vec3 calcBiasForStationJacobian(State state, int onBodyB, Vec3 stationPInB) {
    return new Vec3(opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForStationJacobian__SWIG_2(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(stationPInB), stationPInB), true);
  }

  /**
   *  Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to <br>
   * nt bodies B={Bi}, that result from a particular set of n generalized speeds u.<br>
   * <br>
   * The result is each task frame's angular and linear velocity measured and <br>
   * expressed in Ground. Using this method is considerably faster than forming the <br>
   * 6*nt X n Frame Jacobian explicitly and then performing the matrix-vector <br>
   * multiply. See the performance analysis below for details.<br>
   * <br>
   * There is a simplified signature of this method available if you have only a<br>
   * single frame task.<br>
   * <br>
   * @param state<br>
   *     A State that has already been realized through Position stage.<br>
   * @param onBodyB<br>
   *     An array of nt mobilized bodies (one per task) to which the task frames of <br>
   *     interest are fixed. These may be in any order and the same body may appear<br>
   *     more than once if there are multiple task frames on it.<br>
   * @param originAoInB<br>
   *     An array of nt frame origin points Ao for the task frames interest (one <br>
   *     per task), each corresponding to one of the bodies B from <i>onBodyB</i>, given<br>
   *     as vectors from each body B's origin Bo to its task frame origin Ao, <br>
   *     expressed in frame B.<br>
   * @param u<br>
   *     A mobility-space Vector, such as a set of generalized speeds. The length<br>
   *     and order must match the mobilities of this system (that is n, the number<br>
   *     of generalized speeds u, <i>not</i> nq, the number of generalized <br>
   *     coordinates q).<br>
   * @param JFu<br>
   *     The resulting product JF*u, where JF is the frame task Jacobian. Resized<br>
   *     if needed to a Vector of nt SpatialVec entries.<br>
   * <br>
   * Note: All frames A fixed to a given body B have the same angular velocity so <br>
   * we do not actually need to know the task frames' orientations here, just the<br>
   * location on B of their origin points Ao. If you have a Transform X_BA giving <br>
   * the pose of frame A in the body frame B, you can extract the position vector <br>
   * for the origin point Ao using X_BA.p() and pass that as the <i>originAoInB</i> <br>
   * parameter here.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * A call to this method costs 27*nt + 12*(nb+n) flops. If you assume that <br>
   * nb ~= n &gt;&gt; 1, you could say this is about 25*(nt+n) flops. In contrast, assuming <br>
   * you already have the 6*nt X n Frame Jacobian JF available, you can compute the<br>
   * JF*u product in about 12*nt*n flops. If you have just one task (nt==1) this<br>
   * explicit multiplication is about twice as fast; at two tasks it is about even<br>
   * and for more than two it is more expensive. However forming JF costs about <br>
   * 180*(n+nt/4) flops (see calcFrameJacobian()). So to form a one-task Jacobian <br>
   * and use it once is almost 8X more expensive (192*n vs 25*n), but if you use it <br>
   * more than 16 times it is (marginally) cheaper to do it explicitly (for one<br>
   * task). For example, forming a one-task JF and using it 100 times costs 1392*n <br>
   * flops while calling this method 100 times would cost about 2500*n flops.<br>
   * <br>
   * Conclusion: in almost all practical cases you are better off using this operator<br>
   * rather than forming JF, even if you have only a single frame task and certainly <br>
   * if you have more than two tasks.<br>
   * <br>
   * @see multiplyByFrameJacobianTranspose(), calcFrameJacobian() *
   */
  public void multiplyByFrameJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 originAoInB, Vector u, VectorOfSpatialVec JFu) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByFrameJacobian__SWIG_0(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(originAoInB), originAoInB, Vector.getCPtr(u), u, VectorOfSpatialVec.getCPtr(JFu), JFu);
  }

  /**
   *  Simplified signature for when you just have a single frame task; see the<br>
   * main signature for documentation.<br>
   * @return JF*u, where JF is the single frame task Jacobian. *
   */
  public SpatialVec multiplyByFrameJacobian(State state, int onBodyB, Vec3 originAoInB, Vector u) {
    return new SpatialVec(opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByFrameJacobian__SWIG_1(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(originAoInB), originAoInB, Vector.getCPtr(u), u), true);
  }

  /**
   *  Calculate the n generalized forces f resulting from a set of spatial forces <br>
   * (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi. The <br>
   * applied forces are spatial vectors (pairs of 3-vectors) expressed in Ground. Use<br>
   * of this O(n) method is considerably faster than forming the 6*nt X n Jacobian <br>
   * explicitly and then performing an O(n^2) matrix-vector multiply.<br>
   * <br>
   * @param state<br>
   *     A State that has already been realized through Position stage.<br>
   * @param onBodyB<br>
   *     An array of nt mobilized bodies (one per task) to which the task frames of <br>
   *     interest are fixed. These may be in any order and the same body may appear<br>
   *     more than once if there are multiple task frames on it.<br>
   * @param originAoInB<br>
   *     An array of nt frame origin points Ao for the task frames interest (one <br>
   *     per task), each corresponding to one of the bodies B from <i>onBodyB</i>, given<br>
   *     as vectors from each body B's origin Bo to its task frame origin Ao, <br>
   *     expressed in frame B.<br>
   * @param F_GAo<br>
   *     A Vector of nt spatial forces, each applied one of the task frames. These<br>
   *     are expressed in Ground.<br>
   * @param f<br>
   *     The Vector of n generalized forces that results from applying the forces<br>
   *     <i>F_GAo</i> to the task frames. Resized if necessary.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * A call to this method costs 33*nt + 18*nb + 11*n flops. If you assume that <br>
   * nb ~= n &gt;&gt; 1, you could say this is about 30*(n+nt) flops. In contrast, assuming <br>
   * you already have the 6*nt X n Frame Jacobian JF available, you can compute the<br>
   * ~JF*F product in about 12*nt*n flops. For one or two tasks that would be faster<br>
   * than applying the operator. However forming JF costs about 180*(n+nt/4) flops <br>
   * (see calcFrameJacobian()). So to form even a one-task Frame Jacobian and use <br>
   * it once is about 6X more expensive than using the operator (192*n vs 30*n), <br>
   * but if you use it more than 10 times it is (marginally) cheaper to do it <br>
   * explicitly. For example, forming a one-task JF and using it 100 times costs <br>
   * around 1392*n flops while calling this method 100 times would cost about <br>
   * 3000*n flops.<br>
   * <br>
   * Conclusion: in almost all practical cases you are better off using this operator<br>
   * rather than forming JF, even if you have only a single frame task and certainly <br>
   * if you have more than two tasks.<br>
   * <br>
   * @see multiplyByFrameJacobian(), calcFrameJacobian() *
   */
  public void multiplyByFrameJacobianTranspose(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 originAoInB, VectorOfSpatialVec F_GAo, Vector f) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByFrameJacobianTranspose__SWIG_0(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(originAoInB), originAoInB, VectorOfSpatialVec.getCPtr(F_GAo), F_GAo, Vector.getCPtr(f), f);
  }

  /**
   *  Simplified signature for when you just have a single frame task. See the<br>
   * other signature for documentation. *
   */
  public void multiplyByFrameJacobianTranspose(State state, int onBodyB, Vec3 originAoInB, SpatialVec F_GAo, Vector f) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByFrameJacobianTranspose__SWIG_1(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(originAoInB), originAoInB, SpatialVec.getCPtr(F_GAo), F_GAo, Vector.getCPtr(f), f);
  }

  /**
   *  Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a <br>
   * set of nt frame tasks A={Ai} fixed to nt bodies B={Bi}. This matrix maps <br>
   * generalized speeds to the Cartesian spatial velocity (angular and linear<br>
   * velocity) of each frame, measured and expressed in Ground. That is, if you have<br>
   * a set of n generalized speeds u, you can find the Cartesian spatial velocities <br>
   * of task frames A as V_GA = JF*u, where V_GA is a 6*nt column vector. The <br>
   * transpose of this matrix maps a 6*nt vector of spatial forces F_GA (expressed <br>
   * in Ground and applied to the origins of frames A) to the equivalent set of n <br>
   * generalized forces f: f = ~JF*F_GA.<br>
   * <br>
   * Note: It is almost always far more efficient to use multiplyByFrameJacobian() or<br>
   * multiplyByFrameJacobianTranspose() to form matrix-vector products rather than to<br>
   * use this method to form the Jacobian explicitly. See the performance discussion <br>
   * there.<br>
   * <br>
   * Overloaded signatures of this method are available to allow you to obtain the<br>
   * Jacobian either as an nt X n Matrix with SpatialVec elements, or as 6*nt X n <br>
   * Matrix with scalar elements.<br>
   * <br>
   * @param state<br>
   *     A State that has already been realized through Position stage.<br>
   * @param onBodyB<br>
   *     An array of nt mobilized bodies (one per task) to which the task frames of <br>
   *     interest are fixed. These may be in any order and the same body may appear<br>
   *     more than once if there are multiple task frames on it.<br>
   * @param originAoInB<br>
   *     An array of nt frame origin points Ao for the task frames of interest (one <br>
   *     per task), each corresponding to one of the bodies B from <i>onBodyB</i>, given<br>
   *     as vectors from each body B's origin Bo to its task frame origin Ao, <br>
   *     expressed in frame B.<br>
   * @param JF<br>
   *     The resulting nt X n frame task Jacobian, with each element a SpatialVec. <br>
   *     Resized if necessary.<br>
   * <br>
   * <h3>Performance discussion</h3><br>
   * The cost of a call to this method is about 42*nt + 108*nb + 66*n flops. If we <br>
   * assume that nb ~= n &gt;&gt; 1, this is roughly 180*(n+nt/4) flops. Then once the <br>
   * Frame Jacobian JF has been formed, each JF*u matrix-vector product costs about<br>
   * 12*nt*n flops to form. When nt is small enough (say one or two tasks), and you<br>
   * plan to re-use it a lot, this can be computationally efficient; but for single<br>
   * use or more than a few tasks you can do much better with <br>
   * multiplyByFrameJacobian() or multiplyByFrameJacobianTranspose().<br>
   * <br>
   * @see multiplyByFrameJacobian(), multiplyByFrameJacobianTranspose() *
   */
  public void calcFrameJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 originAoInB, MatrixOfSpatialVec JF) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcFrameJacobian__SWIG_0(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(originAoInB), originAoInB, MatrixOfSpatialVec.getCPtr(JF), JF);
  }

  /**
   *  Simplified signature for when you just have a single frame task. See the<br>
   * other signature for documentation. *
   */
  public void calcFrameJacobian(State state, int onBodyB, Vec3 originAoInB, SWIGTYPE_p_SimTK__RowVector_T_SimTK__VecT_2_SimTK__Vec3_1_t_t JF) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcFrameJacobian__SWIG_1(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(originAoInB), originAoInB, SWIGTYPE_p_SimTK__RowVector_T_SimTK__VecT_2_SimTK__Vec3_1_t_t.getCPtr(JF));
  }

  /**
   *  Alternate signature that returns a frame Jacobian as a 6*nt X n Matrix <br>
   * rather than as an nt X n Matrix of SpatialVecs. See the other signature for<br>
   * documentation and important performance considerations.*
   */
  public void calcFrameJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 originAoInB, Matrix JF) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcFrameJacobian__SWIG_2(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(originAoInB), originAoInB, Matrix.getCPtr(JF), JF);
  }

  /**
   *  Simplified signature for when you just have a single frame task. See the<br>
   * other signature for documentation. *
   */
  public void calcFrameJacobian(State state, int onBodyB, Vec3 originAoInB, Matrix JF) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcFrameJacobian__SWIG_3(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(originAoInB), originAoInB, Matrix.getCPtr(JF), JF);
  }

  /**
   *  Calculate the acceleration bias term for a task frame Jacobian, that is, the<br>
   * parts of the frames' accelerations that are due only to velocities. This term <br>
   * is also known as the Coriolis acceleration, and it is returned here as spatial<br>
   * accelerations of the frames in Ground.<br>
   * <br>
   * There is a simplified signature of this method available if you have only a<br>
   * single frame task.<br>
   * <br>
   * @param state<br>
   *     A State that has already been realized through Velocity stage.<br>
   * @param onBodyB<br>
   *     An array of nt mobilized bodies (one per task) to which the task frames of <br>
   *     interest are fixed. These may be in any order and the same body may appear<br>
   *     more than once if there are multiple task frames on it.<br>
   * @param originAoInB<br>
   *     An array of nt frame origin points Ao for the task frames of interest (one <br>
   *     per task), each corresponding to one of the bodies B from <i>onBodyB</i>, given<br>
   *     as vectors from each body B's origin Bo to its task frame origin Ao, <br>
   *     expressed in frame B.<br>
   * @param JFDotu<br>
   *     The result JFDot*u, where JF is the task frame Jacobian and JFDot its<br>
   *     time derivative, and u is the set of generalized speeds taken from the<br>
   *     the supplied <i>state</i>.<br>
   * <br>
   * <h3>Theory</h3><br>
   * The spatial velocity V_GA of frame A can be obtained from the generalized<br>
   * speeds u using the frame Jacobian for A, as V_GA = JF*u. Taking the time <br>
   * derivative in G gives<br>
   * <pre><br>
   *     A_GA = JF*udot + JFDot*u<br>
   * </pre><br>
   * This method returns JFDot*u, which depends only on configuration and <br>
   * velocities. Note that the same u is used to calculate JFDot, which is linear<br>
   * in u, so the term JFDot*u is quadratic in u.<br>
   * <br>
   * <h3>Implementation</h3><br>
   * This method just obtains body B's total Coriolis acceleration already available<br>
   * in the <i>state</i> cache and shifts it to the A frame's origin Ao, for each of the<br>
   * nt task frames. Cost is 48*nt flops.<br>
   * <br>
   * @see getTotalCoriolisAcceleration(), shiftAccelerationBy()
   */
  public void calcBiasForFrameJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 originAoInB, VectorOfSpatialVec JFDotu) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForFrameJacobian__SWIG_0(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(originAoInB), originAoInB, VectorOfSpatialVec.getCPtr(JFDotu), JFDotu);
  }

  /**
   *  Alternate signature that returns the bias as a 6*nt-vector of scalars <br>
   * rather than as an nt-vector of SpatialVec elements. See the other signature for<br>
   * documentation. *
   */
  public void calcBiasForFrameJacobian(State state, SimTKArrayMobilizedBodyIndex onBodyB, SimTKArrayVec3 originAoInB, Vector JFDotu) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForFrameJacobian__SWIG_1(swigCPtr, this, State.getCPtr(state), state, SimTKArrayMobilizedBodyIndex.getCPtr(onBodyB), onBodyB, SimTKArrayVec3.getCPtr(originAoInB), originAoInB, Vector.getCPtr(JFDotu), JFDotu);
  }

  /**
   *  Simplified signature for when you just have a single frame task. <br>
   * @return JFDot*u, where JFDot is the frame task Jacobian time derivative and<br>
   * u the generalized speeds taken from <i>state</i>. *
   */
  public SpatialVec calcBiasForFrameJacobian(State state, int onBodyB, Vec3 originAoInB) {
    return new SpatialVec(opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForFrameJacobian__SWIG_2(swigCPtr, this, State.getCPtr(state), state, onBodyB, Vec3.getCPtr(originAoInB), originAoInB), true);
  }

  /**
   * ** This operator calculates in O(n) time the product M*v where M is the <br>
   * system mass matrix and v is a supplied mobility-space vector (that is, it has<br>
   * one entry for each of the n mobilities). If v is a set of mobility accelerations<br>
   * (generalized accelerations udot), then the result is a generalized force <br>
   * (f=M*udot). Only the supplied vector is used, and M depends only on position <br>
   * states, so the result here is not affected by velocities in the State.<br>
   * Constraints and prescribed motions are ignored.<br>
   * <br>
   * The current implementation requires about 120*n flops and does not require <br>
   * realization of composite-body or articulated-body inertias. <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public void multiplyByM(State state, Vector a, Vector Ma) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByM(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(a), a, Vector.getCPtr(Ma), Ma);
  }

  /**
   *  This operator calculates in O(n) time the product M^-1*v where M is the <br>
   * system mass matrix and v is a supplied vector with one entry per u-space<br>
   * mobility. If v is a set of generalized forces f, the result is a generalized <br>
   * acceleration (udot=M^-1*f). Only the supplied vector is used, and M depends <br>
   * only on position states, so the result here is not affected by velocities in <br>
   * <i>state</i>. In particular, you'll have to obtain your own inertial forces and <br>
   * put them in f if you want them included.<br>
   * <br>
   * @param state<br>
   *     This is a State that has been realized through Position stage, from which<br>
   *     the current system configuration and articulated body inertias are <br>
   *     obtained. If necessary, the articulated body inertias will be realized in<br>
   *     the state the first time this is called. They will then be retained in the<br>
   *     <i>state</i> cache for speed.<br>
   * @param v<br>
   *     This is a generalized-force like vector in mobility space (u-space). If <br>
   *     there is any prescribed motion specified using Motion objects or mobilizer<br>
   *     locking (see below), then only the entries of v corresponding to <br>
   *     non-prescribed mobilities are examined by this method; the prescribed ones <br>
   *     are not referenced at all. <br>
   * @param MinvV<br>
   *     This is the result M^-1*v. If there is any prescribed motion specified<br>
   *     using Motion objects or mobilizer locks (see below), then only the <br>
   *     non-prescribed entries in MinvV are calculated; the prescribed ones are set <br>
   *     to zero.<br>
   * <br>
   * <h3>Behavior with prescribed motion</h3><br>
   * If you prescribe the motion of one or more mobilizers using Motion objects or<br>
   * mobilizer locking, the behavior of this method is altered. (This does <i>not</i> <br>
   * apply if you use Constraint objects to specify the motion.) With prescribed<br>
   * motion enabled, this method works only with the free (non-prescribed) <br>
   * mobilities. Only the entries in <i>v</i> corresponding to free mobilities are <br>
   * examined, and only the entries in the result <i>MinvV</i> corresponding to free <br>
   * mobilities are calculated; the others are set to zero.<br>
   * <br>
   * <h3>Theory</h3><br>
   * View the unconstrained, prescribed zero-velocity equations of motion <br>
   * M udot + tau = f as partitioned into "free" and "prescribed" variables like <br>
   * this:<br>
   * <pre><br>
   *     [M_ff ~M_fp] [udot_f]   [ 0 ]   [f_f]<br>
   *     [          ] [      ] + [   ] = [   ]<br>
   *     [M_fp  M_pp] [udot_p]   [tau]   [f_p]<br>
   * </pre><br>
   * The free and prescribed variables have been grouped here for clarity but<br>
   * in general they are interspersed among the columns and rows of M.<br>
   * <br>
   * Given that decomposition, this method returns<br>
   * <pre><br>
   *     [udot_f]   [udot_f]   [M_ff^-1  0  ][f_f]<br>
   *     [      ] = [      ] = [            ][   ]<br>
   *     [udot_p]   [  0   ]   [   0     0  ][f_p]<br>
   * </pre><br>
   * When there is no prescribed motion M_ff is the entire mass matrix, and the <br>
   * result is udot_f=udot=M^-1*f. When there is prescribed motion, M_ff is a <br>
   * submatrix of M, and the result is the nf elements of udot_f, with udot_p=0.<br>
   * <br>
   * <h3>Implementation</h3><br>
   * This is a stripped-down version of forward dynamics. It requires the hybrid<br>
   * free/prescribed articulated body inertias to have been realized and will <br>
   * initiate that calculation if necessary the first time it is called for a given <br>
   * configuration q. The M^-1*f calculation requires two sweeps of the multibody <br>
   * tree, an inward sweep to accumulate forces, followed by an outward sweep to <br>
   * propagate accelerations.<br>
   * <br>
   * <h3>Performance</h3><br>
   * If the supplied State does not already contain realized values for the<br>
   * articulated body inertias, then they will be realized when this operator is <br>
   * first called for a new set of positions. Calculating articulated body inertias<br>
   * is O(n) but relatively expensive. Once the appropriate articulated body <br>
   * inertias are available, repeated calls to this operator are very fast, with <br>
   * worst case around 80*n flops when all mobilizers have 1 dof. If you want to<br>
   * force realization of the articulated body inertias, call the method<br>
   * realizeArticulatedBodyInertias().<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> (articulated body inertias realized first if necessary)</p><br>
   * <br>
   * @see multiplyByM(), calcMInv(), realizeArticulatedBodyInertias() *
   */
  public void multiplyByMInv(State state, Vector v, Vector MinvV) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByMInv(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(v), v, Vector.getCPtr(MinvV), MinvV);
  }

  /**
   *  This operator explicitly calculates the n X n mass matrix M. Note that this<br>
   * is inherently an O(n^2) operation since the mass matrix has n^2 elements <br>
   * (although only n(n+1)/2 are unique due to symmetry). <em>DO NOT USE THIS CALL <br>
   * DURING NORMAL DYNAMICS</em>. To do so would change an O(n) operation into an <br>
   * O(n^2) one. Instead, see if you can accomplish what you need with O(n) operators<br>
   * like multiplyByM() which calculates the matrix-vector product M*v in O(n)<br>
   * without explicitly forming M. Also, don't invert this matrix numerically to get<br>
   * M^-1. Instead, call the method calcMInv() which can produce M^-1 directly.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> </p><br>
   * <br>
   * @see multiplyByM(), calcMInv() *
   */
  public void calcM(State arg0, Matrix M) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcM(swigCPtr, this, State.getCPtr(arg0), arg0, Matrix.getCPtr(M), M);
  }

  /**
   *  This operator explicitly calculates the inverse of the part of the system<br>
   * mobility-space mass matrix corresponding to free (non-prescribed)<br>
   * mobilities. The returned matrix is always n X n, but rows and columns <br>
   * corresponding to prescribed mobilities are zero. This is an O(n^2) operation, <br>
   * which is of course within a constant factor of optimal for returning a matrix <br>
   * with n^2 elements explicitly. (There are actually only n(n+1)/2 unique elements<br>
   * since the matrix is symmetric.) <em>DO NOT USE THIS CALL DURING NORMAL <br>
   * DYNAMICS</em>. To do so would change an O(n) operation into an O(n^2) one. <br>
   * Instead, see if you can accomplish what you need with O(n) operators like <br>
   * multiplyByMInv() which calculates the matrix-vector product M^-1*v in O(n) <br>
   * without explicitly forming M or M^-1. If you need M explicitly, you can get it<br>
   * with the calcM() method.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> (articulated body inertias realized first if necessary)</p><br>
   * <br>
   * @see multiplyByMInv(), calcM() *
   */
  public void calcMInv(State arg0, Matrix MInv) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcMInv(swigCPtr, this, State.getCPtr(arg0), arg0, Matrix.getCPtr(MInv), MInv);
  }

  /**
   *  This operator calculates in O(m*n) time the m X m "projected inverse mass <br>
   * matrix" or "constraint compliance matrix" W=G*M^-1*~G, where G (mXn) is the <br>
   * acceleration-level constraint Jacobian mapped to generalized coordinates,<br>
   * and M (nXn) is the unconstrained system mass matrix. In case there is prescribed<br>
   * motion specified with Motion objects or mobilizer locking, M^-1 here is really<br>
   * M_ff^-1, that is, it is restricted to the free (non-prescribed) mobilities, but <br>
   * scattered into a full n X n matrix (conceptually). See multiplyByMInv() and <br>
   * calcMInv() for more information.<br>
   * <br>
   * W is the projection of the inverse mass matrix into the constraint coordinate<br>
   * space (that is, the vector space of the multipliers lambda). It can be used to <br>
   * solve for the constraint forces that will eliminate a given constraint <br>
   * acceleration error:<br>
   * <pre><br>
   *     (1)     W * lambda = aerr<br>
   *     (2)     aerr = G*udot - b(t,q,u)<br>
   * </pre><br>
   * where udot is an unconstrained generalized acceleration. Note that you can<br>
   * view equation (1) as a dynamic system in a reduced set of m generalized<br>
   * coordinates, with the caveat that W may be singular.<br>
   * <br>
   * In general W is singular and does not uniquely determine lambda. Simbody <br>
   * normally calculates a least squares solution for lambda so that loads are <br>
   * distributed among redundant constraints. <br>
   * <br>
   * Note: If you just need to multiply W by a vector or matrix, you do not need<br>
   * to form W explicitly. Instead you can use the method described in the <br>
   * Implementation section to produce a W*v product in the O(n) time it takes to <br>
   * compute a single column of W.<br>
   * <br>
   * <h3>Implementation</h3><br>
   * We are able to form W without forming G or M^-1 and without performing any <br>
   * matrix-matrix multiplies. Instead, W is calculated using m applications of <br>
   * O(n) operators:<br>
   *     - multiplyByGTranspose() by a unit vector to form a column of ~G<br>
   *     - multiplyByMInv() to form a column of M^-1 ~G<br>
   *     - multiplyByG() to form a column of W<br>
   * <br>
   * Even if G and M^-1 were already available, computing W by matrix multiplication<br>
   * would cost O(m^2*n + m*n^2) time and O(m*n) intermediate storage. Here we do <br>
   * it in O(m*n) time with O(n) intermediate storage, which is a <i>lot</i> better.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> (articulated body inertias realized first if necessary)</p><br>
   * <br>
   * @see multiplyByG(), calcG(), multiplyByGTranspose(), calcGTranspose()@see multiplyByMInv(), calcMInv() *
   */
  public void calcProjectedMInv(State s, Matrix GMInvGt) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcProjectedMInv(swigCPtr, this, State.getCPtr(s), s, Matrix.getCPtr(GMInvGt), GMInvGt);
  }

  /**
   *  Given a set of desired constraint-space speed changes, calculate the<br>
   * corresponding constraint-space impulses that would cause those changes. Here we <br>
   * are solving the equation<br>
   * <pre><br>
   *     W * impulse = deltaV<br>
   * </pre><br>
   * for <i>impulse</i>, where W=G*M^-1*~G is the "projected inverse mass matrix" as <br>
   * described for calcProjectedMInv(). In general W is singular due to constraint<br>
   * redundancies, so the solution for <i>impulse</i> is not unique. Simbody handles <br>
   * redundant constraints by finding least squares solutions, and this operator <br>
   * method duplicates the method Simbody uses for determining the rank and <br>
   * performing the factorization of W. <br>
   * <br>
   * @param state<br>
   *     The State whose generalized coordinates and speeds define the matrix W.<br>
   *     Must already be realized to Velocity stage.<br>
   * @param deltaV<br>
   *     The set of desired velocity changes to be produced by the impulse, in <br>
   *     constraint space. These will consist of observed velocity constraint <br>
   *     violations (-verr) and constraint violations that would be generated by<br>
   *     impulsive applied forces (-G*M^-1*f).<br>
   * @param impulse<br>
   *     The set of constraint multiplier-space impulses that will produce the<br>
   *     desired velocity changes without violating the constraints.<br>
   * <br>
   * To convert these constraint-space impulses into updates to the mobility-space<br>
   * generalized speeds u, use code like this:<br>
   * {@code 
      const SimbodyMatterSubsystem& matter=...;
      Vector deltaV=...;  // constraint space speed change desired; length m
      Vector impulse;     // constraint space impulses; length m
      solveForConstraintImpulses(state, deltaV, impulse);
      Vector f;           // mobility space impulses; length n
      Vector du;          // change to generalized speeds u; length n
      matter.multiplyByGTranspose(s,impulse,f);
      matter.multiplyByMInv(s,f,du);
      state.updU() += du; // update generalized speeds
  } <br>
   * <br>
   * Note that the length of the constraint-space vectors is m=mp+mv+ma, the total <br>
   * number of acceleration-level constraints including the second time derivatives<br>
   * of the position (holonomic) constraints, the first time derivatives of the <br>
   * velocity (nonholonomic) constraints, and the acceleration-only constraints. <br>
   * @see calcProjectedMInv(), multiplyByGTranspose(), multiplyByMInv() *
   */
  public void solveForConstraintImpulses(State state, Vector deltaV, Vector impulse) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_solveForConstraintImpulses(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(deltaV), deltaV, Vector.getCPtr(impulse), impulse);
  }

  /**
   *  Returns Gulike = G*ulike, the product of the mXn acceleration <br>
   * constraint Jacobian G and a "u-like" (mobility space) vector of length n. <br>
   * m is the number of active acceleration-level constraint equations, n is the <br>
   * number of mobilities. This is an O(m+n) operation.<br>
   * <br>
   * If you are going to call this method repeatedly at the same time, positions and<br>
   * velocities, you should precalculate the bias term once and supply it to the<br>
   * alternate signature of this method. See the Implementation section for more <br>
   * information.<br>
   * <br>
   * <p alt="Implementation"><br>
   * This is accomplished by treating the input vector <i>ulike</i> as though it were<br>
   * a set of generalized accelerations (for nonholonomic and acceleration-only<br>
   * constraints) or generalized speeds (for holonomic constraints). These are <br>
   * mapped to body accelerations (or velocities) in O(n) time. See<br>
   * calcBodyAccelerationFromUDot() for more information (converting from <br>
   * generalized speeds to velocities is just multiplying by the System Jacobian).<br>
   * The method calcBiasForMultiplyByG() is used to determine the state-dependent<br>
   * term of the constraint error equations. Then a second call is made to<br>
   * evaluate the bias term aerr(t,q,u;0)=-b(t,q,u). We then calculate <br>
   * Gulike = aerr(t,q,u;ulike)-aerr(t,q,u;0) in O(m) time.<br>
   * </p>@see calcBiasForMultiplyByG() *
   */
  public void multiplyByG(State state, Vector ulike, Vector Gulike) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByG__SWIG_0(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(ulike), ulike, Vector.getCPtr(Gulike), Gulike);
  }

  /**
   *  Multiply Gulike=G*ulike using the supplied precalculated bias vector to <br>
   * improve performance (approximately 2X) over the other signature. <br>
   * @see calcBiasForMultiplyByG() *
   */
  public void multiplyByG(State state, Vector ulike, Vector bias, Vector Gulike) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByG__SWIG_1(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(ulike), ulike, Vector.getCPtr(bias), bias, Vector.getCPtr(Gulike), Gulike);
  }

  /**
   *  Calculate the bias vector needed for the higher-performance signature of<br>
   * the multiplyByG() method above. <br>
   * <br>
   * @param state<br>
   *     Provides time t, positions q, and speeds u; must be realized through<br>
   *     Velocity stage so that all body spatial velocities are known.<br>
   * @param bias<br>
   *     This is the bias vector for use in repeated calls to multiplyByG(). It<br>
   *     will be resized if necessary to length m=mp+mv+ma, the total number of <br>
   *     active acceleration-level constraint equations. <br>
   * <br>
   * <p alt="Implementation"><br>
   * This method uses either velocity- or acceleration- level constraint error<br>
   * functions with zero input to determine the bias term for use in <br>
   * multiplyByG(). Body quantities and generalized quantities are supplied to each <br>
   * of the m active constraints' (constant time) error methods to calculate<br>
   * <pre><br>
   *    pverr(t,q,u;ulike)=G*ulike - c(t,q)    (holonomic) <br>
   * or aerr(t,q,u;ulike)=G*ulike - b(t,q,u)   (nonholonomic or acceleration-only)<br>
   * </pre><br>
   * with ulike=0, giving the bias term in O(m) time. </p><br>
   * <br>
   * If you want the acceleration-level bias terms b for all the constraints, even<br>
   * if they are holonomic, use calcBiasForAccelerationConstraints(). *
   */
  public void calcBiasForMultiplyByG(State state, Vector bias) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForMultiplyByG(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(bias), bias);
  }

  /**
   *  This O(m*n) operator explicitly calculates the m X n acceleration-level <br>
   * constraint Jacobian G which appears in the system equations of <br>
   * motion. Consider using the multiplyByG() method instead of this one, <br>
   * which forms the matrix-vector product G*v in O(m+n) time without explicitly <br>
   * forming G.<br>
   * <br>
   * <p alt="Implementation"><br>
   * This method generates G columnwise using repeated calls to multiplyByG(), <br>
   * which makes use of the constraint error methods to perform a G*v product<br>
   * in O(m+n) time. To within numerical error, for non-working constraints<br>
   * this should be identical to the transpose of the matrix returned by calcGt() <br>
   * which uses the constraint force methods instead. <br>
   * </p>@see multiplyByG(), calcGt(), calcPq() *
   */
  public void calcG(State state, Matrix G) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcG(swigCPtr, this, State.getCPtr(state), state, Matrix.getCPtr(G), G);
  }

  /**
   *  Calculate the acceleration constraint bias vector, that is, the terms in<br>
   * the acceleration constraints that are independent of the accelerations.<br>
   * <br>
   * @param state<br>
   *     Provides time t, positions q, and speeds u; must be realized through<br>
   *     Velocity stage so that all body spatial velocities are known.<br>
   * @param bias<br>
   *     This is the bias vector for all the acceleration constraint equations<br>
   *     together. It will be resized if necessary to length m=mp+mv+ma, the total <br>
   *     number of active acceleration-level constraint equations. <br>
   * <br>
   * <p alt="Implementation"><br>
   * We have constant-time constraint acceleration error methods <br>
   * <pre>   <br>
   * paerr(t,q,u;udot)=P*udot - b_p(t,q,u) <br>
   * vaerr(t,q,u;udot)=V*udot - b_v(t,q,u) <br>
   *  aerr(t,q,u;udot)=A*udot - b_a(t,q,u)   <br>
   * </pre><br>
   * that together define the acceleration constraint equation G*udot-b=0<br>
   * where G=[P;V;A] and b=[b_p b_v b_a]. There is one of these error functions <br>
   * for each %Constraint, with paerr() the twice-differentiated position (holonomic)<br>
   * constraints, vaerr() the once-differentiated velocity (nonholonomic)<br>
   * constraints, and aerr() the acceleration-only constraints. This method <br>
   * sets <code>udot</code> = 0 and invokes each of those methods to obtain <br>
   * bias = -[b_p b_v b_a].</p><br>
   * <br>
   * <h3>Performance note</h3><br>
   * The actual acceleration constraint functions require both udot and body <br>
   * accelerations for the constrained bodies; even with udot==0 body accelerations <br>
   * may have a non-zero velocity-dependent component (the coriolis accelerations). <br>
   * Those are already available in the state, but only as accelerations in Ground. <br>
   * For constraints that have a non-Ground Ancestor, we have to convert the <br>
   * accelerations to A at a cost of 105 flops/constrained body. *
   */
  public void calcBiasForAccelerationConstraints(State state, Vector bias) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForAccelerationConstraints(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(bias), bias);
  }

  /**
   *  Returns f = ~G*lambda, the product of the n X m transpose of the <br>
   * acceleration constraint Jacobian G (=[P;V;A]) and a multiplier-like vector <br>
   * <i>lambda</i> of length m, returning a generalized-force like quantity <i>f</i> of<br>
   * length n. m=mp+mv+ma is the total number of active constraint equations, <br>
   * n (==nu) is the number of mobilities (generalized speeds u). If lambda is a set<br>
   * of constraint multipliers, then f=~G*lambda is the set of forces generated by<br>
   * the constraints, mapped into generalized forces. This is an O(m+n) operation.<br>
   * <br>
   * Because the velocity (non-holonomic) or acceleration-only constraint Jacobians<br>
   * V and A can have velocity dependence, the <i>state</i> supplied here must generally<br>
   * be realized through Velocity stage. If the system has only position (holonomic)<br>
   * constraints then the <i>state</i> need be realized only through Position stage.<br>
   * <br>
   * @param state<br>
   *     A State that has been realized through Velocity stage (or Position stage<br>
   *     if the system has no velocity-dependent constraint Jacobians).<br>
   *     Configuration and velocities if needed are taken from <i>state</i>.<br>
   * @param lambda<br>
   *     A multiplier-like vector to be multiplied by ~G. Its length must be the<br>
   *     same as the total number of active constraint equations m.<br>
   * @param f<br>
   *     This is the generalized force-like output. It will be resized if necessary<br>
   *     to length equal to the number of mobilities (generalized speeds) n (==nu). <br>
   * <br>
   * <p alt="Implementation"><br>
   * This is accomplished by treating the input vector <i>lambda</i> as though it were<br>
   * a set of Lagrange multipliers, then calling each of the active Constraints' <br>
   * (constant time) force generation methods, providing the appropriate subset of <br>
   * the multipliers each time. That gives body forces F0 and mobility forces f0 in <br>
   * O(m) time. We then use the equivalent of multiplyBySystemJacobianTranspose() <br>
   * to convert the returned body spatial forces to generalized forces in O(n) <br>
   * time, and finally return the generalized force-like result f = ~J*F0 + f0. <br>
   * </p>@see multiplyByG(), multiplyBySystemJacobianTranspose() *
   */
  public void multiplyByGTranspose(State state, Vector lambda, Vector f) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByGTranspose(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(lambda), lambda, Vector.getCPtr(f), f);
  }

  /**
   *  This O(nm) operator explicitly calculates the n X m transpose of the <br>
   * acceleration-level constraint Jacobian G = [P;V;A] which appears in the system <br>
   * equations of motion. This method generates ~G columnwise use the constraint <br>
   * force generating methods which map constraint multipliers to constraint forces.<br>
   * To within numerical error, this should be identical to the transpose of<br>
   * the matrix returned by calcG() which uses a different method. Consider using <br>
   * the multiplyByGTranspose() method instead of this one, which forms the <br>
   * matrix-vector product ~G*v in O(n) time without explicitly forming ~G.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code><br>
   * </p>@see calcG(), multiplyByGTranspose() *
   */
  public void calcGTranspose(State arg0, Matrix Gt) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcGTranspose(swigCPtr, this, State.getCPtr(arg0), arg0, Matrix.getCPtr(Gt), Gt);
  }

  /**
   *  Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq <br>
   * position (holonomic) constraint Jacobian and <i>qlike</i> is a "q-like" <br>
   * (generalized coordinate space) vector of length nq. Here mp is the number of <br>
   * active position-level constraint equations in this system.<br>
   * <br>
   * If you are going to call this method repeatedly at the same time t and <br>
   * configuration q and want maximum efficiency, you can gain a factor of almost<br>
   * 2X by precalculating a bias term once using calcBiasForMultiplyByPq() and <br>
   * supplying it to the alternate signature of this method. See the Theory<br>
   * section below for an explanation of the bias term.<br>
   * <br>
   * <br>
   * <br>
   * <h3>Theory</h3><br>
   * Simbody's position (holonomic) constraints are defined by the constraint <br>
   * error equation <br>
   * <pre><br>
   *     (1)    perr(t;q) = p(t,q)<br>
   * </pre><br>
   * where we try to maintain perr=0 at all times. We also have available time <br>
   * derivatives of equation (1); the first time derivative is relevant here:<br>
   * <pre><br>
   *     (2)    pverr(t,q;qdot) = dperr/dt = Pq * qdot + Pt<br>
   * </pre><br>
   * where Pq=Dperr/Dq and Pt=Dperr/Dt (capital "D" means partial derivative).<br>
   * Pt=Pt(t,q) is called the "bias" term. (Note that because u=N^-1*qdot we also<br>
   * have Pq=P*N^-1, where P=Dpverr/Du is the very useful mobility-space holonomic <br>
   * constraint Jacobian.) Eq. (2) can be used to perform efficient multiplication <br>
   * by Pq, since it can be used to calculate Pq*qlike+Pt, and a second evaluation <br>
   * at qlike=0 can be used to calculate the unwanted bias term for removal: <br>
   * <pre><br>
   *     (3)    Pq*qlike = pverr(t,q;qlike) - pverr(t,q;0)  <br>
   * </pre><br>
   * Despite appearances, eq. (2) calculates its result in constant time per<br>
   * constraint equation, for a total cost that is O(n) or more strictly O(mp+nq).<br>
   * The matrix Pq is never actually formed; instead the matrix-vector product<br>
   * is calculated directly.<br>
   * <br>
   * <h3>Implementation</h3><br>
   * We treat the input vector <i>qlike</i> as though it were a set of generalized <br>
   * coordinate derivatives qdot. These are mapped to body velocities V in O(n) <br>
   * time, using V=Jq*qdot, where Jq is the coordinate space system Jacobian <br>
   * (partial velocity matrix), with Jq=J*N^-1. Then the body velocities and qdots <br>
   * are supplied to each of the mp active position constraints' (constant time) <br>
   * velocity error methods to get pverr(t,q;qlike)=Pq*qlike-Pt in O(n) time. A <br>
   * second call is made to evaluate the bias term pverr(t,q;0)=-Pt. We then <br>
   * calculate the result <i>PqXqlike</i> = pverr(t,q;qlike)-pverr(t,q;0) in O(n) time<br>
   * using equation (3). <br>
   * <br>
   * @see calcBiasForMultiplyByPq() *
   */
  public void multiplyByPq(State state, Vector qlike, Vector PqXqlike) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByPq__SWIG_0(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(qlike), qlike, Vector.getCPtr(PqXqlike), PqXqlike);
  }

  /**
   *  Multiply Pq*qlike using the supplied precalculated bias vector to <br>
   * improve performance (approximately 2X) over the other signature. <br>
   * @see calcBiasForMultiplyByPq() *
   */
  public void multiplyByPq(State state, Vector qlike, Vector biasp, Vector PqXqlike) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByPq__SWIG_1(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(qlike), qlike, Vector.getCPtr(biasp), biasp, Vector.getCPtr(PqXqlike), PqXqlike);
  }

  /**
   *  Calculate the bias vector needed for the higher-performance signature of<br>
   * the multiplyByPq() method above. <br>
   * <br>
   * @param state<br>
   *     Provides time t, and positions q; must be realized through<br>
   *     Position stage so that all body spatial poses are known.<br>
   * @param biasp<br>
   *     This is the bias vector for use in repeated calls to multiplyByPq(). It<br>
   *     will be resized if necessary to length mp, the total number of <br>
   *     active position-level (holonomic) constraint equations. <br>
   * <br>
   * <br>
   * <br>
   * See multiplyByPq() for theory and implementation; this method is just <br>
   * performing the qlike=0 case described there for calculating the bias term Pt.
   */
  public void calcBiasForMultiplyByPq(State state, Vector biasp) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBiasForMultiplyByPq(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(biasp), biasp);
  }

  /**
   *  This O(m*n) operator explicitly calculates the mp X nq position-level <br>
   * (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the<br>
   * position error equations with respect to q. Consider using the multiplyByPq() <br>
   * method instead of this one, which forms the matrix-vector product Pq*v in <br>
   * O(m+n) time without explicitly forming Pq.<br>
   * <br>
   * Note that quaternion normalization constraints are <i>not</i> included in mp; we<br>
   * do not consider those holonomic constraints.<br>
   * <br>
   * <br>
   * <br>
   * @param state<br>
   *     A State realized through Position stage so that time and the pose <br>
   *     (configuration) of each body is known.<br>
   * @param Pq<br>
   *     The position constraint Jacobian Dperr/Dq. This will be resized to<br>
   *     mp X nq if necessary.<br>
   * <br>
   * <p alt="Implementation"><br>
   * This method generates Pq columnwise using repeated calls to multiplyByPq(), <br>
   * which makes use of the position constraint velocity-level error methods to <br>
   * perrform a Pq*v product in O(m+n) time. See multiplyByPq() for a more <br>
   * detailed explanation. If Pq's columns are in contiguous memory we'll work<br>
   * in place, otherwise columns are generated into a contiguous temporary and<br>
   * then copied into Pq.</p><br>
   * <br>
   * @see multiplyByPq() *
   */
  public void calcPq(State state, Matrix Pq) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcPq(swigCPtr, this, State.getCPtr(state), state, Matrix.getCPtr(Pq), Pq);
  }

  /**
   *  Returns f = ~Pq*lambdap, the product of the n X mp transpose of the <br>
   * position (holonomic) constraint Jacobian Pq (=P*N^-1) and a multiplier-like <br>
   * vector <i>lambdap</i> of length mp, returning a generalized-force like quantity <br>
   * <i>f</i> of length n. mp is the number of active position constraint equations, <br>
   * n (==nu) is the number of mobilities (generalized speeds u). If lambdap is a set<br>
   * of mp constraint multipliers, then f=~G*lambdap is the set of forces generated <br>
   * by the position constraints, mapped into generalized forces. This is an <br>
   * O(mp+n) operation.<br>
   * <br>
   * A holonomic constraint Jacobian cannot have a velocity dependence, so the<br>
   * <i>state</i> need be realized only to Position stage here.<br>
   * <br>
   * @param state<br>
   *     A State that has been realized through Position stage. Time and<br>
   *     configuration are taken from <i>state</i>.<br>
   * @param lambdap<br>
   *     A multiplier-like vector to be multiplied by ~Pq. Its length must be the<br>
   *     same as the number of active position constraint equations mp.<br>
   * @param f<br>
   *     This is the generalized force-like output. It will be resized if necessary<br>
   *     to length equal to the number of mobilities (generalized speeds) n (==nu). <br>
   * <br>
   * <p alt="Implementation"><br>
   * This is accomplished by treating the input vector <i>lambdap</i> as though it were<br>
   * a set of Lagrange multipliers, then calling each of the active holonomic<br>
   * Constraints' (constant time) force generation methods, providing the <br>
   * appropriate subset of the multipliers each time. That gives body forces F0 and <br>
   * mobility forces f0 in O(mp) time. We then use the equivalent of <br>
   * multiplyBySystemJacobianTranspose() to convert the returned body spatial <br>
   * forces to generalized forces in O(n) time, and finally return the generalized <br>
   * force-like result f = ~J*F0 + f0. <br>
   * </p>@see multiplyByPq(), multiplyBySystemJacobianTranspose() *
   */
  public void multiplyByPqTranspose(State state, Vector lambdap, Vector f) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByPqTranspose(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(lambdap), lambdap, Vector.getCPtr(f), f);
  }

  /**
   *  This O(m*n) operator explicitly calculates the nq X mp transpose of <br>
   * the position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial <br>
   * derivative of the position error equations with respect to q. Consider using <br>
   * the multiplyByPqTranspose() method instead of this one, which forms the <br>
   * matrix-vector product ~Pq*v in O(m+n) time without explicitly forming ~Pq.<br>
   * <br>
   * Note that quaternion normalization constraints are <i>not</i> included in mp; we<br>
   * do not consider those holonomic constraints.<br>
   * <br>
   * <br>
   * <br>
   * @param state<br>
   *     A State realized through Position stage so that time and the pose <br>
   *     (configuration) of each body is known.<br>
   * @param Pqt<br>
   *     The transposed position constraint Jacobian ~Pq=(Dperr/Dq)^T. This will be<br>
   *     resized to nq X mp if necessary.<br>
   * <br>
   * <p alt="Implementation"><br>
   * This method generates <i>Pqt</i> columnwise using repeated calls to <br>
   * multiplyByPqTranspose(), which makes use of the position constraint force<br>
   * generating methods to perform a ~Pq*v product in O(m+n) time. See <br>
   * multiplyByPqTranspose() for a more detailed explanation. If Pqt's columns <br>
   * are in contiguous memory we'll work in place, otherwise columns are generated <br>
   * into a contiguous temporary and then copied into Pqt.</p><br>
   * <br>
   * @see multiplyByPqTranspose() *
   */
  public void calcPqTranspose(State state, Matrix Pqt) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcPqTranspose(swigCPtr, this, State.getCPtr(state), state, Matrix.getCPtr(Pqt), Pqt);
  }

  /**
   *  Returns the mp X nu matrix P which is the Jacobian of the first time<br>
   * derivative of the holonomic (position) constraint errors with respect to the <br>
   * generalized speeds u; that is, P = partial( dperr/dt )/partial(u). Here mp is <br>
   * the number of holonomic constraint equations (not including quaternion <br>
   * normalization constraints) and nu is the total number of generalized speeds as <br>
   * found in the supplied State. P is resized if necessary; an error will be thrown<br>
   * if the Matrix is not the right size and not resizeable.<br>
   * <br>
   * <p alt="Complexity:"><br>
   * Calculates the m X n matrix in O(m*n) time, which is good if you really need<br>
   * this matrix. However, in many cases what is really needed is the product<br>
   * of this matrix with a vector which can be done in O(n) time; consider whether<br>
   * you really need the whole matrix explicitly.<br>
   * </p><p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public void calcP(State state, Matrix P) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcP(swigCPtr, this, State.getCPtr(state), state, Matrix.getCPtr(P), P);
  }

  /**
   *  Returns the nu X mp matrix ~P - see calcP() for a description. <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public void calcPt(State state, Matrix Pt) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcPt(swigCPtr, this, State.getCPtr(state), state, Matrix.getCPtr(Pt), Pt);
  }

  /**
   *  Calculate out_q = N(q)*in_u (like qdot=N*u) or out_u = ~N*in_q. Note that <br>
   * one of "in" and "out" is always "q-like" while the other is "u-like", but which<br>
   * is which changes if the matrix is transposed. Note that the transposed <br>
   * operation here is the same as multiplying by N on the right, with the Vectors <br>
   * viewed as RowVectors instead. This is an O(n) operator since N is block <br>
   * diagonal.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public void multiplyByN(State s, boolean transpose, Vector in, Vector out) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByN(swigCPtr, this, State.getCPtr(s), s, transpose, Vector.getCPtr(in), in, Vector.getCPtr(out), out);
  }

  /**
   *  Calculate out_u = NInv(q)*in_q (like u=NInv*qdot) or out_q = ~NInv*in_u. <br>
   * Note that one of "in" and "out" is always "q-like" while the other is "u-like",<br>
   * but which is which changes if the matrix is transposed. Note that the <br>
   * transposed operation here is the same as multiplying by NInv on the right, <br>
   * with the Vectors viewed as RowVectors instead. This is an O(N) operator since <br>
   * NInv is block diagonal. The configuration q is taken from the supplied state.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public void multiplyByNInv(State s, boolean transpose, Vector in, Vector out) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByNInv(swigCPtr, this, State.getCPtr(s), s, transpose, Vector.getCPtr(in), in, Vector.getCPtr(out), out);
  }

  /**
   *  Calculate out_q = NDot(q,u)*in_u or out_u = ~NDot(q,u)*in_q. This is used,<br>
   * for example, as part of the conversion between udot and qdotdot. Note that one<br>
   * of "in" and "out" is always "q-like" while the other is "u-like", but which is<br>
   * which changes if the matrix is transposed. Note that the transposed operation <br>
   * here is the same as multiplying by NDot on the right, with the Vectors viewed<br>
   * as RowVectors instead. This is an O(N) operator since NDot is block diagonal.<br>
   * Configuration q and generalized speeds u are taken from the supplied state.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> *</p>
   */
  public void multiplyByNDot(State s, boolean transpose, Vector in, Vector out) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_multiplyByNDot(swigCPtr, this, State.getCPtr(s), s, transpose, Vector.getCPtr(in), in, Vector.getCPtr(out), out);
  }

  /**
   * ** This is the primary forward dynamics operator. It takes a state which<br>
   * has been realized to the Dynamics stage, a complete set of forces to apply,<br>
   * and returns the accelerations that result. Only the forces supplied here,<br>
   * and those calculated internally from prescribed motion, constraints, and<br>
   * centrifugal effects, affect the results. Acceleration constraints are <br>
   * always satisfied on return as long as the constraints are consistent. <br>
   * If the position and velocity constraints aren't already satisified in the <br>
   * State, results are harder to interpret physically, but they will still be <br>
   * calculated and the acceleration constraints will still be satisfied. No <br>
   * attempt will be made to satisfy position and velocity constraints, or to <br>
   * set prescribed positions and velocities, nor even to check whether these <br>
   * are satisfied; position and velocity constraint and prescribed positions <br>
   * and velocities are simply irrelevant here.<br>
   * <br>
   * Given applied forces f_applied, this operator solves this set of equations:<br>
   * <pre><br>
   *      M udot + tau + ~G lambda + f_inertial = f_applied       (1)<br>
   *                                   G udot   = b               (2)<br>
   *                                     udot_p = udot_p(t,q,u,z) (3)<br>
   * </pre><br>
   * where udot={udot_f,udot_p}, tau={0,tau_p}. The unknowns are: the free <br>
   * generalized accelerations udot_f, the constraint multipliers lambda, and the <br>
   * prescribed motion generalized forces tau_p. A subset udot_p of udot may have <br>
   * been prescribed as a known function of state via Motion objects or locks <br>
   * associated with the mobilized bodies. On return all the entries in udot will <br>
   * have been set to their calculated or prescribed values, and body spatial <br>
   * accelerations A_GB (that is, measured and expressed in Ground) are also <br>
   * returned. Lambda and tau_p are necessarily calculated but are not returned here.<br>
   * <br>
   * f_applied is the set of generalized (mobility) forces equivalent to the <br>
   * <i>appliedMobilityForces</i> and <i>appliedBodyForces</i> arguments supplied here. <br>
   * That is,<br>
   * <pre><br>
   *     f_applied = appliedMobilityForces + ~J * appliedBodyForces<br>
   * </pre> <br>
   * where J is the system Jacobian mapping between spatial and generalized<br>
   * coordinates. Typically these forces will have been calculated as a function of <br>
   * state so we will have f_applied(t,q,u,z).<br>
   * <br>
   * M(t,q), G(t,q,u), and b(t,q,u) are defined by the mobilized bodies and <br>
   * constraints present in the system. f_inertial(q,u) includes the <br>
   * velocity-dependent gyroscopic and coriolis forces due to rigid body <br>
   * rotations and is extracted internally from the already-realized state. <br>
   * <br>
   * Note that this method does not allow you to specify your own prescribed udots; <br>
   * those are calculated from the mobilizers' state-dependent Motion specifications<br>
   * (or are zero due to mobilizer locks) that are already part of the system.<br>
   * <br>
   * This is an O(n*m + m^3) operator where n is the number of generalized speeds<br>
   * and m the number of constraint equations (mobilities with prescribed motion are<br>
   * counted in n, not m).<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Dynamics</code> (articulated body inertia will be realized if needed) *</p>
   */
  public void calcAcceleration(State state, Vector appliedMobilityForces, VectorOfSpatialVec appliedBodyForces, Vector udot, VectorOfSpatialVec A_GB) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcAcceleration(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(appliedMobilityForces), appliedMobilityForces, VectorOfSpatialVec.getCPtr(appliedBodyForces), appliedBodyForces, Vector.getCPtr(udot), udot, VectorOfSpatialVec.getCPtr(A_GB), A_GB);
  }

  /**
   *  This operator is similar to calcAcceleration() but ignores the effects of<br>
   * acceleration constraints although it obeys prescribed accelerations. The <br>
   * supplied forces, prescribed motion forces, and velocity-induced centrifugal <br>
   * and gyroscopic effects are properly accounted for, but any forces that would <br>
   * have resulted from enforcing the constraints are not present. This operator <br>
   * solves the equations<br>
   * <pre><br>
   *             M udot + tau + f_inertial = f_applied           (1)<br>
   *                                udot_p = udot_p(t,q,u,z)     (2)<br>
   * </pre><br>
   * where udot={udot_f,udot_p}, tau={0,tau_p}. The unknowns are the free <br>
   * generalized accelerations udot_f and the prescribed motion generalized forces<br>
   * tau_p. f_inertial contains the velocity-dependent gyroscopic and coriolis<br>
   * forces due to rigid body rotations. No constraint forces are included.<br>
   * <br>
   * On return all the entries in udot will have been set to their calculated or <br>
   * prescribed values, and body spatial accelerations A_GB (that is, measured and <br>
   * expressed in Ground) are also returned. tau_p is not returned.<br>
   * <br>
   * This is an O(n) operator.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Dynamics</code> (articulated body inertia will be realized if needed) *</p>
   */
  public void calcAccelerationIgnoringConstraints(State state, Vector appliedMobilityForces, VectorOfSpatialVec appliedBodyForces, Vector udot, VectorOfSpatialVec A_GB) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcAccelerationIgnoringConstraints(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(appliedMobilityForces), appliedMobilityForces, VectorOfSpatialVec.getCPtr(appliedBodyForces), appliedBodyForces, Vector.getCPtr(udot), udot, VectorOfSpatialVec.getCPtr(A_GB), A_GB);
  }

  /**
   *  This is the inverse dynamics operator for the tree system; if there are<br>
   * any constraints or prescribed motion they are ignored. This method solves<br>
   * <pre><br>
   *      f_residual = M udot + f_inertial - f_applied<br>
   * </pre><br>
   * for f_residual in O(n) time, meaning that the mass matrix M is never formed. <br>
   * Inverse dynamics is considerably faster than forward dynamics, even though <br>
   * both are O(n) in Simbody.<br>
   * <br>
   * In the above equation we solve for the residual forces <code>f_residual</code> given<br>
   * desired accelerations and (optionally) a set of applied forces. Here <br>
   * <code>f_applied</code> is the mobility-space equivalent of all the applied forces<br>
   * (including mobility and body forces), <code>f_inertial</code> is the mobility-space<br>
   * equivalent of the velocity-dependent inertial forces due to rigid <br>
   * body rotations (coriolis and gyroscopic forces), and <code>udot</code> is the <br>
   * given set of values for the desired generalized accelerations. The returned <br>
   * <code>f_residual</code> is the additional generalized force (that is, mobility <br>
   * force) that would have to be applied at each mobility to give the desired<br>
   * <code>udot</code>. The inertial forces depend on the velocities <code>u</code> already realized <br>
   * in the State. Otherwise, only the explicitly-supplied forces affect the <br>
   * results of this operator; any forces that may be present elsewhere in <br>
   * the system are ignored.<br>
   * <br>
   * @param state<br>
   *      A State valid for the containing System, already realized to<br>
   *      Stage::Velocity.<br>
   * @param appliedMobilityForces<br>
   *      One scalar generalized force applied per mobility. Can be zero<br>
   *      length if there are no mobility forces; otherwise must have exactly <br>
   *      one entry per mobility in the matter subsystem.<br>
   * @param appliedBodyForces<br>
   *      One spatial force for each body. A spatial force is a force applied<br>
   *      to the body origin and a torque on the body, each expressed in the <br>
   *      Ground frame. Gravity, if present, is specified here as a body force.<br>
   *      The supplied Vector must be either zero length (interpreted as all-zero)<br>
   *      or have exactly one entry per body in the matter subsystem, starting with<br>
   *      Ground as body zero.<br>
   * @param knownUdot<br>
   *      These are the desired generalized accelerations, one per mobility. <br>
   *      If this is zero length it will be treated as all-zero; otherwise <br>
   *      it must have exactly one entry per mobility in the matter subsystem.<br>
   * @param residualMobilityForces<br>
   *      These are the residual generalized forces which, if added to the applied<br>
   *      forces, would produce the given <i>knownUdot</i> in forward dynamics (assuming<br>
   *      the system is unconstrained). This will be resized if necessary to have <br>
   *      length nu; that is, one scalar entry per mobility. You can view this as a <br>
   *      measure of how much the given <i>knownUdot</i> fails to satisfy the equations <br>
   *      of motion.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> </p><br>
   * <br>
   * @see calcResidualForce(), multiplyByM()@see calcAcceleration(), calcAccelerationIgnoringConstraints() *
   */
  public void calcResidualForceIgnoringConstraints(State state, Vector appliedMobilityForces, VectorOfSpatialVec appliedBodyForces, Vector knownUdot, Vector residualMobilityForces) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcResidualForceIgnoringConstraints(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(appliedMobilityForces), appliedMobilityForces, VectorOfSpatialVec.getCPtr(appliedBodyForces), appliedBodyForces, Vector.getCPtr(knownUdot), knownUdot, Vector.getCPtr(residualMobilityForces), residualMobilityForces);
  }

  /**
   *  This is the inverse dynamics operator for when you know both the <br>
   * accelerations and Lagrange multipliers for a constrained system. Prescribed<br>
   * motion is ignored. Using position and velocity from the given state, a set of <br>
   * applied forces, and a known set of generalized accelerations udot and <br>
   * constraint multipliers lambda, it calculates the additional generalized forces<br>
   * that would be required to satisfy Newton's 2nd law, f=Ma. That is, this <br>
   * operator returns<br>
   * <pre><br>
   *     f_residual = M udot + ~G lambda + f_inertial - f_applied<br>
   * </pre><br>
   * where f_applied is the mobility-space equivalent to all the applied forces <br>
   * (including mobility and body forces), f_inertial is the mobility-space <br>
   * equivalent of the velocity-dependent inertial forces due to rigid body <br>
   * rotations (coriolis and gyroscopic forces), and the udots and lambdas are given<br>
   * values of the generalized accelerations and constraint multipliers, resp.<br>
   * <br>
   * Note that there is no requirement that the given udots satisfy the constraint<br>
   * equations; we simply solve the above equation for <code>f_residual</code>.<br>
   * <br>
   * The inertial forces depend on the velocities <code>u</code> already realized in the State.<br>
   * Otherwise, only the explicitly-supplied forces affect the results of this <br>
   * operator; any forces that may be defined elsewhere in the system are ignored <br>
   * here.<br>
   * <br>
   * @param state<br>
   *      A State valid for the containing System, already realized to<br>
   *      <code>Stage::Velocity</code>.<br>
   * @param appliedMobilityForces<br>
   *      One scalar generalized force applied per mobility. Can be zero<br>
   *      length if there are no mobility forces; otherwise must have exactly <br>
   *      one entry per mobility in the matter subsystem.<br>
   * @param appliedBodyForces<br>
   *      One spatial force for each body. A spatial force is a force applied<br>
   *      to the body origin and a torque on the body, each expressed in the <br>
   *      Ground frame. Gravity, if present, is specified here as a body force.<br>
   *      The supplied Vector must be either zero length (interpreted as all-zero)<br>
   *      or have exactly one entry per body in the matter subsystem, starting with<br>
   *      Ground as body zero.<br>
   * @param knownUdot<br>
   *      These are the specified generalized accelerations, one per mobility so<br>
   *      the length should be nu. If this is zero length it will be treated as <br>
   *      all-zero of length nu; otherwise it must have exactly one entry per <br>
   *      mobility in the matter subsystem.<br>
   * @param knownLambda<br>
   *      These are the specified Lagrange multipliers, one per constraint<br>
   *      equation. If this is zero length it will be treated as all-zero; otherwise <br>
   *      it must have exactly m entries, where m=mp+mv+ma is the total number of<br>
   *      position, velocity, and acceleration-only constraints. There are no<br>
   *      entries here corresponding to quaternion constraints, which do not <br>
   *      generate forces.<br>
   * @param residualMobilityForces<br>
   *      These are the residual generalized forces which, if added to the applied<br>
   *      forces along with the constraint forces ~G*lambda, would produce the <br>
   *      given <i>knownUdot</i> in unconstrained forward dynamics. This will be resized<br>
   *      if necessary to have length nu; that is, one scalar entry per mobility.<br>
   *      You can view this as a measure of how much the given udot and lambda fail<br>
   *      to satisfy the equations of motion.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> </p><br>
   * <br>
   * @see calcResidualForceIgnoringConstraints() *
   */
  public void calcResidualForce(State state, Vector appliedMobilityForces, VectorOfSpatialVec appliedBodyForces, Vector knownUdot, Vector knownLambda, Vector residualMobilityForces) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcResidualForce(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(appliedMobilityForces), appliedMobilityForces, VectorOfSpatialVec.getCPtr(appliedBodyForces), appliedBodyForces, Vector.getCPtr(knownUdot), knownUdot, Vector.getCPtr(knownLambda), knownLambda, Vector.getCPtr(residualMobilityForces), residualMobilityForces);
  }

  /**
   *  Given a complete set of n generalized accelerations udot, this kinematic <br>
   * operator calculates in O(n) time the resulting body accelerations, including <br>
   * velocity-dependent terms taken from the supplied <i>state</i>.<br>
   * <br>
   * @param state<br>
   *     The State from which position- and velocity- related terms are taken; <br>
   *     must already have been realized to Velocity stage.<br>
   * @param knownUDot<br>
   *     A complete set of generalized accelerations. Must have the same length <br>
   *     as the number of mobilities nu, or if length zero the udots will be taken <br>
   *     as all zero in which case only velocity-dependent (Coriolis) accelerations <br>
   *     will be returned in <i>A_GB</i>.<br>
   * @param A_GB<br>
   *     Spatial accelerations of all the body frames measured and expressed in<br>
   *     the Ground frame, resulting from supplied generalized accelerations <br>
   *     <i>knownUDot</i> and velocity-dependent acceleration terms taken from <br>
   *     <i>state</i>. This will be resized if necessary to the number of bodies <br>
   *     <em>including</em> Ground so that the returned array may be indexed by <br>
   *     MobilizedBodyIndex with A_GB[0]==0 always. The angular acceleration<br>
   *     vector for MobilizedBody i is A_GB[i][0]; linear acceleration of the<br>
   *     body's origin is A_GB[i][1].<br>
   * <br>
   * <p alt="Theory"><br>
   * The generalized speeds u and spatial velocities V are related by the system<br>
   * Jacobian J as V=J*u. Thus the spatial accelerations A=Vdot=J*udot+Jdot*u.</p><br>
   * <br>
   * <p alt="Implementation"><br>
   * The Coriolis accelerations Jdot*u are already available in a State realized<br>
   * to Velocity stage. The J*udot term is equivalent to an application of <br>
   * multiplyBySystemJacobian() to the <i>knownUdot</i> vector. The current <br>
   * implementation uses 12*nu + 18*nb flops to produce nb body accelerations.</p><br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> </p><br>
   * <br>
   * @see multiplyBySystemJacobian(), getTotalCoriolisAcceleration() *
   */
  public void calcBodyAccelerationFromUDot(State state, Vector knownUDot, VectorOfSpatialVec A_GB) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcBodyAccelerationFromUDot(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(knownUDot), knownUDot, VectorOfSpatialVec.getCPtr(A_GB), A_GB);
  }

  /**
   *  Treating all Constraints together, given a comprehensive set of m <br>
   * Lagrange multipliers <i>lambda</i>, generate the complete set of body spatial forces<br>
   * and mobility (generalized) forces applied by all the Constraints.<br>
   * <br>
   * Spatial forces are applied at each body's origin and the moment and force<br>
   * vectors therein are expressed in the Ground frame. Watch the <br>
   * sign -- normally constraint forces have opposite sign from applied forces, <br>
   * because our equations of motion are <br>
   *     <pre>   M udot + ~G lambda = f_applied  </pre><br>
   * If you want to take Simbody-calculated multipliers and use them to generate <br>
   * forces that look like applied forces, negate the multipliers in the argument<br>
   * passed to this call.<br>
   * <br>
   * State must be realized to Stage::Velocity to call this operator (although <br>
   * typically the multipliers are obtained by realizing to Stage::Acceleration).<br>
   * <br>
   * This is an O(m) operator. In particular it does <i>not</i> involve forming or<br>
   * multiplying by the constraint force matrix ~G. Instead, one constant-time call<br>
   * is made to each %Constraint's calcConstraintForce methods.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> *</p>
   */
  public void calcConstraintForcesFromMultipliers(State state, Vector multipliers, VectorOfSpatialVec bodyForcesInG, Vector mobilityForces) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcConstraintForcesFromMultipliers(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(multipliers), multipliers, VectorOfSpatialVec.getCPtr(bodyForcesInG), bodyForcesInG, Vector.getCPtr(mobilityForces), mobilityForces);
  }

  /**
   *  Calculate the mobilizer reaction force generated at each MobilizedBody,<br>
   * as felt at the mobilizer's outboard frame M, and expressed in Ground.<br>
   * <br>
   * @param state        <br>
   *     A State compatible with this System that has already been realized <br>
   *     to Stage::Acceleration.<br>
   * @param forcesAtMInG    <br>
   *     A Vector of spatial force vectors, indexed by MobilizedBodyIndex <br>
   *     (beginning with 0 for Ground), giving the reaction moment and force<br>
   *     applied by each body's unique inboard mobilizer to that body. The<br>
   *     force is returned as though it were applied at the origin of the <br>
   *     body's mobilizer frame M. The returned force is expressed in the<br>
   *     Ground frame. Applied mobility (generalized) forces are <i>included</i> in the<br>
   *     returned reaction forces.<br>
   * <br>
   * A simple way to think of the reaction force is to think of cutting the <br>
   * mobilizer, then imagine the force required to make the system move in <br>
   * the same manner as when the mobilizer was present. This is what the <br>
   * reaction forces accomplish. With that definition, mobility forces (that is,<br>
   * generalized forces as opposed to body forces) are <i>included</i> in the reactions.<br>
   * Some conventions do not include the mobility forces in the definition of a <br>
   * reaction force. We chose to include them since this preserves Newton's <br>
   * 3rd law of equal and opposite reactions between bodies. Ours is the same <br>
   * convention as used in SD/FAST.<br>
   * <br>
   * Note: You can think of the Ground body being welded to the universe at the<br>
   * Ground origin. The reactions reported for Ground are the ones that would <br>
   * occur in that Weld mobilizer if it were really present. That is, it includes<br>
   * the effects of all the base bodies on Ground.<br>
   * <br>
   * <h3>How to find the reaction felt by the parent body</h3><br>
   * <br>
   * A mobilizer connects a frame F fixed on the parent (inboard) body P to a<br>
   * frame M fixed on the child (outboard) body B. It exerts equal and opposite <br>
   * reaction forces on the two bodies, at a given location in space. This method <br>
   * reports the force on the child body, as though it were applied at the origin <br>
   * Mo of frame M, and expressed in the Ground frame. The force on the parent body<br>
   * <em>at Mo</em> is just the negative of the returned value. However, it is <br>
   * more likely that you would want it as felt <em>at Fo</em>, the origin of the<br>
   * F frame on the parent. Here is one way to calculate that from the returned<br>
   * quantities:<br>
   * {@code 
      matter.calcMobilizerReactionForces(state,forcesAtMInG); // This method.
      const int nb = matter.getNumBodies();
      Vector_<SpatialVec> forcesAtFInG(nb); // to hold the result
      forcesAtFInG[0] = -forcesAtMInG[0]; // Ground is "welded" at origin
      for (MobilizedBodyIndex i(1); i < nb; ++i) {
          const MobilizedBody& mobod  = matter.getMobilizedBody(i);
          const MobilizedBody& parent = mobod.getParentMobilizedBody();
  Want to shift reaction by p_MF, the vector from M to F across the
  mobilizer, and negate. Can get p_FM; must reexpress in G.
          const Vec3& p_FM = mobod.getMobilizerTransform(state).p();
          const Rotation& R_PF = mobod.getInboardFrame(state).R(); // In parent.
          const Rotation& R_GP = parent.getBodyTransform(state).R();
          Rotation R_GF   =   R_GP*R_PF;  // F frame orientation in Ground.
          Vec3     p_MF_G = -(R_GF*p_FM); // Re-express and negate shift vector. 
          forcesAtFInG[i] = -shiftForceBy(forcesAtMInG[i], p_MF_G);
      }
  }<br>
   * <br>
   * <h3>Implementation</h3><br>
   * This method combines already-calculated quantities to calculate the reactions.<br>
   * See Abhi Jain's 2011 book "Robot and Multibody Dynamics", Eq. 7.34 page 128: <br>
   * <pre>   F_reaction = PPlus*APlus + zPlus  </pre><br>
   * where P is the articulated body inertia, A is the spatial acceleration,<br>
   * a the Coriolis acceleration and z the articulated body forces, and "Plus"<br>
   * indicates that we evaluate these on the inboard (parent) side of the mobilizer<br>
   * rather than on the body's side. (The alternative P(A-a)+z given there does not <br>
   * work for prescribed mobilizers unless you replace "a" with "a_underscore" from<br>
   * equation 16.14.) After calculating F_reaction at the body frame<br>
   * origin Bo, we shift it to M for reporting.<br>
   * <br>
   * <h3>Performance</h3><br>
   * The cost of the above calculation is 114 flops/body. The code presented<br>
   * above for converting from M to F costs an additional 81 flops/body if you<br>
   * use it.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Acceleration</code> </p><br>
   * <br>
   * @see SimTK#MobilizedBody::findMobilizerReactionOnBodyAtMInGround()@see calcMobilizerReactionForcesUsingFreebodyMethod() *
   */
  public void calcMobilizerReactionForces(State state, VectorOfSpatialVec forcesAtMInG) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcMobilizerReactionForces(swigCPtr, this, State.getCPtr(state), state, VectorOfSpatialVec.getCPtr(forcesAtMInG), forcesAtMInG);
  }

  /**
   *  Return a reference to the prescribed motion multipliers tau that have <br>
   * already been calculated in the given <i>state</i>, which must have been realized <br>
   * through Acceleration stage. The result contains entries only for prescribed <br>
   * mobilities; if you want these unpacked into u-space mobility forces, use<br>
   * findMotionForces() instead. A mobilizer may follow prescribed motion either<br>
   * because of a Motion object or a call to MobilizedBody::lock(). <br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Acceleration</code> *</p>
   */
  public Vector getMotionMultipliers(State state) {
    return new Vector(opensimSimbodyJNI.SimbodyMatterSubsystem_getMotionMultipliers(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *  Calculate the degree to which the supplied <i>state</i> does not satisfy the<br>
   * prescribed motion requirements at a particular Stage. For Position and Velocity<br>
   * stage, a call to the prescribe() solver using the same stage will eliminate<br>
   * the error. Accelerations should have been calculated to satisfy all prescribed<br>
   * accelerations, so the returned value should be zero always. The returned <br>
   * Vector has one element per known (prescribed) q, known u, or known udot. <br>
   * <br>
   * The <i>state</i> must be realized to Time stage to check Position errors,<br>
   * Position stage to check Velocity errors, and Acceleration stage to check<br>
   * Acceleration errors. <br>
   * <br>
   * Errors are calculated actualValue - prescribedValue so a positive error<br>
   * indicates that the value in <i>state</i> is too large. *
   */
  public Vector calcMotionErrors(State state, Stage stage) {
    return new Vector(opensimSimbodyJNI.SimbodyMatterSubsystem_calcMotionErrors(swigCPtr, this, State.getCPtr(state), state, Stage.getCPtr(stage), stage), true);
  }

  /**
   *  Find the generalized mobility space forces produced by all the Motion <br>
   * objects active in this system. These are the same values as returned by <br>
   * getMotionMultipliers() but unpacked into u-space slots, with zeroes <br>
   * corresponding to any "free" mobilities, that is, those whose motion is not <br>
   * prescribed. <br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Acceleration</code> *</p>
   */
  public void findMotionForces(State state, Vector mobilityForces) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_findMotionForces(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(mobilityForces), mobilityForces);
  }

  /**
   *  Return a reference to the constraint multipliers lambda that have already <br>
   * been calculated in the given <i>state</i>, which must have been realized through <br>
   * Acceleration stage. Constraint multipliers are not directly interpretable as <br>
   * forces; if you want the actual forces use findConstraintForces() instead. If<br>
   * you want to know individual Constraint contributions to these forces, ask the <br>
   * Constraint objects rather than this SimbodyMatterSubsystem object. <br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Acceleration</code> *</p>
   */
  public Vector getConstraintMultipliers(State state) {
    return new Vector(opensimSimbodyJNI.SimbodyMatterSubsystem_getConstraintMultipliers(swigCPtr, this, State.getCPtr(state), state), false);
  }

  /**
   *  Find the forces produced by all the active Constraint objects in this <br>
   * system. Constraints produce both body spatial forces and generalized <br>
   * mobility-space forces. The supplied <i>state</i> must have been realized through <br>
   * Acceleration stage. <br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Acceleration</code> *</p>
   */
  public void findConstraintForces(State state, VectorOfSpatialVec bodyForcesInG, Vector mobilityForces) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_findConstraintForces(swigCPtr, this, State.getCPtr(state), state, VectorOfSpatialVec.getCPtr(bodyForcesInG), bodyForcesInG, Vector.getCPtr(mobilityForces), mobilityForces);
  }

  /**
   *  Calculate the power being generated or dissipated by all the Motion objects<br>
   * currently active in this system. The sign is chosen so that a positive value for<br>
   * power means the Motion is adding energy to the system; negative means it is<br>
   * removing energy. The <i>state</i> must already have been realized through <br>
   * Acceleration stage so that the prescribed motion forces are available.<br>
   * <br>
   * @param state<br>
   *     A State realized through Acceleration stage from which we obtain the<br>
   *     prescribed motion forces and the velocities needed to calculate power.<br>
   * <br>
   * <h3>Implementation</h3><br>
   * We calculate power=-dot(tau, u) where tau is the set of mobility reaction <br>
   * forces generated by Motion objects and mobilizer locks (tau[i]==0 if mobility<br>
   * i is free), and u is the set of all generalized speeds.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Acceleration</code><br>
   * </p>@see calcConstraintPower() *
   */
  public double calcMotionPower(State state) {
    return opensimSimbodyJNI.SimbodyMatterSubsystem_calcMotionPower(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   *  Return the power begin generated or dissipated by all the Constraint<br>
   * objects currently active in this system. The sign is chosen so that a positive <br>
   * value for power means the Constraints (taken together) are adding energy to the<br>
   * system; negative means they are removing energy. The <i>state</i> must already have<br>
   * been realized through Acceleration stage so that the constraint forces are <br>
   * available.<br>
   * <br>
   * Note that if you want to know the power output of an individual Constraint,<br>
   * you should call that Constraint's calcPower() method; here they are all summed<br>
   * together.<br>
   * <br>
   * @param state<br>
   *     A State realized through Acceleration stage from which we obtain the<br>
   *     constraint forces and the velocities needed to calculate power.<br>
   * @return <br>
   *     The signed sum over all the Constraint objects of the power being generated<br>
   *     or dissipated by each Constraint. A positive value means that together the<br>
   *     constraints are adding energy to the system; negative means they are <br>
   *     removing energy.<br>
   * <br>
   * <h3>Implementation</h3><br>
   * We calculate power=-(dot(F,V)+dot(f,u)) where F is the set of body spatial<br>
   * reaction forces produced by the Constraints, V is the body spatial velocities, <br>
   * f is the set of mobility reaction forces produced by the Constraints, and u is <br>
   * the set of generalized speeds.<br>
   * <br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Acceleration</code> <br>
   * </p>@see calcMotionPower() *
   */
  public double calcConstraintPower(State state) {
    return opensimSimbodyJNI.SimbodyMatterSubsystem_calcConstraintPower(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   *  Accounts for applied forces and inertial forces produced by non-zero <br>
   * velocities in the State. Returns a set of mobility forces which replace both <br>
   * the applied bodyForces and the inertial forces.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Dynamics</code> *</p>
   */
  public void calcTreeEquivalentMobilityForces(State arg0, VectorOfSpatialVec bodyForces, Vector mobilityForces) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcTreeEquivalentMobilityForces(swigCPtr, this, State.getCPtr(arg0), arg0, VectorOfSpatialVec.getCPtr(bodyForces), bodyForces, Vector.getCPtr(mobilityForces), mobilityForces);
  }

  /**
   *  Calculate qdot = N(q)*u in O(n) time (very fast). Note that q is taken<br>
   * from the supplied state while u is an argument to this operator method.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Position</code> *</p>
   */
  public void calcQDot(State s, Vector u, Vector qdot) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcQDot(swigCPtr, this, State.getCPtr(s), s, Vector.getCPtr(u), u, Vector.getCPtr(qdot), qdot);
  }

  /**
   *  Calculate qdotdot = N(q)*udot + Ndot(q,u)*u in O(n) time (very fast). Note<br>
   * that q and u are taken from the supplied state while udot is an argument to<br>
   * this operator method.<br>
   * <p alt="Required stage"><br>
   *   <code>Stage::Velocity</code> *</p>
   */
  public void calcQDotDot(State s, Vector udot, Vector qdotdot) {
    opensimSimbodyJNI.SimbodyMatterSubsystem_calcQDotDot(swigCPtr, this, State.getCPtr(s), s, Vector.getCPtr(udot), udot, Vector.getCPtr(qdotdot), qdotdot);
  }

  public static boolean isInstanceOf(SWIGTYPE_p_Subsystem arg0) {
    return opensimSimbodyJNI.SimbodyMatterSubsystem_isInstanceOf(SWIGTYPE_p_Subsystem.getCPtr(arg0));
  }

  public static SimbodyMatterSubsystem downcast(SWIGTYPE_p_Subsystem arg0) {
    return new SimbodyMatterSubsystem(opensimSimbodyJNI.SimbodyMatterSubsystem_downcast(SWIGTYPE_p_Subsystem.getCPtr(arg0)), false);
  }

  public static SimbodyMatterSubsystem updDowncast(SWIGTYPE_p_Subsystem arg0) {
    return new SimbodyMatterSubsystem(opensimSimbodyJNI.SimbodyMatterSubsystem_updDowncast(SWIGTYPE_p_Subsystem.getCPtr(arg0)), false);
  }

  public SWIGTYPE_p_SimbodyMatterSubsystemRep getRep() {
    return new SWIGTYPE_p_SimbodyMatterSubsystemRep(opensimSimbodyJNI.SimbodyMatterSubsystem_getRep(swigCPtr, this), false);
  }

  public SWIGTYPE_p_SimbodyMatterSubsystemRep updRep() {
    return new SWIGTYPE_p_SimbodyMatterSubsystemRep(opensimSimbodyJNI.SimbodyMatterSubsystem_updRep(swigCPtr, this), false);
  }

}
