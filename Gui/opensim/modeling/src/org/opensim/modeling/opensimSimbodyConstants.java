/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

public interface opensimSimbodyConstants {
  /**
   *  <br>
   * <br>
   * There are two kinds of numerical constants predefined by %SimTK: (1) a set<br>
   * of typed, const, in-memory values in the SimTK namespace, at the default Real <br>
   * precision or with other specific types, and (2) a set of preprocessor<br>
   * (#define) macros containing extremely high-precision precalculated numerical <br>
   * values in long double precision.<br>
   * <br>
   * You should use the typed constants whenever possible in your code since they<br>
   * are very compact and well-behaved in C++. They have memory addresses so can<br>
   * be returned as references. Because they are filled in at startup, they can<br>
   * include machine- and precision-specific values like NaN, Infinity, machine<br>
   * roundoff error, number of digits in a float, etc. that are very useful for <br>
   * writing robust, precision-independent numerical algorithms.<br>
   * <br>
   * The macro values must be cast to the appropriate type before use, and are <br>
   * mostly useful as raw material for making <i>typed</i> constants. These macros<br>
   * contain <em>machine-independent</em> constants, including unitless mathematical <br>
   * constants like pi, as well as physical constants and unit conversion factors.<br>
   * These constants are provided at extremely high precision as compile-time <br>
   * macros in long double precision. By using very high precision we ensure <br>
   * sufficient accuracy for any IEEE long double precision implementation (they <br>
   * can be 64, 80, or 128 bits). These constants can be used as raw material for<br>
   * providing nicer templatized constants in appropriate precisions and unit <br>
   * systems.<br>
   * <br>
   * <h2>Naming conventions</h2><br>
   * Note that the %SimTK convention for typed constants is to name them<br>
   * like ordinary variables except with an initial capital letter (like a<br>
   * class name). This is distinct from the widely-used convention for <br>
   * constants that are defined via the presprocessor as macros (that is, <br>
   * using #define). Those are written entirely in <br>
   * <code>UPPER_CASE_WITH_UNDERSCORES</code>, after an initial <code>SimTK_</code>. Typed constants<br>
   * are processed instead by the compiler itself and do not require any<br>
   * special treatment when used; they behave just like variables of the<br>
   * same type and value would behave so there is no need to shout when <br>
   * using them. * <br>
   *     <br>
   * <br>
   * These are preprocessor (#define) macros providing constants values at very<br>
   * high precision.\ See the discussion under the main <a href="#PredefinedConstants">PredefinedConstants</a><br>
   * module heading.<br>
   * <br>
   * <h2>Units</h2><br>
   * Our most common unit systems are the "SI" (MKS) system, and the "MD" system <br>
   * used for molecular dynamics. SI units are meters, kg, seconds, coulombs <br>
   * (ampere-s), kelvins and moles. MD units are nanometers, atomic mass units<br>
   * (Daltons, g/mol), picoseconds, proton charge e, kelvins, and moles. Many<br>
   * molecular dynamicists and chemists prefer kcals for energy and angstroms for<br>
   * length. This does not constitute a consistent set of units, however, so<br>
   * we provide for it by conversion from the MD units, which are consistent.<br>
   * (By consistent, we mean that force units = mass-length/time^2, so f=ma!)<br>
   * <br>
   * <pre><br>
   * Unit systems<br>
   * <br>
   *            SI (MKS)           MD                     KCAL-ANGSTROM<br>
   * ---------  --------------  ------------------------  ------------------<br>
   * length     meter           nanometer                 angstrom (A)<br>
   * mass       kg              amu, dalton               amu, dalton<br>
   * time       second          picosecond                picosecond<br>
   * charge     coulomb         e, proton charge          e, proton charge<br>
   * temp.      kelvin          kelvin                    kelvin<br>
   * substance  mole            mole                      mole<br>
   * <br>
   * velocity   m/s             km/s (nm/ps)              100m/s (A/ps)<br>
   * <br>
   * energy     J (kg-m^2/s^2)  kJ/mol                    kcal/mol <br>
   *                              (Da-nm^2/ps^2)            (418.4 Da-A^2/ps^2)<br>
   * force      N (kg-m/s^2)    kJ/(mol-nm) = TN/mol      kcal/(mol-A)<br>
   *                              (Da-nm/ps^2) (T=10^12)    (418.4 Da-A/ps^2)<br>
   * <br>
   * </pre><br>
   * <br>
   * We always keep angles in radians internally, which are unitless. However,<br>
   * most humans prefer degrees where 1 degree = Pi/180 radians so we provide<br>
   * convenient conversions. ** The ratio pi of a circle's circumference to its diameter in Euclidean geometry.<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_PI = opensimSimbodyJNI.SimTK_PI_get();
  /**
   *  e, or exp(1).<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_E = opensimSimbodyJNI.SimTK_E_get();
  /**
   *  The natural (base e) logarithm of 2.<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p><br>
   * @see SimTK_E
   */
  public final static double SimTK_LN2 = opensimSimbodyJNI.SimTK_LN2_get();
  /**
   *  The natural (base e) logarithm of 10.<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p><br>
   * @see SimTK_E
   */
  public final static double SimTK_LN10 = opensimSimbodyJNI.SimTK_LN10_get();
  /**
   *  log2(e).<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_LOG2E = opensimSimbodyJNI.SimTK_LOG2E_get();
  /**
   *  log10(e).<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_LOG10E = opensimSimbodyJNI.SimTK_LOG10E_get();
  /**
   *  The square root of 2.<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_SQRT2 = opensimSimbodyJNI.SimTK_SQRT2_get();
  /**
   *  One over the square root of 2; also half the square root of 2 since<br>
   * 1/sqrt(2) == 2^(-1/2) == sqrt(2)/2.<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_OOSQRT2 = opensimSimbodyJNI.SimTK_OOSQRT2_get();
  /**
   *  The cube root of 2, 2^(1/3).<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_CBRT2 = opensimSimbodyJNI.SimTK_CBRT2_get();
  /**
   *  One over the cube root of 2, 2^(-1/3).<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_OOCBRT2 = opensimSimbodyJNI.SimTK_OOCBRT2_get();
  /**
   *  The sixth root of 2, 2^(1/6).<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_SIXRT2 = opensimSimbodyJNI.SimTK_SIXRT2_get();
  /**
   *  One over the sixth root of 2, 2^(-1/6).<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_OOSIXRT2 = opensimSimbodyJNI.SimTK_OOSIXRT2_get();
  /**
   *  The square root of 3.<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_SQRT3 = opensimSimbodyJNI.SimTK_SQRT3_get();
  /**
   *  The cube root of 3.<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact value</p>
   */
  public final static double SimTK_CBRT3 = opensimSimbodyJNI.SimTK_CBRT3_get();
  /**
   * ** <br>
   * Avogadro's number (NA) is defined as the number of atoms in 12g of pure Carbon-12 in<br>
   * its unbound, rest state. The number is 1 mole (mol).<br>
   * <p alt="uncertainty"><br>
   *      10e16</p>
   */
  public final static double SimTK_AVOGADROS_NUMBER = opensimSimbodyJNI.SimTK_AVOGADROS_NUMBER_get();
  /**
   * Mass of a proton in MD units.<br>
   * <br>
   * The atomic mass unit u (or amu) is defined as 1/12 of the mass of a Carbon-12 atom,<br>
   * unbound and in its rest state. This definition matched to Avogadro's number's definition<br>
   * ensures that 1 mole of particles of mass 1u each has total mass exactly 1g. This is<br>
   * synonymous with the dalton (Da), with units of g/mole, so 1u = 1Dalton = 1g/mole.<br>
   * We will use Da for this mass unit, with kDa being a common mass measure for <br>
   * large biomolecules.<br>
   * <br>
   * <p alt="uncertainty"><br>
   *      13e-11</p><br>
   * @see SimTK_AVOGADROS_NUMBER
   */
  public final static double SimTK_MASS_OF_PROTON_IN_MD = opensimSimbodyJNI.SimTK_MASS_OF_PROTON_IN_MD_get();
  /**
   * Mass of a neutron in MD units.<br>
   * <p alt="uncertainty"><br>
   *      55e-11</p><br>
   * @see SimTK_MASS_OF_PROTON_IN_MD
   */
  public final static double SimTK_MASS_OF_NEUTRON_IN_MD = opensimSimbodyJNI.SimTK_MASS_OF_NEUTRON_IN_MD_get();
  /**
   * Mass of an electron in MD units.<br>
   * <p alt="uncertainty"><br>
   *      24e-14</p><br>
   * @see SimTK_MASS_OF_PROTON_IN_MD
   */
  public final static double SimTK_MASS_OF_ELECTRON_IN_MD = opensimSimbodyJNI.SimTK_MASS_OF_ELECTRON_IN_MD_get();
  /**
   * Atomic charge unit e expressed in MKS unit of Coulombs.<br>
   * The charge on an electron is just the negative of this value.<br>
   * <p alt="uncertainty"><br>
   *      14e-27</p>
   */
  public final static double SimTK_CHARGE_OF_PROTON_IN_SI = opensimSimbodyJNI.SimTK_CHARGE_OF_PROTON_IN_SI_get();
  /**
   * Atomic charge unit e expressed in MD units, which uses e as its charge unit!<br>
   * The charge on an electron is just the negative of this value.<br>
   * <p alt="uncertainty"><br>
   *      exact (duh!)</p>
   */
  public final static double SimTK_CHARGE_OF_PROTON_IN_MD = opensimSimbodyJNI.SimTK_CHARGE_OF_PROTON_IN_MD_get();
  /**
   * The charge of 1 mole of protons, expressed in Coulombs.<br>
   * <pre><br>
   *    1.60217653(14)e-19 C/e * 6.0221415(10)e23 = 9.6485338(18)e+4<br>
   * </pre><br>
   * <p alt="uncertainty"><br>
   *      18e-3 </p>
   */
  public final static double SimTK_MOLAR_CHARGE_IN_SI = opensimSimbodyJNI.SimTK_MOLAR_CHARGE_IN_SI_get();
  /**
   * The charge of 1 mole of protons, expressed in MD units where the unit<br>
   * of charge is just the charge on one proton. So in MD units this is just<br>
   * Avogadro's number.<br>
   * @see SimTK_AVOGADROS_NUMBER
   */
  public final static double SimTK_MOLAR_CHARGE_IN_MD = opensimSimbodyJNI.SimTK_MOLAR_CHARGE_IN_MD_get();
  /**
   * Speed of light c is exact in MKS units of m/s.<br>
   * <p alt="uncertainty"><br>
   *      exact</p><br>
   * @see SimTK_LIGHTSPEED_IN_MD
   */
  public final static double SimTK_LIGHTSPEED_IN_SI = opensimSimbodyJNI.SimTK_LIGHTSPEED_IN_SI_get();
  /**
   * Speed of light c is exact in MD units of nm/ps.<br>
   * <p alt="uncertainty"><br>
   *      exact</p><br>
   * @see SimTK_LIGHTSPEED_IN_SI
   */
  public final static double SimTK_LIGHTSPEED_IN_MD = opensimSimbodyJNI.SimTK_LIGHTSPEED_IN_MD_get();
  /**
   * Newton's gravitational constant G in N-m^2/kg^2 = m^3 kg^-1 s^-2.<br>
   * The force between two point masses m1,m2 separated by a distance d is<br>
   *     <pre> F = -G m1*m2/d^2 </pre> <br>
   * (with the "-" indicating an attractive force).<br>
   * <p alt="uncertainty"><br>
   *      10e-15</p><br>
   * @see SimTK_GRAVITATIONAL_CONSTANT_IN_MD
   */
  public final static double SimTK_GRAVITATIONAL_CONSTANT_IN_SI = opensimSimbodyJNI.SimTK_GRAVITATIONAL_CONSTANT_IN_SI_get();
  /**
   * Newton's gravitational constant G in (kJ/mol)-nm^2/u^2 = nm^3 u^-1 ps^-2.<br>
   * <pre><br>
   * Conversion is (nm/m)^3 (u/kg)^-1 (ps/s)^-2<br>
   *          = 1.66053886(28)e-24L     (uncertainty: 28e-32)<br>
   * </pre><br>
   * This is why gravity doesn't matter in molecular systems. Don't try<br>
   * this in single precision -- you'll run out of exponent!<br>
   * <p alt="uncertainty"><br>
   *      17e-39</p><br>
   * @see SimTK_GRAVITATIONAL_CONSTANT_IN_SI
   */
  public final static double SimTK_GRAVITATIONAL_CONSTANT_IN_MD = opensimSimbodyJNI.SimTK_GRAVITATIONAL_CONSTANT_IN_MD_get();
  /**
   * Free space magnetic permeability constant mu0 in SI units (exact).<br>
   * <pre><br>
   *   = 4*pi * 1e-7 exactly in N/A^2 (Newtons/Ampere^2) = kg-m/C^2<br>
   * </pre><br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact quantity</p><br>
   * @see SimTK_ELECTRIC_PERMITTIVITY_IN_SI
   */
  public final static double SimTK_MAGNETIC_PERMEABILITY_IN_SI = opensimSimbodyJNI.SimTK_MAGNETIC_PERMEABILITY_IN_SI_get();
  /**
   * Free space magnetic permeability constant mu0 in MD units (not exact).<br>
   * <pre><br>
   * Convert kg-&gt;g/mole, m-&gt;nm, C-&gt;e = (4*pi*1e5)*1.60217653e-19^2*6.0221415e23<br>
   *      (exact in SI units, but not exact here)<br>
   * </pre><br>
   * <p alt="uncertainty"><br>
   *      47e-16</p><br>
   * @see SimTK_ELECTRIC_PERMITTIVITY_IN_MD
   */
  public final static double SimTK_MAGNETIC_PERMEABILITY_IN_MD = opensimSimbodyJNI.SimTK_MAGNETIC_PERMEABILITY_IN_MD_get();
  /**
   * Free space permittivity constant e0 = 1/(mu0*c^2) Farad/m = Coulomb^2/(N-m^2) (exact in SI units).<br>
   * <p alt="uncertainty"><br>
   *      approximation of an exact quantity</p><br>
   * @see SimTK_MAGNETIC_PERMEABILITY_IN_SI
   */
  public final static double SimTK_ELECTRIC_PERMITTIVITY_IN_SI = opensimSimbodyJNI.SimTK_ELECTRIC_PERMITTIVITY_IN_SI_get();
  /**
   * Free space permittivity constant e0=1/(mu0*c^2) e^2/(kN-nm^2) using MD permeability and<br>
   * MD lightspeed.<br>
   * <p alt="uncertainty"><br>
   *      14e-11</p><br>
   * @see SimTK_MAGNETIC_PERMEABILITY_IN_MD
   */
  public final static double SimTK_ELECTRIC_PERMITTIVITY_IN_MD = opensimSimbodyJNI.SimTK_ELECTRIC_PERMITTIVITY_IN_MD_get();
  /**
   * Coulomb's constant kappa = 1/(4pi*e0)=1e-7*c^2 N-m^2/Coulomb^2 (exact in SI units).<br>
   * This is the constant that appears in Coulomb's law f(r)= kappa*q1*q2/r^2.<br>
   * <p alt="uncertainty"><br>
   *      exact</p>
   */
  public final static double SimTK_COULOMB_CONSTANT_IN_SI = opensimSimbodyJNI.SimTK_COULOMB_CONSTANT_IN_SI_get();
  /**
   * Coulomb's constant kappa = 1/(4*pi*e0) in MD units.<br>
   * This is the constant that appears in Coulomb's law f(r)= kappa*q1*q2/r^2.<br>
   * <pre><br>
   * Coulomb's consant in MD units uses MD e0 &amp; c: <br>
   *   1/(4*pi*e0)=1e5*1.60217653e-19^2*6.0221415e23*c^2 kN-nm^2/e^2 (=kJ-nm/e^2)<br>
   *     (exact in SI units but not exact in MD)<br>
   * </pre><br>
   * <p alt="uncertainty"><br>
   *      33e-6</p>
   */
  public final static double SimTK_COULOMB_CONSTANT_IN_MD = opensimSimbodyJNI.SimTK_COULOMB_CONSTANT_IN_MD_get();
  /**
   * Coulomb's constant kappa = 1/(4*pi*e0) in kcal-Angstroms/e^2.<br>
   * This is the constant that appears in Coulomb's law f(r)= kappa*q1*q2/r^2.<br>
   * This is an exact conversion from MD units (which are inexact).<br>
   * <p alt="uncertainty"><br>
   *      80e-6</p>
   */
  public final static double SimTK_COULOMB_CONSTANT_IN_KCAL_ANGSTROM = opensimSimbodyJNI.SimTK_COULOMB_CONSTANT_IN_KCAL_ANGSTROM_get();
  /**
   * This is the gas constant R in (J/mol)/K. <br>
   * <p alt="uncertainty"><br>
   *      15e-6</p>
   */
  public final static double SimTK_MOLAR_GAS_CONSTANT_SI = opensimSimbodyJNI.SimTK_MOLAR_GAS_CONSTANT_SI_get();
  /**
   * This is the gas constant R in (kJ/mol)/K. <br>
   * This is an exact conversion from SI units, differing only in the use of kJ <br>
   * here vs. J in SI.<br>
   * <p alt="uncertainty"><br>
   *      15e-9</p>
   */
  public final static double SimTK_MOLAR_GAS_CONSTANT_MD = opensimSimbodyJNI.SimTK_MOLAR_GAS_CONSTANT_MD_get();
  /**
   * This is the gas constant R in (kcal/mol)/K. <br>
   * This is an exact conversion from MD units, differing only in the use of kcal <br>
   * here vs. kJ in MD.<br>
   * <p alt="uncertainty"><br>
   *      36e-10</p>
   */
  public final static double SimTK_MOLAR_GAS_CONSTANT_KCAL_ANGSTROM = opensimSimbodyJNI.SimTK_MOLAR_GAS_CONSTANT_KCAL_ANGSTROM_get();
  /**
   * Boltzmann's constant in SI units of joules/kelvin; just divide R by NA.<br>
   * <p alt="uncertainty"><br>
   *      24e-30</p>
   */
  public final static double SimTK_BOLTZMANN_CONSTANT_SI = opensimSimbodyJNI.SimTK_BOLTZMANN_CONSTANT_SI_get();
  /**
   * Boltzmann's constant in MD units of (kJ/mol)/kelvin; same as R.<br>
   * @see SimTK_MOLAR_GAS_CONSTANT_MD
   */
  public final static double SimTK_BOLTZMANN_CONSTANT_MD = opensimSimbodyJNI.SimTK_BOLTZMANN_CONSTANT_MD_get();
  /**
   * Boltzmann's constant in Kcal-Angstrom units of (kcal/mol)/kelvin; same as R.<br>
   * @see SimTK_MOLAR_GAS_CONSTANT_KCAL_ANGSTROM
   */
  public final static double SimTK_BOLTZMANN_CONSTANT_KCAL_ANGSTROM = opensimSimbodyJNI.SimTK_BOLTZMANN_CONSTANT_KCAL_ANGSTROM_get();
  /**
   * ** <br>
   * Convert radians to degrees.<br>
   * <p alt="uncertainty"><br>
   *       approximation of an exact quantity</p><br>
   * @see SimTK_DEGREE_TO_RADIAN
   */
  public final static double SimTK_RADIAN_TO_DEGREE = opensimSimbodyJNI.SimTK_RADIAN_TO_DEGREE_get();
  /**
   * Convert degrees to radians.<br>
   * <p alt="uncertainty"><br>
   *       approximation of an exact quantity</p><br>
   * @see SimTK_RADIAN_TO_DEGREE
   */
  public final static double SimTK_DEGREE_TO_RADIAN = opensimSimbodyJNI.SimTK_DEGREE_TO_RADIAN_get();
  /**
   * Convert nanoseconds to seconds.<br>
   * <p alt="uncertainty"><br>
   *          exact</p><br>
   * @see SimTK_S_TO_NS
   */
  public final static double SimTK_NS_TO_S = opensimSimbodyJNI.SimTK_NS_TO_S_get();
  /**
   * Convert seconds to nanoseconds.<br>
   * <p alt="uncertainty"><br>
   *          exact</p><br>
   * @see SimTK_NS_TO_S
   */
  public final static double SimTK_S_TO_NS = opensimSimbodyJNI.SimTK_S_TO_NS_get();
  /**
   * Convert Kcal to Kjoule (also Kcal/mol to Kjoule/mol).<br>
   * <p alt="uncertainty"><br>
   *         exact</p><br>
   * @see SimTK_KJOULE_TO_KCAL
   */
  public final static double SimTK_KCAL_TO_KJOULE = opensimSimbodyJNI.SimTK_KCAL_TO_KJOULE_get();
  /**
   * Convert Kjoule to Kcal (also Kjoule/mol to Kcal/mol).<br>
   * <p alt="uncertainty"><br>
   *         approximation of an exact quantity</p><br>
   * @see SimTK_KCAL_TO_KJOULE
   */
  public final static double SimTK_KJOULE_TO_KCAL = opensimSimbodyJNI.SimTK_KJOULE_TO_KCAL_get();
  /**
   * Convert atomic mass unit (amu, Dalton) to g. This is 1/NA (NA=avogadro's number).<br>
   * <p alt="uncertainty"><br>
   *         28e-32</p><br>
   * @see SimTK_AVOGADROS_NUMBER
   */
  public final static double SimTK_DALTON_TO_GRAM = opensimSimbodyJNI.SimTK_DALTON_TO_GRAM_get();
  /**
   * Convert proton charge units to Coulombs. This is the same as the<br>
   * conversion from electron volts to Joules, and both are just the<br>
   * charge of a proton in SI units.<br>
   * @see SimTK_CHARGE_OF_PROTON_IN_SI<br>
   * @see SimTK_EV_TO_JOULE
   */
  public final static double SimTK_E_TO_COULOMB = opensimSimbodyJNI.SimTK_E_TO_COULOMB_get();
  /**
   * Convert electron volts to Joules. This is the same as the<br>
   * conversion from proton charge units to Coulombs, and both are just the<br>
   * charge of a proton in SI units.<br>
   * @see SimTK_CHARGE_OF_PROTON_IN_SI<br>
   * @see SimTK_E_TO_COULOMB
   */
  public final static double SimTK_EV_TO_JOULE = opensimSimbodyJNI.SimTK_EV_TO_JOULE_get();
  /**
   * <br>
   * Mandatory first inclusion for any Simbody source or header file.<br>
   * <br>
   * Every source and most header files using %SimTK must include this <br>
   * header as its <i>first</i> inclusion. Declarations and definitions that <br>
   * must be available and compiler-and machine-specific issues are dealt<br>
   * with here.<br>
   * <br>
   * This file must be includable from either C++ or ANSI C. It uses<br>
   * the ANSI-C++ macro "__cplusplus" for any code that will compile<br>
   * only under C++. *<br>
   * This is the top-level %SimTK namespace into which all %SimTK names are <br>
   * placed to avoid collision with other symbols. If you get tired of prefacing <br>
   * every symbol with "SimTK::", include the statement "using namespace SimTK;" <br>
   * at the beginning of your %SimTK-using compilation units. Any names which <br>
   * cannot be put in the namespace (macro names, for example) begin with the <br>
   * prefix "SimTK_" instead. *<br>
   * This compile-time constant determines the default precision used everywhere<br>
   * in %SimTK Core code. Wherever a SimTK::Real, SimTK::Vector, SimTK::Matrix,<br>
   * etc. appears with no precision specified, it will have this underlying precision.<br>
   * We use 1==float, 2==double, 4==long double. Any other value will cause<br>
   * a compile time error. The default is 2, i.e., double precision.
   */
  public final static int SimTK_DEFAULT_PRECISION = opensimSimbodyJNI.SimTK_DEFAULT_PRECISION_get();
}
