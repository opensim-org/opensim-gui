/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 * InputController is a simple intermediate abstract class for a Controller that<br>
 * computes controls based on scalar values defined via a list Input.<br>
 * <br>
 * Concrete implementations of InputController must provide a relevant <br>
 * implementation for the computeControlsImpl() method. This method is called by<br>
 * computeControls() only if the InputController has the correct number of <br>
 * connected Input controls. Otherwise, computeControls() does modify the<br>
 * model controls vector. It is up to each concrete implementation class to <br>
 * define how the scalar values from the list Input are mapped to the controls <br>
 * for the actuators in the controller's ActuatorSet. Additionally, concrete <br>
 * implementations must implement getInputControlLabels() to provide a vector of<br>
 * labels denoting the order and length of the scalar Input values expected by <br>
 * the controller. These labels may be useful in simulation tools (e.g., Moco)<br>
 * to make connections between control signals from other sources <br>
 * (e.g., ControlDistributor) and the Input controls of the controller.<br>
 * <br>
 * InputController provides convenience methods for getting the names and<br>
 * indexes of the controls for the actuators in the controller's ActuatorSet.<br>
 * Non-scalar actuators will have multiple controls, and therefore have multiple<br>
 * control names and indexes. Control information is only available after <br>
 * calling Model::finalizeConnections().<br>
 * <br>
 * Actuator control names and indexes are based on the convention used by the<br>
 * utility function SimulationUtilities::createControlNamesFromModel(), which<br>
 * returns control names and indexes based on the order of the actuators stored<br>
 * in the model. However, we do not check if the order of the actuators stored<br>
 * in the model matches the order of the controls in the underlying system. Use<br>
 * the utility function SimulationUtilities::checkOrderSystemControls() to<br>
 * perform this check when using this controller.
 */
public class InputController extends Controller {
  private transient long swigCPtr;

  public InputController(long cPtr, boolean cMemoryOwn) {
    super(opensimSimulationJNI.InputController_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  public static long getCPtr(InputController obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(InputController obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings({"deprecation", "removal"})
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_InputController(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  public static InputController safeDownCast(OpenSimObject obj) {
    long cPtr = opensimSimulationJNI.InputController_safeDownCast(OpenSimObject.getCPtr(obj), obj);
    return (cPtr == 0) ? null : new InputController(cPtr, false);
  }

  public void assign(OpenSimObject aObject) {
    opensimSimulationJNI.InputController_assign(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  public static String getClassName() {
    return opensimSimulationJNI.InputController_getClassName();
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.InputController_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new InputController(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.InputController_getConcreteClassName(swigCPtr, this);
  }

  public void setPropertyIndex_input_controls(SWIGTYPE_p_OpenSim__PropertyIndex value) {
    opensimSimulationJNI.InputController_PropertyIndex_input_controls_set(swigCPtr, this, SWIGTYPE_p_OpenSim__PropertyIndex.getCPtr(value));
  }

  public SWIGTYPE_p_OpenSim__PropertyIndex getPropertyIndex_input_controls() {
    return new SWIGTYPE_p_OpenSim__PropertyIndex(opensimSimulationJNI.InputController_PropertyIndex_input_controls_get(swigCPtr, this), true);
  }

  public void connectInput_controls(AbstractOutput output, String alias) {
    opensimSimulationJNI.InputController_connectInput_controls__SWIG_0(swigCPtr, this, AbstractOutput.getCPtr(output), output, alias);
  }

  public void connectInput_controls(AbstractOutput output) {
    opensimSimulationJNI.InputController_connectInput_controls__SWIG_1(swigCPtr, this, AbstractOutput.getCPtr(output), output);
  }

  public void connectInput_controls(AbstractChannel channel, String alias) {
    opensimSimulationJNI.InputController_connectInput_controls__SWIG_2(swigCPtr, this, AbstractChannel.getCPtr(channel), channel, alias);
  }

  public void connectInput_controls(AbstractChannel channel) {
    opensimSimulationJNI.InputController_connectInput_controls__SWIG_3(swigCPtr, this, AbstractChannel.getCPtr(channel), channel);
  }

  /**
   * Get the vector of labels for the Input controls expected by the<br>
   * controller.<br>
   * <br>
   * The connected Input controls must match the length and order of the <br>
   * labels returned by this method. These labels may be useful in simulation<br>
   * tools (e.g., Moco) for mapping control signals from another source to <br>
   * the Input controls of the controller.
   */
  public StdVectorString getInputControlLabels() {
    return new StdVectorString(opensimSimulationJNI.InputController_getInputControlLabels(swigCPtr, this), true);
  }

  /**
   * Compute the controls for the actuators in the controller's ActuatorSet<br>
   * based on the scalar values provided by the Input controls.<br>
   * <br>
   * This method is only called by computeControls() if the InputController<br>
   * has the correct number of connected Input controls. Concrete <br>
   * implementations of this class must provide a relevant implementation.
   */
  public void computeControlsImpl(State state, Vector controls) {
    opensimSimulationJNI.InputController_computeControlsImpl(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(controls), controls);
  }

  public void computeControls(State state, Vector controls) {
    opensimSimulationJNI.InputController_computeControls(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(controls), controls);
  }

  /**
   * Get the number of Input controls expected by the controller.
   */
  public int getNumInputControls() {
    return opensimSimulationJNI.InputController_getNumInputControls(swigCPtr, this);
  }

  /**
   * Get the names of the controls for the actuators in the controller's<br>
   * ActuatorSet.<br>
   * <br>
   * For scalar actuators, these names are simply the paths of<br>
   * the actuators in the model. For non-scalar actuators, these names are<br>
   * actuator path plus an additional suffix representing the index of the<br>
   * control in the actuator's control vector (e.g., "/actuator_0").<br>
   * <br>
   * Note: Only valid after actuators are connected and<br>
   *       Model::finalizeConnections() has been called.<br>
   * <br>
   * Note: This does *not* check if the order of the actuators stored in the<br>
   *       model matches the order of the controls in the underlying system.<br>
   *       Use SimulationUtilities::checkOrderSystemControls() to perform<br>
   *       this check.
   */
  public StdVectorString getControlNames() {
    return new StdVectorString(opensimSimulationJNI.InputController_getControlNames(swigCPtr, this), false);
  }

  /**
   * Get the model control indexes for the controls associated with the<br>
   * actuators in the controller's ActuatorSet.<br>
   * <br>
   * The control indexes are based on the order of the actuators stored in the<br>
   * model. Non-scalar actuators will have multiple controls, and therefore<br>
   * have multiple control indexes. The order of the returned indexes matches<br>
   * the order of the control names returned by getControlNames().<br>
   * <br>
   * Note: Only valid after actuators are connected and<br>
   *       Model::finalizeConnections() has been called.<br>
   * <br>
   * Note: This does *not* check if the order of the actuators stored in the<br>
   *       model matches the order of the controls in the underlying system.<br>
   *       Use SimulationUtilities::checkOrderSystemControls() to perform<br>
   *       this check.
   */
  public StdVectorInt getControlIndexes() {
    return new StdVectorInt(opensimSimulationJNI.InputController_getControlIndexes(swigCPtr, this), false);
  }

}
