/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  Class used to iterate over subcomponents of a specific type (by default,<br>
 * any Component).<br>
 * This iterator is can either be a const_iterator or non-const iterator, depending<br>
 * on how you got it. If this is a const_iterator, it returns only a const<br>
 * reference to a component. If this is a non-const iterator, then it returns<br>
 * a non-const reference to a component, and thus you can modify the component.<br>
 * <br>
 * If you got this iterator from something like a ComponentList&lt;const Body&gt;, then<br>
 * it is necessarily a const_iterator. If you got this iterator from something like<br>
 * ComponentList<body>, then this may be either a const_iterator (e.g., from<br>
 * ComponentList<body>::cbegin()) or non-const iterator (e.g.,<br>
 * from ComponentList<body>::begin()).<br>
 * <br>
 * If you have a non-const iterator, you should *not* add (sub)components to any<br>
 * components.<br>
 * <br>
 * This iterator works only in the forward direction (not bidirectional).<br>
 * <br>
 * Here is an example of using this iterator with a range for loop (const_iterator):<br>
 * {@code 
ComponentList<const GeometryPath> geomPathList = model.getComponentList<GeometryPath>();
for (const GeometryPath& gpath : geomPathList) {
do something with gpath
}
}<br>
 * <br>
 * Here is a similar example, but where you can modify the components:<br>
 * {@code 
ComponentList<GeometryPath> geomPathList = model.updComponentList<GeometryPath>();
for (GeometryPath& gpath : geomPathList) {
do something with gpath
}
}
 */
public class Millard2012EquilibriumMuscleIterator {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public Millard2012EquilibriumMuscleIterator(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(Millard2012EquilibriumMuscleIterator obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(Millard2012EquilibriumMuscleIterator obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_Millard2012EquilibriumMuscleIterator(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  @ Comparison operators for scripting<br>
   *  These variants accept only an iterator with the same template parameter.<br>
   *  <br>
   *  Check for (non)equality using a normal method rather than an operator.
   */
  public boolean equals(Millard2012EquilibriumMuscleIterator other) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_equals(swigCPtr, this, Millard2012EquilibriumMuscleIterator.getCPtr(other), other);
  }

  /**
   *  Dereference the iterator to get a reference to Component of proper<br>
   *     type (matching Filter if specified). If you have a const iterator, then<br>
   *     this returns a const reference; otherwise, this returns a non-const<br>
   *     reference. 
   */
  public Millard2012EquilibriumMuscle __ref__() {
    return new Millard2012EquilibriumMuscle(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator___ref__(swigCPtr, this), false);
  }

  public Millard2012EquilibriumMuscle deref() {
    return new Millard2012EquilibriumMuscle(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_deref(swigCPtr, this), false);
  }

  /**
   *  Another dereferencing operator that returns a pointer.
   */
  public Millard2012EquilibriumMuscle __deref__() {
    long cPtr = opensimSimulationJNI.Millard2012EquilibriumMuscleIterator___deref__(swigCPtr, this);
    return (cPtr == 0) ? null : new Millard2012EquilibriumMuscle(cPtr, false);
  }

  /**
   *  Method equivalent to pre-increment operator for operator-deficient<br>
   *      languages. 
   */
  public Millard2012EquilibriumMuscleIterator next() {
    return new Millard2012EquilibriumMuscleIterator(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_next(swigCPtr, this), false);
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Millard2012EquilibriumMuscle(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getConcreteClassName(swigCPtr, this);
  }

  public double get_fiber_damping(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_fiber_damping__SWIG_0(swigCPtr, this, i);
  }

  public double get_fiber_damping() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_fiber_damping__SWIG_1(swigCPtr, this);
  }

  public double get_default_activation(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_default_activation__SWIG_0(swigCPtr, this, i);
  }

  public double get_default_activation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_default_activation__SWIG_1(swigCPtr, this);
  }

  public double get_default_fiber_length(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_default_fiber_length__SWIG_0(swigCPtr, this, i);
  }

  public double get_default_fiber_length() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_default_fiber_length__SWIG_1(swigCPtr, this);
  }

  public double get_activation_time_constant(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_activation_time_constant__SWIG_0(swigCPtr, this, i);
  }

  public double get_activation_time_constant() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_activation_time_constant__SWIG_1(swigCPtr, this);
  }

  public double get_deactivation_time_constant(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_deactivation_time_constant__SWIG_0(swigCPtr, this, i);
  }

  public double get_deactivation_time_constant() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_deactivation_time_constant__SWIG_1(swigCPtr, this);
  }

  public double get_minimum_activation(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_minimum_activation__SWIG_0(swigCPtr, this, i);
  }

  public double get_minimum_activation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_minimum_activation__SWIG_1(swigCPtr, this);
  }

  public double get_maximum_pennation_angle(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_maximum_pennation_angle__SWIG_0(swigCPtr, this, i);
  }

  public double get_maximum_pennation_angle() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_maximum_pennation_angle__SWIG_1(swigCPtr, this);
  }

  public ActiveForceLengthCurve get_ActiveForceLengthCurve(int i) {
    return new ActiveForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_ActiveForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public ActiveForceLengthCurve get_ActiveForceLengthCurve() {
    return new ActiveForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_ActiveForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public ForceVelocityCurve get_ForceVelocityCurve(int i) {
    return new ForceVelocityCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_ForceVelocityCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public ForceVelocityCurve get_ForceVelocityCurve() {
    return new ForceVelocityCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_ForceVelocityCurve__SWIG_1(swigCPtr, this), false);
  }

  public FiberForceLengthCurve get_FiberForceLengthCurve(int i) {
    return new FiberForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_FiberForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public FiberForceLengthCurve get_FiberForceLengthCurve() {
    return new FiberForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_FiberForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public TendonForceLengthCurve get_TendonForceLengthCurve(int i) {
    return new TendonForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_TendonForceLengthCurve__SWIG_0(swigCPtr, this, i), false);
  }

  public TendonForceLengthCurve get_TendonForceLengthCurve() {
    return new TendonForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_TendonForceLengthCurve__SWIG_1(swigCPtr, this), false);
  }

  public boolean get_has_output_passive_fiber_elastic_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_elastic_force_get(swigCPtr, this);
  }

  public boolean get_has_output_passive_fiber_elastic_force_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_elastic_force_along_tendon_get(swigCPtr, this);
  }

  public boolean get_has_output_passive_fiber_damping_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_damping_force_get(swigCPtr, this);
  }

  public boolean get_has_output_passive_fiber_damping_force_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_damping_force_along_tendon_get(swigCPtr, this);
  }

  /**
   *  @return A boolean indicating whether fiber damping is being used. 
   */
  public boolean getUseFiberDamping() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getUseFiberDamping(swigCPtr, this);
  }

  /**
   *  @return The fiber damping coefficient. 
   */
  public double getFiberDamping() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberDamping(swigCPtr, this);
  }

  /**
   *  @return The default activation level that is used as an initial<br>
   *     condition if none is provided by the user. 
   */
  public double getDefaultActivation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getDefaultActivation(swigCPtr, this);
  }

  /**
   *  @return The default fiber length that is used as an initial condition<br>
   *     if none is provided by the user. 
   */
  public double getDefaultFiberLength() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getDefaultFiberLength(swigCPtr, this);
  }

  /**
   *  @return The activation time constant (in seconds). 
   */
  public double getActivationTimeConstant() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActivationTimeConstant(swigCPtr, this);
  }

  /**
   *  @return The deactivation time constant (in seconds). 
   */
  public double getDeactivationTimeConstant() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getDeactivationTimeConstant(swigCPtr, this);
  }

  /**
   *  @return The minimum activation level permitted by the muscle model.<br>
   *     Note that this equilibrium model, like all equilibrium models, has a<br>
   *     singularity when activation approaches 0, which means that a non-zero lower<br>
   *     bound is required. 
   */
  public double getMinimumActivation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMinimumActivation(swigCPtr, this);
  }

  /**
   *  @return The ActiveForceLengthCurve used by this model. 
   */
  public ActiveForceLengthCurve getActiveForceLengthCurve() {
    return new ActiveForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActiveForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *  @return The ForceVelocityCurve used by this model. 
   */
  public ForceVelocityCurve getForceVelocityCurve() {
    return new ForceVelocityCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getForceVelocityCurve(swigCPtr, this), false);
  }

  /**
   *  @return The FiberForceLengthCurve used by this model. 
   */
  public FiberForceLengthCurve getFiberForceLengthCurve() {
    return new FiberForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *  @return The TendonForceLengthCurve used by this model. 
   */
  public TendonForceLengthCurve getTendonForceLengthCurve() {
    return new TendonForceLengthCurve(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonForceLengthCurve(swigCPtr, this), false);
  }

  /**
   *  @return The MuscleFixedWidthPennationModel owned by this model. 
   */
  public MuscleFixedWidthPennationModel getPennationModel() {
    return new MuscleFixedWidthPennationModel(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPennationModel(swigCPtr, this), false);
  }

  /**
   *  @return The MuscleFirstOrderActivationDynamicModel owned by this<br>
   *     model. 
   */
  public MuscleFirstOrderActivationDynamicModel getActivationModel() {
    return new MuscleFirstOrderActivationDynamicModel(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActivationModel(swigCPtr, this), false);
  }

  /**
   *  @return The minimum fiber length, which is the maximum of two values:<br>
   *     the smallest fiber length allowed by the pennation model, and the minimum<br>
   *     fiber length on the active-force-length curve. When the fiber reaches this<br>
   *     length, it is constrained to this value until the fiber velocity becomes<br>
   *     positive. 
   */
  public double getMinimumFiberLength() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMinimumFiberLength(swigCPtr, this);
  }

  /**
   *  @return The minimum fiber length along the tendon, which is the maximum<br>
   *     of two values: the smallest fiber length along the tendon permitted by the<br>
   *     pennation model, and the minimum fiber length along the tendon on the<br>
   *     active-force-length curve. When the fiber length reaches this value, it is<br>
   *     constrained to this length along the tendon until the fiber velocity becomes<br>
   *     positive. 
   */
  public double getMinimumFiberLengthAlongTendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMinimumFiberLengthAlongTendon(swigCPtr, this);
  }

  /**
   *  @param s The state of the system.<br>
   *         @return The normalized force term associated with the tendon element,<br>
   *      \mathbf{f}_{SE}(\hat{l}_{T}), in the equilibrium equation. 
   */
  public double getTendonForceMultiplier(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonForceMultiplier(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  @return The stiffness of the muscle fibers along the tendon (N/m). 
   */
  public double getFiberStiffnessAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberStiffnessAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  @param s The state of the system.<br>
   *     @return The velocity of the fiber (m/s). 
   */
  public double getFiberVelocity(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberVelocity(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  @param s The state of the system.<br>
   *     @return The time derivative of activation. 
   */
  public double getActivationDerivative(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActivationDerivative(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the portion of the passive fiber force generated by the elastic<br>
   *         element only (N) 
   */
  public double getPassiveFiberElasticForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPassiveFiberElasticForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the portion of the passive fiber force generated by the elastic<br>
   *         element only, projected onto the tendon direction (N) 
   */
  public double getPassiveFiberElasticForceAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPassiveFiberElasticForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the portion of the passive fiber force generated by the damping<br>
   *         element only (N) 
   */
  public double getPassiveFiberDampingForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPassiveFiberDampingForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the portion of the passive fiber force generated by the damping<br>
   *         element only, projected onto the tendon direction (N) 
   */
  public double getPassiveFiberDampingForceAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPassiveFiberDampingForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  @param s The state of the system.<br>
   *         @param activation The desired activation level. 
   */
  public void setActivation(State s, double activation) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setActivation(swigCPtr, this, State.getCPtr(s), s, activation);
  }

  /**
   *  @param s The state of the system.<br>
   *         @param fiberLength The desired fiber length (m). 
   */
  public void setFiberLength(State s, double fiberLength) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setFiberLength(swigCPtr, this, State.getCPtr(s), s, fiberLength);
  }

  /**
   *  @param s The state of the system.<br>
   *         @return The tensile force the muscle is generating (N). 
   */
  public double computeActuation(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_computeActuation(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Computes the fiber length such that the fiber and tendon are developing<br>
   *     the same force, distributing the velocity of the entire musculotendon<br>
   *     actuator between the fiber and tendon according to their relative<br>
   *     stiffnesses.<br>
   *         @param s The state of the system.<br>
   *         @throws MuscleCannotEquilibrate
   */
  public void computeInitialFiberEquilibrium(State s) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_computeInitialFiberEquilibrium(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Computes the fiber length such that the fiber and tendon are developing<br>
   *         the same force, either assuming muscle-tendon velocity as provided<br>
   *         by the state or zero as designated by the useZeroVelocity flag.<br>
   *         @param s         The state of the system.<br>
   *         @param solveForVelocity  Flag indicating to solve for fiber velocity,<br>
   *                                  which by default is false (zero fiber-velocity)<br>
   *         @throws MuscleCannotEquilibrate
   */
  public void computeFiberEquilibrium(State s, boolean solveForVelocity) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_computeFiberEquilibrium__SWIG_0(swigCPtr, this, State.getCPtr(s), s, solveForVelocity);
  }

  /**
   *  Computes the fiber length such that the fiber and tendon are developing<br>
   *         the same force, either assuming muscle-tendon velocity as provided<br>
   *         by the state or zero as designated by the useZeroVelocity flag.<br>
   *         @param s         The state of the system.<br>
   *         @throws MuscleCannotEquilibrate
   */
  public void computeFiberEquilibrium(State s) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_computeFiberEquilibrium__SWIG_1(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   * Conditional comment: DEPRECATED
   */
  public double calcActiveFiberForceAlongTendon(double activation, double fiberLength, double fiberVelocity) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_calcActiveFiberForceAlongTendon(swigCPtr, this, activation, fiberLength, fiberVelocity);
  }

  public Vec4 calcFiberStateGivenBoundaryCond(double lengthMT, double velocityMT, double tendonForce, double dTendonForceDT) {
    return new Vec4(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_calcFiberStateGivenBoundaryCond(swigCPtr, this, lengthMT, velocityMT, tendonForce, dTendonForceDT), true);
  }

  public double calcInextensibleTendonActiveFiberForce(State s, double aActivation) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_calcInextensibleTendonActiveFiberForce(swigCPtr, this, State.getCPtr(s), s, aActivation);
  }

  public double get_max_isometric_force(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_max_isometric_force__SWIG_0(swigCPtr, this, i);
  }

  public double get_max_isometric_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_max_isometric_force__SWIG_1(swigCPtr, this);
  }

  public double get_optimal_fiber_length(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_optimal_fiber_length__SWIG_0(swigCPtr, this, i);
  }

  public double get_optimal_fiber_length() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_optimal_fiber_length__SWIG_1(swigCPtr, this);
  }

  public double get_tendon_slack_length(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_tendon_slack_length__SWIG_0(swigCPtr, this, i);
  }

  public double get_tendon_slack_length() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_tendon_slack_length__SWIG_1(swigCPtr, this);
  }

  public double get_pennation_angle_at_optimal(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_pennation_angle_at_optimal__SWIG_0(swigCPtr, this, i);
  }

  public double get_pennation_angle_at_optimal() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_pennation_angle_at_optimal__SWIG_1(swigCPtr, this);
  }

  public double get_max_contraction_velocity(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_max_contraction_velocity__SWIG_0(swigCPtr, this, i);
  }

  public double get_max_contraction_velocity() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_max_contraction_velocity__SWIG_1(swigCPtr, this);
  }

  public boolean get_ignore_tendon_compliance(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_ignore_tendon_compliance__SWIG_0(swigCPtr, this, i);
  }

  public boolean get_ignore_tendon_compliance() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_ignore_tendon_compliance__SWIG_1(swigCPtr, this);
  }

  public boolean get_ignore_activation_dynamics(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_ignore_activation_dynamics__SWIG_0(swigCPtr, this, i);
  }

  public boolean get_ignore_activation_dynamics() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_ignore_activation_dynamics__SWIG_1(swigCPtr, this);
  }

  public boolean get_has_output_excitation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_excitation_get(swigCPtr, this);
  }

  public boolean get_has_output_activation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_activation_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_length() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_length_get(swigCPtr, this);
  }

  public boolean get_has_output_pennation_angle() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_pennation_angle_get(swigCPtr, this);
  }

  public boolean get_has_output_cos_pennation_angle() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_cos_pennation_angle_get(swigCPtr, this);
  }

  public boolean get_has_output_tendon_length() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_tendon_length_get(swigCPtr, this);
  }

  public boolean get_has_output_normalized_fiber_length() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_normalized_fiber_length_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_length_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_length_along_tendon_get(swigCPtr, this);
  }

  public boolean get_has_output_tendon_strain() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_tendon_strain_get(swigCPtr, this);
  }

  public boolean get_has_output_passive_force_multiplier() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_passive_force_multiplier_get(swigCPtr, this);
  }

  public boolean get_has_output_active_force_length_multiplier() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_active_force_length_multiplier_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_velocity() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_velocity_get(swigCPtr, this);
  }

  public boolean get_has_output_normalized_fiber_velocity() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_normalized_fiber_velocity_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_velocity_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_velocity_along_tendon_get(swigCPtr, this);
  }

  public boolean get_has_output_tendon_velocity() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_tendon_velocity_get(swigCPtr, this);
  }

  public boolean get_has_output_force_velocity_multiplier() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_force_velocity_multiplier_get(swigCPtr, this);
  }

  public boolean get_has_output_pennation_angular_velocity() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_pennation_angular_velocity_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_force_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_force_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_force_along_tendon_get(swigCPtr, this);
  }

  public boolean get_has_output_active_fiber_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_active_fiber_force_get(swigCPtr, this);
  }

  public boolean get_has_output_passive_fiber_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_force_get(swigCPtr, this);
  }

  public boolean get_has_output_active_fiber_force_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_active_fiber_force_along_tendon_get(swigCPtr, this);
  }

  public boolean get_has_output_passive_fiber_force_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_passive_fiber_force_along_tendon_get(swigCPtr, this);
  }

  public boolean get_has_output_tendon_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_tendon_force_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_stiffness() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_stiffness_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_stiffness_along_tendon() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_stiffness_along_tendon_get(swigCPtr, this);
  }

  public boolean get_has_output_tendon_stiffness() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_tendon_stiffness_get(swigCPtr, this);
  }

  public boolean get_has_output_muscle_stiffness() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_muscle_stiffness_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_active_power() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_active_power_get(swigCPtr, this);
  }

  public boolean get_has_output_fiber_passive_power() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_fiber_passive_power_get(swigCPtr, this);
  }

  public boolean get_has_output_tendon_power() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_tendon_power_get(swigCPtr, this);
  }

  public boolean get_has_output_muscle_power() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_muscle_power_get(swigCPtr, this);
  }

  /**
   *  get/set the maximum isometric force (in N) that the fibers can generate 
   */
  public double getMaxIsometricForce() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMaxIsometricForce(swigCPtr, this);
  }

  /**
   *  get/set the optimal length (in m) of the muscle fibers (lumped as a single fiber) 
   */
  public double getOptimalFiberLength() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getOptimalFiberLength(swigCPtr, this);
  }

  /**
   *  get/set the resting (slack) length (in m) of the tendon that is in series with the muscle fiber 
   */
  public double getTendonSlackLength() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonSlackLength(swigCPtr, this);
  }

  /**
   *  get/set the angle (in radians) between fibers at their optimal fiber length and the tendon 
   */
  public double getPennationAngleAtOptimalFiberLength() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPennationAngleAtOptimalFiberLength(swigCPtr, this);
  }

  /**
   *  get/set the maximum contraction velocity of the fibers, in optimal fiber-lengths per second 
   */
  public double getMaxContractionVelocity() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMaxContractionVelocity(swigCPtr, this);
  }

  /**
   *  Get/set Modeling (runtime) option to ignore tendon compliance when <br>
   *     computing muscle dynamics. This does not directly modify the persistent<br>
   *     property value. *
   */
  public boolean getIgnoreTendonCompliance(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getIgnoreTendonCompliance(swigCPtr, this, State.getCPtr(s), s);
  }

  public void setIgnoreTendonCompliance(State s, boolean ignore) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setIgnoreTendonCompliance(swigCPtr, this, State.getCPtr(s), s, ignore);
  }

  /**
   *  Get/set Modeling (runtime) option to ignore activation dynamics when <br>
   *     computing muscle dynamics. This does not directly modify the persistent<br>
   *     property value. *
   */
  public boolean getIgnoreActivationDynamics(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getIgnoreActivationDynamics(swigCPtr, this, State.getCPtr(s), s);
  }

  public void setIgnoreActivationDynamics(State s, boolean ignore) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setIgnoreActivationDynamics(swigCPtr, this, State.getCPtr(s), s, ignore);
  }

  /**
   *  get the activation level of the muscle, which modulates the active force<br>
   *         of the muscle and has a normalized (0 to 1) value <br>
   *         Note: method remains virtual to permit override by deprecated muscles. 
   */
  public double getActivation(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActivation(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current working fiber length (m) for the muscle 
   */
  public double getFiberLength(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberLength(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current pennation angle (radians) between the fiber and tendon at the current fiber length  
   */
  public double getPennationAngle(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPennationAngle(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the cosine of the current pennation angle (radians) between the fiber and tendon at the current fiber length  
   */
  public double getCosPennationAngle(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getCosPennationAngle(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current tendon length (m)  given the current joint angles and fiber length 
   */
  public double getTendonLength(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonLength(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current normalized fiber length (fiber_length/optimal_fiber_length) 
   */
  public double getNormalizedFiberLength(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getNormalizedFiberLength(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current fiber length (m) projected (*cos(pennationAngle)) onto the tendon direction 
   */
  public double getFiberLengthAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberLengthAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current tendon strain (delta_l/tendon_slack_length is dimensionless)  
   */
  public double getTendonStrain(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonStrain(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  the potential energy (J) stored in the fiber due to its parallel elastic element 
   */
  public double getFiberPotentialEnergy(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberPotentialEnergy(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  the potential energy (J) stored in the tendon 
   */
  public double getTendonPotentialEnergy(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonPotentialEnergy(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  the total potential energy (J) stored in the muscle 
   */
  public double getMusclePotentialEnergy(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMusclePotentialEnergy(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the passive fiber (parallel elastic element) force multiplier 
   */
  public double getPassiveForceMultiplier(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPassiveForceMultiplier(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the active fiber (contractile element) force multiplier due to current fiber length 
   */
  public double getActiveForceLengthMultiplier(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActiveForceLengthMultiplier(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get normalized fiber velocity. This is the fiber velocity in m/s divided by<br>
   *     the maximum contraction velocity expressed in m/s; therefore, this quantity is<br>
   *     dimensionless and generally lies in the range [-1, 1]. 
   */
  public double getNormalizedFiberVelocity(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getNormalizedFiberVelocity(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current fiber velocity (m/s) projected onto the tendon direction 
   */
  public double getFiberVelocityAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberVelocityAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get pennation angular velocity (radians/s) 
   */
  public double getPennationAngularVelocity(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPennationAngularVelocity(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the tendon velocity (m/s) positive is lengthening 
   */
  public double getTendonVelocity(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonVelocity(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the dimensionless multiplier resulting from the fiber's force-velocity curve 
   */
  public double getForceVelocityMultiplier(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getForceVelocityMultiplier(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current fiber force (N) applied to the tendon 
   */
  public double getFiberForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   * get the force of the fiber (N/m) along the direction of the tendon
   */
  public double getFiberForceAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current active fiber force (N) due to activation*force_length*force_velocity relationships 
   */
  public double getActiveFiberForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActiveFiberForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the total force applied by all passive elements in the fiber (N) 
   */
  public double getPassiveFiberForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPassiveFiberForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current active fiber force (N) projected onto the tendon direction 
   */
  public double getActiveFiberForceAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActiveFiberForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the total force applied by all passive elements in the fiber (N)<br>
   *         projected onto the tendon direction 
   */
  public double getPassiveFiberForceAlongTendon(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPassiveFiberForceAlongTendon(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current tendon force (N) applied to bones 
   */
  public double getTendonForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current fiber stiffness (N/m) defined as the partial derivative<br>
   *         of fiber force with respect to fiber length 
   */
  public double getFiberStiffness(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberStiffness(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current tendon stiffness (N/m) defined as the partial derivative<br>
   *         of tendon force with respect to tendon length 
   */
  public double getTendonStiffness(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonStiffness(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current muscle stiffness (N/m) defined as the partial derivative<br>
   *         of muscle force with respect to muscle length 
   */
  public double getMuscleStiffness(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMuscleStiffness(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current active fiber power (W) 
   */
  public double getFiberActivePower(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberActivePower(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current passive fiber power (W) 
   */
  public double getFiberPassivePower(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getFiberPassivePower(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current tendon power (W) 
   */
  public double getTendonPower(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getTendonPower(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the current muscle power (W) 
   */
  public double getMusclePower(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMusclePower(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the stress in the muscle (part of the Actuator interface as well) 
   */
  public double getStress(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getStress(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  set the excitation (control) for this muscle. NOTE if controllers are connected to the<br>
   *         muscle and are adding in their controls, and setExcitation is called after the model's<br>
   *         computeControls(), then setExcitation will override the controller values. If called <br>
   *         before computeControls, then controller value(s) are added to the excitation set here. 
   */
  public void setExcitation(State s, double excitation) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setExcitation(swigCPtr, this, State.getCPtr(s), s, excitation);
  }

  public double getExcitation(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getExcitation(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Find and set the equilibrium state of the muscle (if any) 
   */
  public void computeEquilibrium(State s) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_computeEquilibrium(swigCPtr, this, State.getCPtr(s), s);
  }

  public AbstractGeometryPath get_path(int i) {
    return new AbstractGeometryPath(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_path__SWIG_0(swigCPtr, this, i), false);
  }

  public AbstractGeometryPath get_path() {
    return new AbstractGeometryPath(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_path__SWIG_1(swigCPtr, this), false);
  }

  public double get_optimal_force(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_optimal_force__SWIG_0(swigCPtr, this, i);
  }

  public double get_optimal_force() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_optimal_force__SWIG_1(swigCPtr, this);
  }

  public boolean get_has_output_tension() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_tension_get(swigCPtr, this);
  }

  public AbstractGeometryPath getPath() {
    return new AbstractGeometryPath(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPath(swigCPtr, this), false);
  }

  public GeometryPath getGeometryPath() {
    return new GeometryPath(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getGeometryPath(swigCPtr, this), false);
  }

  public boolean hasVisualPath() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_hasVisualPath(swigCPtr, this);
  }

  public double getOptimalForce() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getOptimalForce(swigCPtr, this);
  }

  public double getLength(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getLength(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getLengtheningSpeed(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getLengtheningSpeed(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getPower(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPower(swigCPtr, this, State.getCPtr(s), s);
  }

  public double computeMomentArm(State s, Coordinate aCoord) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_computeMomentArm(swigCPtr, this, State.getCPtr(s), s, Coordinate.getCPtr(aCoord), aCoord);
  }

  public double get_min_control(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_min_control__SWIG_0(swigCPtr, this, i);
  }

  public double get_min_control() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_min_control__SWIG_1(swigCPtr, this);
  }

  public double get_max_control(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_max_control__SWIG_0(swigCPtr, this, i);
  }

  public double get_max_control() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_max_control__SWIG_1(swigCPtr, this);
  }

  public boolean get_has_output_actuation() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_actuation_get(swigCPtr, this);
  }

  public boolean get_has_output_speed() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_speed_get(swigCPtr, this);
  }

  /**
   *  Convenience method to get control given scalar (double) valued control
   */
  public double getControl(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getControl(swigCPtr, this, State.getCPtr(s), s);
  }

  public int numControls() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_numControls(swigCPtr, this);
  }

  public void setActuation(State s, double aActuation) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setActuation(swigCPtr, this, State.getCPtr(s), s, aActuation);
  }

  public double getActuation(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getActuation(swigCPtr, this, State.getCPtr(s), s);
  }

  public void setSpeed(State s, double aspeed) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setSpeed(swigCPtr, this, State.getCPtr(s), s, aspeed);
  }

  public double getSpeed(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getSpeed(swigCPtr, this, State.getCPtr(s), s);
  }

  public double getMinControl() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMinControl(swigCPtr, this);
  }

  public double getMaxControl() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getMaxControl(swigCPtr, this);
  }

  /**
   * Enable/disable a ScalarActuator's override actuation.<br>
   * <br>
   * The actuation normally produced by a ScalarActuator can be overridden and<br>
   * When the ScalarActuator's actuation is overridden, the ScalarActuator will<br>
   * by default produce a constant actuation which can be set with<br>
   * setOverrideActuation().<br>
   * <br>
   * @param s    current state<br>
   * @param flag true = override ScalarActuator's output actuation<br>
   *             false = use ScalarActuator's computed force (normal operation)
   */
  public void overrideActuation(State s, boolean flag) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_overrideActuation(swigCPtr, this, State.getCPtr(s), s, flag);
  }

  /**
   *  return ScalarActuator's override status
   */
  public boolean isActuationOverridden(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_isActuationOverridden(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   * set the actuation value used when the override is true <br>
   * <br>
   * @param s      current state<br>
   * @param value  value of override actuation   
   */
  public void setOverrideActuation(State s, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setOverrideActuation(swigCPtr, this, State.getCPtr(s), s, value);
  }

  /**
   * return override actuation 
   */
  public double getOverrideActuation(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getOverrideActuation(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Convenience methods for getting, setting and adding to actuator controls from/into <br>
   *         the model controls. These methods have no effect on the realization stage. 
   */
  public void getControls(Vector modelControls, Vector actuatorControls) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getControls(swigCPtr, this, Vector.getCPtr(modelControls), modelControls, Vector.getCPtr(actuatorControls), actuatorControls);
  }

  /**
   *  set actuator controls subvector into the right slot in the system-wide model controls 
   */
  public void setControls(Vector actuatorControls, Vector modelControls) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setControls(swigCPtr, this, Vector.getCPtr(actuatorControls), actuatorControls, Vector.getCPtr(modelControls), modelControls);
  }

  /**
   *  add actuator controls to the values already occupying the slot in the system-wide model controls 
   */
  public void addInControls(Vector actuatorControls, Vector modelControls) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_addInControls(swigCPtr, this, Vector.getCPtr(actuatorControls), actuatorControls, Vector.getCPtr(modelControls), modelControls);
  }

  public boolean get_appliesForce(int i) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_appliesForce__SWIG_0(swigCPtr, this, i);
  }

  public boolean get_appliesForce() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_get_appliesForce__SWIG_1(swigCPtr, this);
  }

  public boolean get_has_output_potential_energy() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator__has_output_potential_energy_get(swigCPtr, this);
  }

  /**
   * Tell SimBody to parallelize this force. Should be <br>
   * set to true for any forces that will take time to <br>
   * complete their calcForce method. Note that all forces<br>
   * that set this flag to false will be put in series on a<br>
   * thread that is running in parallel with other forces<br>
   * that marked this flag as true.
   */
  public boolean shouldBeParallelized() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_shouldBeParallelized(swigCPtr, this);
  }

  /**
   *  Return if the Force is applied (or enabled) or not.                   
   */
  public boolean appliesForce(State s) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_appliesForce(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  %Set whether or not the Force is applied.                             
   */
  public void setAppliesForce(State s, boolean applyForce) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setAppliesForce(swigCPtr, this, State.getCPtr(s), s, applyForce);
  }

  /**
   *  Get a const reference to the Model this component is part of. 
   */
  public Model getModel() {
    return new Model(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getModel(swigCPtr, this), false);
  }

  /**
   *  Does this ModelComponent have a Model associated with it? 
   */
  public boolean hasModel() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_hasModel(swigCPtr, this);
  }

  /**
   *  Have the Component add itself to the underlying computational System 
   */
  public void addToSystem(SWIGTYPE_p_SimTK__MultibodySystem system) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_addToSystem(swigCPtr, this, SWIGTYPE_p_SimTK__MultibodySystem.getCPtr(system));
  }

  /**
   *  Initialize Component's state variable values from its properties 
   */
  public void initStateFromProperties(State state) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_initStateFromProperties(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   * Optional method for generating arbitrary display geometry that reflects<br>
   *     this %Component at the specified <i>state</i>. This will be called once to<br>
   *     obtain ground- and body-fixed geometry (with <i>fixed=</i><code>true)</code>, and then<br>
   *     once per frame (with <i>fixed=</i><code>false)</code> to generate on-the-fly geometry such<br>
   *     as rubber band lines, force arrows, labels, or debugging aids.<br>
   * <br>
   *     Please note that there is a precondition that the state passed in to<br>
   *     generateDecorations be realized to Stage::Position. If your component can<br>
   *     visualize quantities realized at Velocity, Dynamics or Acceleration stages,<br>
   *     then you must check that the stage has been realized before using/requesting<br>
   *     stage dependent values. It is forbidden to realize the model to a higher<br>
   *     stage within generateDecorations, because this can trigger costly side-<br>
   *     effects such as evaluating all model forces even when performing a purely<br>
   *     kinematic study.<br>
   * <br>
   *     If you override this method, be sure to invoke the base class method first,<br>
   *     using code like this:<br>
   *     {@code 
      void MyComponent::generateDecorations
         (bool                                        fixed,
          const ModelDisplayHints&                    hints,
          const SimTK::State&                         state,
          SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
      {
  invoke parent class method
          Super::generateDecorations(fixed,hints,state,appendToThis);
  ... your code goes here
  can render velocity dependent quanities if stage is Velocity or higher
          if(state.getSystemStage() >= Stage::Velocity) {
  draw velocity vector for model COM
          }
  can render computed forces if stage is Dynamics or higher
          if(state.getSystemStage() >= Stage::Dynamics) {
  change the length of a force arrow based on the force in N
          }
      }
      }<br>
   * <br>
   *     @param fixed<br>
   *         If <code>true</code>, generate only geometry that is fixed to a PhysicalFrame,<br>
   *         configuration, and velocity. Otherwise generate only such dependent<br>
   *         geometry.<br>
   *     @param hints<br>
   *         See documentation for ModelDisplayHints; you may want to alter the<br>
   *         geometry you generate depending on what you find there. For example,<br>
   *         you can determine whether the user wants to see debug geometry.<br>
   *     @param state<br>
   *         The State for which geometry should be produced. See below for more<br>
   *         information.<br>
   *     @param appendToThis<br>
   *         %Array to which generated geometry should be <i>appended</i> via the<br>
   *         <code>push_back()</code> method.<br>
   * <br>
   *     When called with <i>fixed=</i><code>true</code> only modeling options and parameters<br>
   *     (Instance variables) should affect geometry; time, position, and velocity<br>
   *     should not. In that case OpenSim will already have realized the <i>state</i><br>
   *     through Instance stage. When called with <i>fixed=</i><code>false</code>, you may<br>
   *     consult any relevant value in <i>state</i>. However, to avoid unnecessary<br>
   *     computation, OpenSim guarantees only that <i>state</i> will have been realized<br>
   *     through Position stage; if you need anything higher than that (reaction<br>
   *     forces, for example) you should make sure the <i>state</i> is realized through<br>
   *     Acceleration stage. *
   */
  public void generateDecorations(boolean fixed, ModelDisplayHints hints, State state, ArrayDecorativeGeometry appendToThis) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_generateDecorations(swigCPtr, this, fixed, ModelDisplayHints.getCPtr(hints), hints, State.getCPtr(state), state, ArrayDecorativeGeometry.getCPtr(appendToThis), appendToThis);
  }

  /**
   * Get the underlying MultibodySystem that this component is connected to.<br>
   * Make sure you have called Model::initSystem() prior to accessing the System.<br>
   * Throws an Exception if the System has not been created or the Component<br>
   * has not added itself to the System.<br>
   * @see hasSystem().  
   */
  public SWIGTYPE_p_SimTK__MultibodySystem getSystem() {
    return new SWIGTYPE_p_SimTK__MultibodySystem(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getSystem(swigCPtr, this), false);
  }

  /**
   * Check if this component has an underlying MultibodySystem.<br>
   * Returns false if the System has not been created OR if this<br>
   * Component has not added itself to the System.  
   */
  public boolean hasSystem() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_hasSystem(swigCPtr, this);
  }

  /**
   *  Does the provided component already exist anywhere in the ownership<br>
   * tree (not just subcomponents of this component)? 
   */
  public boolean isComponentInOwnershipTree(Component component) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_isComponentInOwnershipTree(swigCPtr, this, Component.getCPtr(component), component);
  }

  /**
   *  Get the complete (absolute) pathname for this Component to its ancestral<br>
   * Component, which is the root of the tree to which this Component belongs.<br>
   * For example: a Coordinate Component would have an absolute path name<br>
   * like: `/arm26/elbow_r/flexion`. Accessing a Component by its<br>
   * absolutePathName from root is guaranteed to be unique. The<br>
   * absolutePathName is generated on-the-fly by traversing the ownership tree<br>
   * and, therefore, calling this method is not "free". 
   */
  public String getAbsolutePathString() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getAbsolutePathString(swigCPtr, this);
  }

  /**
   *  Return a ComponentPath of the absolute path of this Component.<br>
   * Note that this has more overhead than calling `getName()` because<br>
   * it traverses up the tree to generate the absolute pathname (and its<br>
   * computational cost is thus a function of depth). Consider other<br>
   * options if this is repeatedly called and efficiency is important.<br>
   * For instance, `getAbsolutePathString()` is faster if you only<br>
   * need the path as a string. 
   */
  public ComponentPath getAbsolutePath() {
    return new ComponentPath(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getAbsolutePath(swigCPtr, this), true);
  }

  /**
   *  Get the relative path of this Component with respect to another<br>
   * Component, as a string. 
   */
  public String getRelativePathString(Component wrt) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getRelativePathString(swigCPtr, this, Component.getCPtr(wrt), wrt);
  }

  /**
   *  Get the relative path of this Component with respect to another<br>
   * Component. 
   */
  public ComponentPath getRelativePath(Component wrt) {
    return new ComponentPath(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getRelativePath(swigCPtr, this, Component.getCPtr(wrt), wrt), true);
  }

  /**
   *  Query if there is a component (of any type) at the specified<br>
   * path name. For example,<br>
   * {@code 
  bool exists = model.hasComponent("right_elbow/elbow_flexion");
  }<br>
   * checks if `model` has a subcomponent "right_elbow," which has a<br>
   * subcomponent "elbow_flexion." 
   */
  public boolean hasComponent(String pathname) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_hasComponent(swigCPtr, this, pathname);
  }

  /**
   *  Similar to the templatized getComponent(), except this returns the<br>
   * component as the generic Component type. This can be used in<br>
   * Python/Java/MATLAB. Here is an example of using this in MATLAB:<br>
   * {@code 
  coord = model.getComponent('right_elbow/elbow_flexion')
  coord.getNumConnectees() % okay; this is a Component method.
  coord.getDefaultClamped() % inaccessible; method on Coordinate.
  Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.
  }<br>
   * <br>
   * %Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  coord = model.getComponent('right_elbow/elbow_flexion')
  coord.getDefaultClamped() # works; no downcasting necessary.
  }
   */
  public Component getComponent(String pathname) {
    return new Component(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getComponent(swigCPtr, this, pathname), false);
  }

  /**
   *  Print a list to the console of all components whose absolute path name<br>
   * contains the given string. You might use this if (a) you know the name<br>
   * of a component in your model but don't know its absolute path, (b) if<br>
   * you want to find all components with a given name, or (c) to get a list<br>
   * of all components on the right leg of a model (if all components on the<br>
   * right side have "_r" in their name).<br>
   * <br>
   * A function call like:<br>
   * {@code 
  unsigned num = comp.printComponentsMatching("rotation");
  }<br>
   * may produce output like:<br>
   * {@literal 
  /leg_model/right_hip/rotation
  /leg_model/left_hip/rotation
  }<br>
   * <br>
   * @return The number of matches. 
   */
  public long printComponentsMatching(String substring) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_printComponentsMatching(swigCPtr, this, substring);
  }

  /**
   * Get the number of "continuous" state variables maintained by the<br>
   * Component and its subcomponents.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public int getNumStateVariables() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getNumStateVariables(swigCPtr, this);
  }

  /**
   * Get the names of "continuous" state variables maintained by the Component<br>
   * and its subcomponents.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public ArrayStr getStateVariableNames() {
    return new ArrayStr(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getStateVariableNames(swigCPtr, this), true);
  }

  /**
   *  Get the number of Sockets in this Component. 
   */
  public int getNumSockets() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getNumSockets(swigCPtr, this);
  }

  /**
   *  Collect and return the names of the sockets in this component. You<br>
   * can use this to iterate through the sockets:<br>
   * {@code 
  for (std::string name : comp.getSocketNames()) {
      const AbstractSocket& socket = getSocket(name);
  }
  } 
   */
  public StdVectorString getSocketNames() {
    return new StdVectorString(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getSocketNames(swigCPtr, this), true);
  }

  /**
   *  Get the connectee as an Object. This means you will not have<br>
   * access to the methods on the concrete connectee. This is the method you<br>
   * must use in MATLAB to access the connectee.<br>
   * <br>
   * Example:<br>
   * {@code 
  const Object& obj = joint.getConnectee("parent_frame");
  obj.getName(); // method on Object works.
  obj.getMobilizedBody(); // error: not available.
  }<br>
   * <br>
   * In MATLAB, if you want the concrete type, you need to downcast the<br>
   * Object. Here is an example where you know the "parent_frame" is a Body:<br>
   * {@code 
  f = joint.getConnectee('parent_frame');
  m = Body.safeDownCast(f).getMass();
  }<br>
   * <br>
   * Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  f = joint.getConnectee("parent_frame");
  m = f.getMass() # works (if the parent frame is a body)
  }
   */
  public OpenSimObject getConnectee(String name) {
    return new OpenSimObject(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getConnectee(swigCPtr, this, name), false);
  }

  public AbstractSocket getSocket(String name) {
    return new AbstractSocket(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getSocket(swigCPtr, this, name), false);
  }

  /**
   *  Access the number of Inputs that this component has. 
   */
  public int getNumInputs() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getNumInputs(swigCPtr, this);
  }

  /**
   *  Access the number of Outputs that this component has. 
   */
  public int getNumOutputs() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getNumOutputs(swigCPtr, this);
  }

  /**
   *  Collect and return the names of Inputs in this component as an<br>
   * std::vector. 
   */
  public StdVectorString getInputNames() {
    return new StdVectorString(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getInputNames(swigCPtr, this), true);
  }

  /**
   *  Collect and return the names of Outputs in this component as an<br>
   * std::vector. 
   */
  public StdVectorString getOutputNames() {
    return new StdVectorString(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getOutputNames(swigCPtr, this), true);
  }

  /**
   * Get an Input provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get an Input from a Component in the model<br>
   * {@code 
  model.getComponent("/path/to/component").getInput("inputName");
  }<br>
   * <br>
   * If you have not yet called finalizeFromProperties() on this<br>
   * component, this function will update the Input (to tell it which<br>
   * component it's in) before providing it to you.<br>
   * <br>
   * @param name   the name of the Input<br>
   * @return const reference to the AbstractInput
   */
  public AbstractInput getInput(String name) {
    return new AbstractInput(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getInput(swigCPtr, this, name), false);
  }

  /**
   * Get the Output provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get an Output from a Component in a model<br>
   * {@code 
  model.getComponent("/path/to/component").getOutput("outputName");
  }<br>
   * <br>
   * @param name   the name of the Output<br>
   * @return const reference to the AbstractOutput
   */
  public AbstractOutput getOutput(String name) {
    return new AbstractOutput(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getOutput(swigCPtr, this, name), false);
  }

  /**
   * Get a ModelingOption flag for this Component by name.<br>
   * The flag is an integer corresponding to the index of modelingOptionNames used<br>
   * add the modeling option to the component. @see addModelingOption<br>
   * <br>
   * @param state  the State in which to set the modeling option<br>
   * @param name   the name (string) of the modeling option of interest<br>
   * @return flag  integer value for modeling option
   */
  public int getModelingOption(State state, String name) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getModelingOption(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * %Set the value of a ModelingOption flag for this Component.<br>
   * if the integer value exceeds the number of option names used to<br>
   * define the options, an exception is thrown. The SimTK::State<br>
   * Stage will be reverted back to Stage::Instance.<br>
   * <br>
   * @param state  the State in which to set the flag<br>
   * @param name   the name (string) of the modeling option of interest<br>
   * @param flag   the desired flag (int) value specifying the modeling option
   */
  public void setModelingOption(State state, String name, int flag) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setModelingOption(swigCPtr, this, State.getCPtr(state), state, name, flag);
  }

  /**
   * Get the value of a state variable allocated by this Component.<br>
   * <br>
   * To connect this StateVariable as an input to another component (such as<br>
   * a Reporter), use getOutput(name); each state variable has a<br>
   * corresponding Output:<br>
   *  {@code 
   foo.getInput("input1").connect(bar.getOutput(name));
   }<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @param name    the name (string) of the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableValue(State state, String name) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getStateVariableValue__SWIG_0(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Get the value of a state variable allocated by this Component.<br>
   * <br>
   * To connect this StateVariable as an input to another component (such as<br>
   * a Reporter), use getOutput(name); each state variable has a<br>
   * corresponding Output:<br>
   * <br>
   *  {@code 
   foo.getInput("input1").connect(bar.getOutput(name));
   }<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * <br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableValue(State state, ComponentPath path) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getStateVariableValue__SWIG_1(swigCPtr, this, State.getCPtr(state), state, ComponentPath.getCPtr(path), path);
  }

  /**
   * %Set the value of a state variable allocated by this Component by name.<br>
   * <br>
   * @param state  the State for which to set the value<br>
   * @param name   the name of the state variable<br>
   * @param value  the value to set<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setStateVariableValue(State state, String name, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setStateVariableValue(swigCPtr, this, State.getCPtr(state), state, name, value);
  }

  /**
   * Get all values of the state variables allocated by this Component.<br>
   * Includes state variables allocated by its subcomponents.<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @return Vector of state variable values of length getNumStateVariables()<br>
   *                in the order returned by getStateVariableNames()<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public Vector getStateVariableValues(State state) {
    return new Vector(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getStateVariableValues(swigCPtr, this, State.getCPtr(state), state), true);
  }

  /**
   * %Set all values of the state variables allocated by this Component.<br>
   * Includes state variables allocated by its subcomponents. Note, this<br>
   * method simply sets the values on the input State. If other conditions<br>
   * must be met (such as satisfying kinematic constraints for Coordinates,<br>
   * or fiber and tendon equilibrium for muscles) you must invoke the<br>
   * appropriate methods on Model (e.g. assemble() to satisfy constraints or<br>
   * equilibrateMuscles()) to satisfy these conditions starting from the<br>
   * State values provided by setStateVariableValues.<br>
   * <br>
   * @param state   the State whose values are set<br>
   * @param values  Vector of state variable values of length<br>
   *                getNumStateVariables() in the order returned by<br>
   *                getStateVariableNames()<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setStateVariableValues(State state, Vector values) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setStateVariableValues(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(values), values);
  }

  /**
   * Get the value of a state variable derivative computed by this Component.<br>
   * <br>
   * @param state   the State for which to get the derivative value<br>
   * @param name    the name (string) of the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableDerivativeValue(State state, String name) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getStateVariableDerivativeValue(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Get the value of a discrete variable allocated by this Component by name.<br>
   * <br>
   * @param state   the State from which to get the value<br>
   * @param name    the name of the state variable<br>
   * @return value  the discrete variable value<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getDiscreteVariableValue(State state, String name) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getDiscreteVariableValue(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * %Set the value of a discrete variable allocated by this Component by name.<br>
   * <br>
   * @param state  the State for which to set the value<br>
   * @param name   the name of the discrete variable<br>
   * @param value  the value to set<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setDiscreteVariableValue(State state, String name, double value) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_setDiscreteVariableValue(swigCPtr, this, State.getCPtr(state), state, name, value);
  }

  /**
   * Get the index of a Component's cache variable in the Subsystem for allocations.<br>
   * <br>
   * <br>
   * @param name<br>
   *   Name of the cache variable, as provided to Component::addCacheVariable<br>
   * @return <br>
   *   A valid SimTK::CacheEntryIndex, which callers can use with simbody methods<br>
   *   (e.g. markCacheValueRealized)
   */
  public SWIGTYPE_p_SimTK__CacheEntryIndex getCacheVariableIndex(String name) {
    return new SWIGTYPE_p_SimTK__CacheEntryIndex(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getCacheVariableIndex(swigCPtr, this, name), true);
  }

  /**
   * Returns true if the cache variable, identified by `name`, is valid.<br>
   * <br>
   * This method enables callers to monitor the validity of the cache variable,<br>
   * which enables the caller to decide whether to update the cache variable's<br>
   * value (or not). When computing an update is costly, use this method to check<br>
   * whether computing the value is necessary.<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @return bool<br>
   *     whether the cache variable's value is valid or not<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public boolean isCacheVariableValid(State state, String name) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_isCacheVariableValid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Marks the value of a cache variable, identified by `name`, as valid.<br>
   * <br>
   * Upon marking a cache variable's value as valid, the cache variable will remain<br>
   * valid until either:<br>
   * <br>
   * - the realization stage falls below the minimum realization stage set<br>
   *   when the cache variable was initialized with `Component::addCacheVariable`<br>
   * <br>
   * - the cache variable is explicitly invalidated by calling<br>
   *   `Component::markCacheVariableInvalid`<br>
   * <br>
   * This method causes `Component::isCacheVariableValid` to return true.<br>
   * `Component::isCacheVariableValid` is commonly used by value-getting<br>
   * methods to decide on whether to return the value as-is or recompute the<br>
   * value. Therefore, if a cache variable is not marked as valid then the<br>
   * cache variable's value may be recomputed more than necessary, which may<br>
   * be costly.<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public void markCacheVariableValid(State state, String name) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_markCacheVariableValid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Marks the value of a cache variable, identified by `name`, as invalid.<br>
   * <br>
   * Upon marking a cache variable's value as invalid, it will remain invalid<br>
   * until `Component::markCacheVariableValid` is called (or a method which<br>
   * uses that, such as `Component::setCacheVariableValue`, is called).<br>
   * <br>
   * - Cache variables are automatically marked as invalid when the realization stage<br>
   *   falls below the minimum realization stage set when the cache variable was<br>
   *   initialized with `Component::addCacheVariable`.<br>
   * <br>
   * - Cache variables *may* be indirectly marked as invalid by other methods. For<br>
   *   example, a component-added state variable may invalidate a cache variable at<br>
   *   a lower stage. Concretely:<br>
   * <br>
   *   - A (hypothetical) component has a `length` state variable<br>
   *   - There are cache variables that are computed from `length` (e.g.<br>
   *   `strain`)<br>
   *   - So changing the `length` may invalidate the `strain` indirectly<br>
   *     (depending on how the state variable is handled)<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public void markCacheVariableInvalid(State state, String name) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_markCacheVariableInvalid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   *  List all subcomponents by name and recurse into these components to<br>
   *     list their subcomponents, and so on.                                      
   */
  public void printSubcomponentInfo() {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_printSubcomponentInfo(swigCPtr, this);
  }

  /**
   *  List all the Sockets of this component and whether or not they are<br>
   *     connected. Also list the connectee paths for sockets that are connected. 
   */
  public void printSocketInfo() {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_printSocketInfo(swigCPtr, this);
  }

  /**
   *  List all the inputs of this component and whether or not they are<br>
   *     connected. Also list the (desired) connectee paths for the inputs.       
   */
  public void printInputInfo() {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_printInputInfo(swigCPtr, this);
  }

  /**
   *  Print outputs of this component and optionally, those of all<br>
   *     subcomponents.                                                            
   */
  public void printOutputInfo(boolean includeDescendants) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_printOutputInfo__SWIG_0(swigCPtr, this, includeDescendants);
  }

  /**
   *  Print outputs of this component and optionally, those of all<br>
   *     subcomponents.                                                            
   */
  public void printOutputInfo() {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_printOutputInfo__SWIG_1(swigCPtr, this);
  }

  /**
   *  Access the owner of this Component.<br>
   * An exception is thrown if the %Component has no owner; in this case, the<br>
   * component is the root component, or is orphaned.<br>
   * @see hasOwner() 
   */
  public Component getOwner() {
    return new Component(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getOwner(swigCPtr, this), false);
  }

  /**
   *  (For advanced users) Check if this %Component has an owner.<br>
   * A component may not have an owner if it:<br>
   * (1) is the root component, or<br>
   * (2) has not been added to another component 
   */
  public boolean hasOwner() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_hasOwner(swigCPtr, this);
  }

  /**
   *  Obtain the root %Component, which is this component if it is orphaned.
   */
  public Component getRoot() {
    return new Component(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getRoot(swigCPtr, this), false);
  }

  /**
   *  Find a Component to which this Component is an ancestor---in other<br>
   *     words, a Component that is directly owned by this Component or is owned<br>
   *     by one of its sub-components, sub-sub-components, etc. The Component can<br>
   *     be found by type (by specifying a template argument) and either path or<br>
   *     name.<br>
   * <br>
   *     Here is an example of searching for a component of any type with the name<br>
   *     'elbow_flexion':<br>
   *     {@code 
      if (const Component* found =
              model.findComponent(ComponentPath("elbow_flexion"))) {
          std::cout << found.getName() << std::endl;
      }
      }<br>
   * <br>
   *     Here, we require that 'elbow_flexion' is of type Coordinate.<br>
   *     {@code 
      if (const Coordinate* found =
              model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
          std::cout << "Coordinate " << found.getName() << std::endl;
      }
      }<br>
   * <br>
   *     The search can be sped up considerably if the path or even partial path<br>
   *     name is known. For example, "forearm/elbow/elbow_flexion" will find<br>
   *     the Coordinate component of the elbow joint that connects the forearm body<br>
   *     in linear time (linear search for name at each component level). Whereas<br>
   *     supplying "elbow_flexion" requires a tree search. Returns nullptr (None in<br>
   *     Python, empty array in Matlab) if Component of that specified name cannot<br>
   *     be found.<br>
   * <br>
   *     NOTE: If the component name is ambiguous, an exception is thrown. To<br>
   *     disambiguate, more information must be provided, such as the template<br>
   *     argument to specify the type and/or a path rather than just the name. 
   */
  public Component findComponent(ComponentPath pathToFind) {
    long cPtr = opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_findComponent__SWIG_2(swigCPtr, this, ComponentPath.getCPtr(pathToFind), pathToFind);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   *  Same as findComponent(const ComponentPath&amp;), but accepting a string (a<br>
   *     path or just a name) as input. 
   */
  public Component findComponent(String pathToFind) {
    long cPtr = opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_findComponent__SWIG_3(swigCPtr, this, pathToFind);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   * Get an iterator through the underlying subcomponents that this component is<br>
   * composed of. The hierarchy of Components/subComponents forms a tree.<br>
   * The order of the Components is that of tree preorder traversal so that a<br>
   * component is traversed before its subcomponents.<br>
   * <br>
   * {@code 
  for (const auto& muscle : model.getComponentList<Muscle>()) {
      muscle.get_max_isometric_force();
  }
  }<br>
   * <br>
   * The returned ComponentList does not permit modifying any components; if<br>
   * you want to modify the components, see updComponentList().<br>
   * <br>
   * 
   */
  public ComponentsList getComponentsList() {
    return new ComponentsList(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getComponentsList(swigCPtr, this), true);
  }

  /**
   *  End of conditional comment.<br>
   * Equality operator wrapper for use from languages not supporting operator<br>
   * overloading.
   */
  public boolean isEqualTo(OpenSimObject aObject) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_isEqualTo(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  /**
   *  Get the name of this Object. 
   */
  public String getName() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getName(swigCPtr, this);
  }

  /**
   *  Get description, a one-liner summary. 
   */
  public String getDescription() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getDescription(swigCPtr, this);
  }

  /**
   *  Get Authors of this Object 
   */
  public String getAuthors() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getAuthors(swigCPtr, this);
  }

  /**
   *  Get references or publications to cite if using this object. 
   */
  public String getReferences() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getReferences(swigCPtr, this);
  }

  /**
   * * Determine how many properties are stored with this %Object. These<br>
   *     are numbered 0..n-1 in the order they were created. *
   */
  public int getNumProperties() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getNumProperties(swigCPtr, this);
  }

  /**
   *  Get a const reference to a property by its index number, returned as<br>
   *     an AbstractProperty. *
   */
  public AbstractProperty getPropertyByIndex(int propertyIndex) {
    return new AbstractProperty(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPropertyByIndex(swigCPtr, this, propertyIndex), false);
  }

  /**
   *  Return true if this %Object has a property of any type with the <br>
   *     given <i>name</i>, which must not be empty. *
   */
  public boolean hasProperty(String name) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_hasProperty(swigCPtr, this, name);
  }

  /**
   *  Get a const reference to a property by its name, returned as<br>
   *     an AbstractProperty. An exception is thrown if no property by this name<br>
   *     is present in this %Object. *
   */
  public AbstractProperty getPropertyByName(String name) {
    return new AbstractProperty(opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getPropertyByName(swigCPtr, this, name), false);
  }

  /**
   *  Returns <code>true</code> if no property's value has changed since the last time<br>
   *     setObjectIsUpToDateWithProperties() was called. *
   */
  public boolean isObjectUpToDateWithProperties() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_isObjectUpToDateWithProperties(swigCPtr, this);
  }

  /**
   *  Serialize this object into the XML node that represents it.   <br>
   *     @param parent <br>
   *         Parent XML node of this object. Sending in a parent node allows an XML <br>
   *         node to be generated for this object if it doesn't already have one. If <br>
   *         no parent node is supplied and this object doesn't already have an XML <br>
   *         node, this object will become the root node for a new XML document. If <br>
   *         this object already has an XML node associated with it, no new nodes <br>
   *         are ever generated and the parent node is not used.<br>
   *     @param prop (optional)<br>
   *         The pointer to the property that contains this object. If it is<br>
   *         present, check if the property is unnamed and if NOT, use the property<br>
   *         name as its name when updating the XML node. *
   */
  public void updateXMLNode(SWIGTYPE_p_SimTK__Xml__Element parent, AbstractProperty prop) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_updateXMLNode__SWIG_0(swigCPtr, this, SWIGTYPE_p_SimTK__Xml__Element.getCPtr(parent), AbstractProperty.getCPtr(prop), prop);
  }

  /**
   *  Serialize this object into the XML node that represents it.   <br>
   *     @param parent <br>
   *         Parent XML node of this object. Sending in a parent node allows an XML <br>
   *         node to be generated for this object if it doesn't already have one. If <br>
   *         no parent node is supplied and this object doesn't already have an XML <br>
   *         node, this object will become the root node for a new XML document. If <br>
   *         this object already has an XML node associated with it, no new nodes <br>
   *         are ever generated and the parent node is not used.<br>
   *     
   */
  public void updateXMLNode(SWIGTYPE_p_SimTK__Xml__Element parent) {
    opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_updateXMLNode__SWIG_1(swigCPtr, this, SWIGTYPE_p_SimTK__Xml__Element.getCPtr(parent));
  }

  /**
   *  Inlined means an in-memory Object that is not associated with<br>
   *     an XMLDocument. *
   */
  public boolean getInlined() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getInlined(swigCPtr, this);
  }

  /**
   *  If there is a document associated with this object then return the<br>
   *     file name maintained by the document. Otherwise return an empty string. *
   */
  public String getDocumentFileName() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getDocumentFileName(swigCPtr, this);
  }

  /**
   *  If there is a document associated with this object then return its<br>
   *         version number. For example this is 30000 for OpenSim 3.x documents <br>
   *         and is 305xx for OpenSim 4.0 beta and above. If there is no document<br>
   *         associated with the object, the method returns -1.
   */
  public int getDocumentFileVersion() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_getDocumentFileVersion(swigCPtr, this);
  }

  /**
   *  Write this %Object into an XML file of the given name; conventionally<br>
   *     the suffix to use is ".osim". This is useful for writing out a Model that<br>
   *     has been created programmatically, and also very useful for testing and<br>
   *     debugging. If object has invalid connections, then printing is aborted.<br>
   *     You can override this behavior by setting the debug level to at least 1 <br>
   *     (e.g., Object::setDebugLevel(1)) prior to printing. *
   */
  public boolean print(String fileName) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_print(swigCPtr, this, fileName);
  }

  /**
   *  dump the XML representation of this %Object into an std::string and return it.<br>
   *     Mainly intended for debugging and for use by the XML browser in the GUI. *
   */
  public String dump() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_dump(swigCPtr, this);
  }

  /**
   *  The default implementation returns true only if the supplied string<br>
   *     is "Object"; each %Object-derived class overrides this to match its own<br>
   *     class name. *
   */
  public boolean isA(String type) {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_isA(swigCPtr, this, type);
  }

  /**
   *  Wrapper to be used on Java side to display objects in tree; this returns<br>
   *     just the object's name. *
   */
  public String toString() {
    return opensimSimulationJNI.Millard2012EquilibriumMuscleIterator_toString(swigCPtr, this);
  }

}
