/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  This is a smart pointer that implements "cross reference" semantics where<br>
 * a pointer data member of some object is intended to refer to some target<br>
 * object in a larger data structure. Judicious use of this container will allow<br>
 * you to use compiler-generated copy constructors and copy assignment operators<br>
 * for classes which would otherwise have to implement their own in order to<br>
 * properly initialize these pointer data members, which must not be copied.<br>
 * <br>
 * The contained pointer is initialized to `nullptr` on construction, and it is <br>
 * reinitialized to null upon copy construction or copy assignment. That's <br>
 * because we are assuming this is part of copying the entire data structure and <br>
 * copying the old pointer would create a reference into the old data structure <br>
 * rather than the new copy. This pointer does not own the target to which it <br>
 * points, and there is no reference counting so it will become stale if the <br>
 * target is deleted.<br>
 * <br>
 * The pointer *is* moved intact for move construction or move assignment. That<br>
 * allows `std::vector&lt;ReferencePtr<T&gt;&gt;` or `SimTK::Array_&lt;ReferencePtr<T&gt;&gt;` to<br>
 * behave properly when their contents have to be moved for expansion.<br>
 * <br>
 * Whether you can write through the pointer is controlled by whether type T<br>
 * is a const type. For example %ReferencePtr&lt;int&gt; is equivalent to an int*, while<br>
 * %ReferencePtr&lt;const int&gt; is equivalent to a const int*.<br>
 * <br>
 * This class is entirely inline and has no computational or space overhead; it<br>
 * contains just a single pointer. <br>
 * <br>
 * @see ClonePtr, CloneOnWritePtr *
 */
public class ReferencePtrCoordinate {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public ReferencePtrCoordinate(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(ReferencePtrCoordinate obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(ReferencePtrCoordinate obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimulationJNI.delete_ReferencePtrCoordinate(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   * * Default constructor creates an empty object. *
   */
  public ReferencePtrCoordinate() {
    this(opensimSimulationJNI.new_ReferencePtrCoordinate__SWIG_0(), true);
  }

  /**
   *  Constructor from `nullptr` is the same as the default constructor.<br>
   *     This is an implicit conversion that allows `nullptr` to be used to<br>
   *     initialize a %ReferencePtr. *
   */
  public ReferencePtrCoordinate(SWIGTYPE_p_std__nullptr_t arg0) {
    this(opensimSimulationJNI.new_ReferencePtrCoordinate__SWIG_1(SWIGTYPE_p_std__nullptr_t.getCPtr(arg0)), true);
  }

  /**
   *  Construct from a given pointer stores the pointer. *
   */
  public ReferencePtrCoordinate(Coordinate tp) {
    this(opensimSimulationJNI.new_ReferencePtrCoordinate__SWIG_2(Coordinate.getCPtr(tp), tp), true);
  }

  /**
   *  Copy constructor unconditionally sets the pointer to null; see class<br>
   *     comments for why. *
   */
  public ReferencePtrCoordinate(ReferencePtrCoordinate arg0) {
    this(opensimSimulationJNI.new_ReferencePtrCoordinate__SWIG_4(ReferencePtrCoordinate.getCPtr(arg0), arg0), true);
  }

  /**
   *  <b>(Deprecated)</b> Use %ReferencePtr(nullptr) or just %ReferencePtr()<br>
   *     instead. For backwards compatibility, this allows initialization <br>
   *     by "0" rather than `nullptr`. *
   */
  public ReferencePtrCoordinate(int mustBeZero) {
    this(opensimSimulationJNI.new_ReferencePtrCoordinate__SWIG_6(mustBeZero), true);
  }

  /**
   * ** Return the contained pointer, or null if the container is empty. *
   */
  public Coordinate get() {
    long cPtr = opensimSimulationJNI.ReferencePtrCoordinate_get(swigCPtr, this);
    return (cPtr == 0) ? null : new Coordinate(cPtr, false);
  }

  /**
   *  Return a reference to the target object. Fails if the pointer is<br>
   *     null. *
   */
  public Coordinate getRef() {
    return new Coordinate(opensimSimulationJNI.ReferencePtrCoordinate_getRef(swigCPtr, this), false);
  }

  /**
   *  Return the contained pointer. This will fail if the container is <br>
   *     empty. *
   */
  public Coordinate __deref__() {
    long cPtr = opensimSimulationJNI.ReferencePtrCoordinate___deref__(swigCPtr, this);
    return (cPtr == 0) ? null : new Coordinate(cPtr, false);
  }

  /**
   *  The "dereference" operator returns a reference to the target object. <br>
   *     This will fail if the container is empty. *
   */
  public Coordinate __ref__() {
    return new Coordinate(opensimSimulationJNI.ReferencePtrCoordinate___ref__(swigCPtr, this), false);
  }

  /**
   * ** Replace the stored pointer with a different one; no destruction<br>
   *     occurs. *
   */
  public void reset(Coordinate tp) {
    opensimSimulationJNI.ReferencePtrCoordinate_reset__SWIG_0(swigCPtr, this, Coordinate.getCPtr(tp), tp);
  }

  /**
   * ** Replace the stored pointer with a different one; no destruction<br>
   *     occurs. *
   */
  public void reset() {
    opensimSimulationJNI.ReferencePtrCoordinate_reset__SWIG_1(swigCPtr, this);
  }

  /**
   *  Swap the contents of this %ReferencePtr with another one. This is very<br>
   *     fast. *
   */
  public void swap(ReferencePtrCoordinate other) {
    opensimSimulationJNI.ReferencePtrCoordinate_swap(swigCPtr, this, ReferencePtrCoordinate.getCPtr(other), other);
  }

  /**
   *  Return true if this container is empty. *
   */
  public boolean empty() {
    return opensimSimulationJNI.ReferencePtrCoordinate_empty(swigCPtr, this);
  }

  /**
   *  Extract the pointer from this container, leaving the container empty. <br>
   *     The pointer is returned. *
   */
  public Coordinate release() {
    long cPtr = opensimSimulationJNI.ReferencePtrCoordinate_release(swigCPtr, this);
    return (cPtr == 0) ? null : new Coordinate(cPtr, false);
  }

  /**
   *  <b>(Deprecated)</b> Use reset() instead. *
   */
  public void clear() {
    opensimSimulationJNI.ReferencePtrCoordinate_clear(swigCPtr, this);
  }

  public OpenSimObject clone() {
    long cPtr = opensimSimulationJNI.ReferencePtrCoordinate_clone(swigCPtr, this);
    return (cPtr == 0) ? null : new Coordinate(cPtr, true);
  }

  public String getConcreteClassName() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getConcreteClassName(swigCPtr, this);
  }

  public double get_default_value(int i) {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_default_value__SWIG_0(swigCPtr, this, i);
  }

  public double get_default_value() {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_default_value__SWIG_1(swigCPtr, this);
  }

  public double get_default_speed_value(int i) {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_default_speed_value__SWIG_0(swigCPtr, this, i);
  }

  public double get_default_speed_value() {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_default_speed_value__SWIG_1(swigCPtr, this);
  }

  public double get_range(int i) {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_range(swigCPtr, this, i);
  }

  public boolean get_clamped(int i) {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_clamped__SWIG_0(swigCPtr, this, i);
  }

  public boolean get_clamped() {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_clamped__SWIG_1(swigCPtr, this);
  }

  public boolean get_locked(int i) {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_locked__SWIG_0(swigCPtr, this, i);
  }

  public boolean get_locked() {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_locked__SWIG_1(swigCPtr, this);
  }

  public Function get_prescribed_function(int i) {
    return new Function(opensimSimulationJNI.ReferencePtrCoordinate_get_prescribed_function__SWIG_0(swigCPtr, this, i), false);
  }

  public Function get_prescribed_function() {
    return new Function(opensimSimulationJNI.ReferencePtrCoordinate_get_prescribed_function__SWIG_1(swigCPtr, this), false);
  }

  public boolean get_prescribed(int i) {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_prescribed__SWIG_0(swigCPtr, this, i);
  }

  public boolean get_prescribed() {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_prescribed__SWIG_1(swigCPtr, this);
  }

  public boolean get_is_free_to_satisfy_constraints(int i) {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_is_free_to_satisfy_constraints__SWIG_0(swigCPtr, this, i);
  }

  public boolean get_is_free_to_satisfy_constraints() {
    return opensimSimulationJNI.ReferencePtrCoordinate_get_is_free_to_satisfy_constraints__SWIG_1(swigCPtr, this);
  }

  public boolean get_has_output_value() {
    return opensimSimulationJNI.ReferencePtrCoordinate__has_output_value_get(swigCPtr, this);
  }

  public boolean get_has_output_speed() {
    return opensimSimulationJNI.ReferencePtrCoordinate__has_output_speed_get(swigCPtr, this);
  }

  public boolean get_has_output_acceleration() {
    return opensimSimulationJNI.ReferencePtrCoordinate__has_output_acceleration_get(swigCPtr, this);
  }

  /**
   * * access to the Coordinate's owning joint 
   */
  public Joint getJoint() {
    return new Joint(opensimSimulationJNI.ReferencePtrCoordinate_getJoint(swigCPtr, this), false);
  }

  /**
   *  access to the generalized Coordinate's motion type<br>
   *         This can be Rotational, Translational, or Coupled (both) 
   */
  public Coordinate.MotionType getMotionType() {
    return Coordinate.MotionType.swigToEnum(opensimSimulationJNI.ReferencePtrCoordinate_getMotionType(swigCPtr, this));
  }

  /**
   *  get the value of the Coordinate from the state 
   */
  public double getValue(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getValue(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Set the value of the Coordinate on to the state.<br>
   *         Optional flag to enforce the constraints immediately (true by default),<br>
   *         which can adjust all coordinate values in the state to satisfy model<br>
   *         constraints. Use getValue(s) to see if/how the value was adjusted to<br>
   *         satisfy the kinematic constraints. If setting multiple Coordinate values<br>
   *         consecutively, e.g. in a loop, set the flag to false and then call<br>
   *         Model::assemble(state) once all Coordinate values have been set.<br>
   *         Alternatively, use Model::setStateVariableValues() to set all coordinate<br>
   *         values and their speeds at once followed by Model::assemble(state).<br>
   * <br>
   *         The provided value will be clamped to the coordinate's range if<br>
   *         the coordinate is clamped and enforceConstraints is true.
   */
  public void setValue(State s, double aValue, boolean enforceContraints) {
    opensimSimulationJNI.ReferencePtrCoordinate_setValue__SWIG_0(swigCPtr, this, State.getCPtr(s), s, aValue, enforceContraints);
  }

  /**
   *  Set the value of the Coordinate on to the state.<br>
   *         Optional flag to enforce the constraints immediately (true by default),<br>
   *         which can adjust all coordinate values in the state to satisfy model<br>
   *         constraints. Use getValue(s) to see if/how the value was adjusted to<br>
   *         satisfy the kinematic constraints. If setting multiple Coordinate values<br>
   *         consecutively, e.g. in a loop, set the flag to false and then call<br>
   *         Model::assemble(state) once all Coordinate values have been set.<br>
   *         Alternatively, use Model::setStateVariableValues() to set all coordinate<br>
   *         values and their speeds at once followed by Model::assemble(state).<br>
   * <br>
   *         The provided value will be clamped to the coordinate's range if<br>
   *         the coordinate is clamped and enforceConstraints is true.
   */
  public void setValue(State s, double aValue) {
    opensimSimulationJNI.ReferencePtrCoordinate_setValue__SWIG_1(swigCPtr, this, State.getCPtr(s), s, aValue);
  }

  /**
   *  get the speed value of the Coordinate from the state 
   */
  public double getSpeedValue(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getSpeedValue(swigCPtr, this, State.getCPtr(s), s);
  }

  public void setSpeedValue(State s, double aValue) {
    opensimSimulationJNI.ReferencePtrCoordinate_setSpeedValue(swigCPtr, this, State.getCPtr(s), s, aValue);
  }

  /**
   *  return the name (label) used to identify the Coordinate's speed<br>
   *         state variable. Returns the string "<coordinate_name>/speed" 
   */
  public String getSpeedName() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getSpeedName(swigCPtr, this);
  }

  /**
   *  get the derivative of Coordinate's value from the state. This value is<br>
   * not* necessarily equal to the value returned by getSpeedValue(). 
   */
  public double getQDotValue(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getQDotValue(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  get the default value for this coordinate. This is the value <br>
   *         used if no value has been set prior to a simulation. 
   */
  public double getDefaultValue() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDefaultValue(swigCPtr, this);
  }

  /**
   *  get the default speed value for this coordinate. This is the value <br>
   *         used if no value has been set prior to a simulation. 
   */
  public double getDefaultSpeedValue() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDefaultSpeedValue(swigCPtr, this);
  }

  /**
   *  get acceleration of the coordinate is dependent on having <br>
   *         realized the model and state to the acceleration stage 
   */
  public double getAccelerationValue(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getAccelerationValue(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  determine or set whether or not the Coordinate is <br>
   *         "clamped" between a range of values. 
   */
  public boolean getClamped(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getClamped(swigCPtr, this, State.getCPtr(s), s);
  }

  public void setClamped(State s, boolean aClamped) {
    opensimSimulationJNI.ReferencePtrCoordinate_setClamped(swigCPtr, this, State.getCPtr(s), s, aClamped);
  }

  /**
   *  get/set whether or not the Coordinate is clamped by default 
   */
  public boolean getDefaultClamped() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDefaultClamped(swigCPtr, this);
  }

  /**
   *  get the value for the Coordinate's range of motion 
   */
  public double getRangeMin() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getRangeMin(swigCPtr, this);
  }

  public double getRangeMax() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getRangeMax(swigCPtr, this);
  }

  /**
   *  determine or set whether or not the Coordinate is <br>
   *         "locked" for a given state of the Model. 
   */
  public boolean getLocked(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getLocked(swigCPtr, this, State.getCPtr(s), s);
  }

  public void setLocked(State s, boolean aLocked) {
    opensimSimulationJNI.ReferencePtrCoordinate_setLocked(swigCPtr, this, State.getCPtr(s), s, aLocked);
  }

  /**
   *  get/set whether or not the Coordinate is locked by default 
   */
  public boolean getDefaultLocked() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDefaultLocked(swigCPtr, this);
  }

  /**
   *  determine or set whether or not the Coordinate is <br>
   *         "prescribed" for a given state of the Model. 
   */
  public boolean isPrescribed(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_isPrescribed(swigCPtr, this, State.getCPtr(s), s);
  }

  public void setIsPrescribed(State s, boolean isPrescribed) {
    opensimSimulationJNI.ReferencePtrCoordinate_setIsPrescribed(swigCPtr, this, State.getCPtr(s), s, isPrescribed);
  }

  /**
   *  get/set whether or not the Coordinate is locked by default 
   */
  public boolean getDefaultIsPrescribed() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDefaultIsPrescribed(swigCPtr, this);
  }

  public Function getPrescribedFunction() {
    return new Function(opensimSimulationJNI.ReferencePtrCoordinate_getPrescribedFunction(swigCPtr, this), false);
  }

  /**
   *  Return true if coordinate is dependent on other coordinates via a coupler<br>
   *         constraint OR it has been flagged as free to change when satisfying <br>
   *         the model's kinematic constraints in general. 
   */
  public boolean isDependent(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_isDependent(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   *  Return true if coordinate is locked, prescribed, or dependent on other coordinates 
   */
  public boolean isConstrained(State s) {
    return opensimSimulationJNI.ReferencePtrCoordinate_isConstrained(swigCPtr, this, State.getCPtr(s), s);
  }

  /**
   * *
   */
  public int getMobilizerQIndex() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getMobilizerQIndex(swigCPtr, this);
  }

  public int getBodyIndex() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getBodyIndex(swigCPtr, this);
  }

  /**
   * *
   */
  public Coordinate.MotionType getUserSpecifiedMotionTypePriorTo40() {
    return Coordinate.MotionType.swigToEnum(opensimSimulationJNI.ReferencePtrCoordinate_getUserSpecifiedMotionTypePriorTo40(swigCPtr, this));
  }

  /**
   *  Get a const reference to the Model this component is part of. 
   */
  public Model getModel() {
    return new Model(opensimSimulationJNI.ReferencePtrCoordinate_getModel(swigCPtr, this), false);
  }

  /**
   *  Does this ModelComponent have a Model associated with it? 
   */
  public boolean hasModel() {
    return opensimSimulationJNI.ReferencePtrCoordinate_hasModel(swigCPtr, this);
  }

  /**
   *  Have the Component add itself to the underlying computational System 
   */
  public void addToSystem(SWIGTYPE_p_SimTK__MultibodySystem system) {
    opensimSimulationJNI.ReferencePtrCoordinate_addToSystem(swigCPtr, this, SWIGTYPE_p_SimTK__MultibodySystem.getCPtr(system));
  }

  /**
   *  Initialize Component's state variable values from its properties 
   */
  public void initStateFromProperties(State state) {
    opensimSimulationJNI.ReferencePtrCoordinate_initStateFromProperties(swigCPtr, this, State.getCPtr(state), state);
  }

  /**
   * Optional method for generating arbitrary display geometry that reflects<br>
   *     this %Component at the specified <i>state</i>. This will be called once to<br>
   *     obtain ground- and body-fixed geometry (with <i>fixed=</i><code>true)</code>, and then<br>
   *     once per frame (with <i>fixed=</i><code>false)</code> to generate on-the-fly geometry such<br>
   *     as rubber band lines, force arrows, labels, or debugging aids.<br>
   * <br>
   *     Please note that there is a precondition that the state passed in to<br>
   *     generateDecorations be realized to Stage::Position. If your component can<br>
   *     visualize quantities realized at Velocity, Dynamics or Acceleration stages,<br>
   *     then you must check that the stage has been realized before using/requesting<br>
   *     stage dependent values. It is forbidden to realize the model to a higher<br>
   *     stage within generateDecorations, because this can trigger costly side-<br>
   *     effects such as evaluating all model forces even when performing a purely<br>
   *     kinematic study.<br>
   * <br>
   *     If you override this method, be sure to invoke the base class method first,<br>
   *     using code like this:<br>
   *     {@code 
      void MyComponent::generateDecorations
         (bool                                        fixed,
          const ModelDisplayHints&                    hints,
          const SimTK::State&                         state,
          SimTK::Array_<SimTK::DecorativeGeometry>&   appendToThis) const
      {
  invoke parent class method
          Super::generateDecorations(fixed,hints,state,appendToThis);
  ... your code goes here
  can render velocity dependent quanities if stage is Velocity or higher
          if(state.getSystemStage() >= Stage::Velocity) {
  draw velocity vector for model COM
          }
  can render computed forces if stage is Dynamics or higher
          if(state.getSystemStage() >= Stage::Dynamics) {
  change the length of a force arrow based on the force in N
          }
      }
      }<br>
   * <br>
   *     @param fixed<br>
   *         If <code>true</code>, generate only geometry that is fixed to a PhysicalFrame,<br>
   *         configuration, and velocity. Otherwise generate only such dependent<br>
   *         geometry.<br>
   *     @param hints<br>
   *         See documentation for ModelDisplayHints; you may want to alter the<br>
   *         geometry you generate depending on what you find there. For example,<br>
   *         you can determine whether the user wants to see debug geometry.<br>
   *     @param state<br>
   *         The State for which geometry should be produced. See below for more<br>
   *         information.<br>
   *     @param appendToThis<br>
   *         %Array to which generated geometry should be <i>appended</i> via the<br>
   *         <code>push_back()</code> method.<br>
   * <br>
   *     When called with <i>fixed=</i><code>true</code> only modeling options and parameters<br>
   *     (Instance variables) should affect geometry; time, position, and velocity<br>
   *     should not. In that case OpenSim will already have realized the <i>state</i><br>
   *     through Instance stage. When called with <i>fixed=</i><code>false</code>, you may<br>
   *     consult any relevant value in <i>state</i>. However, to avoid unnecessary<br>
   *     computation, OpenSim guarantees only that <i>state</i> will have been realized<br>
   *     through Position stage; if you need anything higher than that (reaction<br>
   *     forces, for example) you should make sure the <i>state</i> is realized through<br>
   *     Acceleration stage. *
   */
  public void generateDecorations(boolean fixed, ModelDisplayHints hints, State state, ArrayDecorativeGeometry appendToThis) {
    opensimSimulationJNI.ReferencePtrCoordinate_generateDecorations(swigCPtr, this, fixed, ModelDisplayHints.getCPtr(hints), hints, State.getCPtr(state), state, ArrayDecorativeGeometry.getCPtr(appendToThis), appendToThis);
  }

  /**
   * Get the underlying MultibodySystem that this component is connected to.<br>
   * Make sure you have called Model::initSystem() prior to accessing the System.<br>
   * Throws an Exception if the System has not been created or the Component<br>
   * has not added itself to the System.<br>
   * @see hasSystem().  
   */
  public SWIGTYPE_p_SimTK__MultibodySystem getSystem() {
    return new SWIGTYPE_p_SimTK__MultibodySystem(opensimSimulationJNI.ReferencePtrCoordinate_getSystem(swigCPtr, this), false);
  }

  /**
   * Check if this component has an underlying MultibodySystem.<br>
   * Returns false if the System has not been created OR if this<br>
   * Component has not added itself to the System.  
   */
  public boolean hasSystem() {
    return opensimSimulationJNI.ReferencePtrCoordinate_hasSystem(swigCPtr, this);
  }

  /**
   *  Does the provided component already exist anywhere in the ownership<br>
   * tree (not just subcomponents of this component)? 
   */
  public boolean isComponentInOwnershipTree(Component component) {
    return opensimSimulationJNI.ReferencePtrCoordinate_isComponentInOwnershipTree(swigCPtr, this, Component.getCPtr(component), component);
  }

  /**
   *  Get the complete (absolute) pathname for this Component to its ancestral<br>
   * Component, which is the root of the tree to which this Component belongs.<br>
   * For example: a Coordinate Component would have an absolute path name<br>
   * like: `/arm26/elbow_r/flexion`. Accessing a Component by its<br>
   * absolutePathName from root is guaranteed to be unique. The<br>
   * absolutePathName is generated on-the-fly by traversing the ownership tree<br>
   * and, therefore, calling this method is not "free". 
   */
  public String getAbsolutePathString() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getAbsolutePathString(swigCPtr, this);
  }

  /**
   *  Return a ComponentPath of the absolute path of this Component.<br>
   * Note that this has more overhead than calling `getName()` because<br>
   * it traverses up the tree to generate the absolute pathname (and its<br>
   * computational cost is thus a function of depth). Consider other<br>
   * options if this is repeatedly called and efficiency is important.<br>
   * For instance, `getAbsolutePathString()` is faster if you only<br>
   * need the path as a string. 
   */
  public ComponentPath getAbsolutePath() {
    return new ComponentPath(opensimSimulationJNI.ReferencePtrCoordinate_getAbsolutePath(swigCPtr, this), true);
  }

  /**
   *  Get the relative path of this Component with respect to another<br>
   * Component, as a string. 
   */
  public String getRelativePathString(Component wrt) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getRelativePathString(swigCPtr, this, Component.getCPtr(wrt), wrt);
  }

  /**
   *  Get the relative path of this Component with respect to another<br>
   * Component. 
   */
  public ComponentPath getRelativePath(Component wrt) {
    return new ComponentPath(opensimSimulationJNI.ReferencePtrCoordinate_getRelativePath(swigCPtr, this, Component.getCPtr(wrt), wrt), true);
  }

  /**
   *  Query if there is a component (of any type) at the specified<br>
   * path name. For example,<br>
   * {@code 
  bool exists = model.hasComponent("right_elbow/elbow_flexion");
  }<br>
   * checks if `model` has a subcomponent "right_elbow," which has a<br>
   * subcomponent "elbow_flexion." 
   */
  public boolean hasComponent(String pathname) {
    return opensimSimulationJNI.ReferencePtrCoordinate_hasComponent(swigCPtr, this, pathname);
  }

  /**
   *  Similar to the templatized getComponent(), except this returns the<br>
   * component as the generic Component type. This can be used in<br>
   * Python/Java/MATLAB. Here is an example of using this in MATLAB:<br>
   * {@code 
  coord = model.getComponent('right_elbow/elbow_flexion')
  coord.getNumConnectees() % okay; this is a Component method.
  coord.getDefaultClamped() % inaccessible; method on Coordinate.
  Coordinate.safeDownCast(coord).getDefaultClamped() % now accessible.
  }<br>
   * <br>
   * %Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  coord = model.getComponent('right_elbow/elbow_flexion')
  coord.getDefaultClamped() # works; no downcasting necessary.
  }
   */
  public Component getComponent(String pathname) {
    return new Component(opensimSimulationJNI.ReferencePtrCoordinate_getComponent(swigCPtr, this, pathname), false);
  }

  /**
   *  Print a list to the console of all components whose absolute path name<br>
   * contains the given string. You might use this if (a) you know the name<br>
   * of a component in your model but don't know its absolute path, (b) if<br>
   * you want to find all components with a given name, or (c) to get a list<br>
   * of all components on the right leg of a model (if all components on the<br>
   * right side have "_r" in their name).<br>
   * <br>
   * A function call like:<br>
   * {@code 
  unsigned num = comp.printComponentsMatching("rotation");
  }<br>
   * may produce output like:<br>
   * {@literal 
  /leg_model/right_hip/rotation
  /leg_model/left_hip/rotation
  }<br>
   * <br>
   * @return The number of matches. 
   */
  public long printComponentsMatching(String substring) {
    return opensimSimulationJNI.ReferencePtrCoordinate_printComponentsMatching(swigCPtr, this, substring);
  }

  /**
   * Get the number of "continuous" state variables maintained by the<br>
   * Component and its subcomponents.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public int getNumStateVariables() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getNumStateVariables(swigCPtr, this);
  }

  /**
   * Get the names of "continuous" state variables maintained by the Component<br>
   * and its subcomponents.<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public ArrayStr getStateVariableNames() {
    return new ArrayStr(opensimSimulationJNI.ReferencePtrCoordinate_getStateVariableNames(swigCPtr, this), true);
  }

  /**
   *  Get the number of Sockets in this Component. 
   */
  public int getNumSockets() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getNumSockets(swigCPtr, this);
  }

  /**
   *  Collect and return the names of the sockets in this component. You<br>
   * can use this to iterate through the sockets:<br>
   * {@code 
  for (std::string name : comp.getSocketNames()) {
      const AbstractSocket& socket = getSocket(name);
  }
  } 
   */
  public StdVectorString getSocketNames() {
    return new StdVectorString(opensimSimulationJNI.ReferencePtrCoordinate_getSocketNames(swigCPtr, this), true);
  }

  /**
   *  Get the connectee as an Object. This means you will not have<br>
   * access to the methods on the concrete connectee. This is the method you<br>
   * must use in MATLAB to access the connectee.<br>
   * <br>
   * Example:<br>
   * {@code 
  const Object& obj = joint.getConnectee("parent_frame");
  obj.getName(); // method on Object works.
  obj.getMobilizedBody(); // error: not available.
  }<br>
   * <br>
   * In MATLAB, if you want the concrete type, you need to downcast the<br>
   * Object. Here is an example where you know the "parent_frame" is a Body:<br>
   * {@code 
  f = joint.getConnectee('parent_frame');
  m = Body.safeDownCast(f).getMass();
  }<br>
   * <br>
   * Exception: in Python, you will get the concrete type (in most cases):<br>
   * {@code 
  f = joint.getConnectee("parent_frame");
  m = f.getMass() # works (if the parent frame is a body)
  }
   */
  public OpenSimObject getConnectee(String name) {
    return new OpenSimObject(opensimSimulationJNI.ReferencePtrCoordinate_getConnectee(swigCPtr, this, name), false);
  }

  public AbstractSocket getSocket(String name) {
    return new AbstractSocket(opensimSimulationJNI.ReferencePtrCoordinate_getSocket(swigCPtr, this, name), false);
  }

  /**
   *  Access the number of Inputs that this component has. 
   */
  public int getNumInputs() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getNumInputs(swigCPtr, this);
  }

  /**
   *  Access the number of Outputs that this component has. 
   */
  public int getNumOutputs() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getNumOutputs(swigCPtr, this);
  }

  /**
   *  Collect and return the names of Inputs in this component as an<br>
   * std::vector. 
   */
  public StdVectorString getInputNames() {
    return new StdVectorString(opensimSimulationJNI.ReferencePtrCoordinate_getInputNames(swigCPtr, this), true);
  }

  /**
   *  Collect and return the names of Outputs in this component as an<br>
   * std::vector. 
   */
  public StdVectorString getOutputNames() {
    return new StdVectorString(opensimSimulationJNI.ReferencePtrCoordinate_getOutputNames(swigCPtr, this), true);
  }

  /**
   * Get an Input provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get an Input from a Component in the model<br>
   * {@code 
  model.getComponent("/path/to/component").getInput("inputName");
  }<br>
   * <br>
   * If you have not yet called finalizeFromProperties() on this<br>
   * component, this function will update the Input (to tell it which<br>
   * component it's in) before providing it to you.<br>
   * <br>
   * @param name   the name of the Input<br>
   * @return const reference to the AbstractInput
   */
  public AbstractInput getInput(String name) {
    return new AbstractInput(opensimSimulationJNI.ReferencePtrCoordinate_getInput(swigCPtr, this, name), false);
  }

  /**
   * Get the Output provided by this Component by name.<br>
   * <br>
   * <b>C++ example:</b> get an Output from a Component in a model<br>
   * {@code 
  model.getComponent("/path/to/component").getOutput("outputName");
  }<br>
   * <br>
   * @param name   the name of the Output<br>
   * @return const reference to the AbstractOutput
   */
  public AbstractOutput getOutput(String name) {
    return new AbstractOutput(opensimSimulationJNI.ReferencePtrCoordinate_getOutput(swigCPtr, this, name), false);
  }

  /**
   * Get a ModelingOption flag for this Component by name.<br>
   * The flag is an integer corresponding to the index of modelingOptionNames used<br>
   * add the modeling option to the component. @see addModelingOption<br>
   * <br>
   * @param state  the State in which to set the modeling option<br>
   * @param name   the name (string) of the modeling option of interest<br>
   * @return flag  integer value for modeling option
   */
  public int getModelingOption(State state, String name) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getModelingOption(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * %Set the value of a ModelingOption flag for this Component.<br>
   * if the integer value exceeds the number of option names used to<br>
   * define the options, an exception is thrown. The SimTK::State<br>
   * Stage will be reverted back to Stage::Instance.<br>
   * <br>
   * @param state  the State in which to set the flag<br>
   * @param name   the name (string) of the modeling option of interest<br>
   * @param flag   the desired flag (int) value specifying the modeling option
   */
  public void setModelingOption(State state, String name, int flag) {
    opensimSimulationJNI.ReferencePtrCoordinate_setModelingOption(swigCPtr, this, State.getCPtr(state), state, name, flag);
  }

  /**
   * Get the value of a state variable allocated by this Component.<br>
   * <br>
   * To connect this StateVariable as an input to another component (such as<br>
   * a Reporter), use getOutput(name); each state variable has a<br>
   * corresponding Output:<br>
   *  {@code 
   foo.getInput("input1").connect(bar.getOutput(name));
   }<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @param name    the name (string) of the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableValue(State state, String name) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getStateVariableValue__SWIG_0(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Get the value of a state variable allocated by this Component.<br>
   * <br>
   * To connect this StateVariable as an input to another component (such as<br>
   * a Reporter), use getOutput(name); each state variable has a<br>
   * corresponding Output:<br>
   * <br>
   *  {@code 
   foo.getInput("input1").connect(bar.getOutput(name));
   }<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * <br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableValue(State state, ComponentPath path) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getStateVariableValue__SWIG_1(swigCPtr, this, State.getCPtr(state), state, ComponentPath.getCPtr(path), path);
  }

  /**
   * %Set the value of a state variable allocated by this Component by name.<br>
   * <br>
   * @param state  the State for which to set the value<br>
   * @param name   the name of the state variable<br>
   * @param value  the value to set<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setStateVariableValue(State state, String name, double value) {
    opensimSimulationJNI.ReferencePtrCoordinate_setStateVariableValue(swigCPtr, this, State.getCPtr(state), state, name, value);
  }

  /**
   * Get all values of the state variables allocated by this Component.<br>
   * Includes state variables allocated by its subcomponents.<br>
   * <br>
   * @param state   the State for which to get the value<br>
   * @return Vector of state variable values of length getNumStateVariables()<br>
   *                in the order returned by getStateVariableNames()<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public Vector getStateVariableValues(State state) {
    return new Vector(opensimSimulationJNI.ReferencePtrCoordinate_getStateVariableValues(swigCPtr, this, State.getCPtr(state), state), true);
  }

  /**
   * %Set all values of the state variables allocated by this Component.<br>
   * Includes state variables allocated by its subcomponents. Note, this<br>
   * method simply sets the values on the input State. If other conditions<br>
   * must be met (such as satisfying kinematic constraints for Coordinates,<br>
   * or fiber and tendon equilibrium for muscles) you must invoke the<br>
   * appropriate methods on Model (e.g. assemble() to satisfy constraints or<br>
   * equilibrateMuscles()) to satisfy these conditions starting from the<br>
   * State values provided by setStateVariableValues.<br>
   * <br>
   * @param state   the State whose values are set<br>
   * @param values  Vector of state variable values of length<br>
   *                getNumStateVariables() in the order returned by<br>
   *                getStateVariableNames()<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setStateVariableValues(State state, Vector values) {
    opensimSimulationJNI.ReferencePtrCoordinate_setStateVariableValues(swigCPtr, this, State.getCPtr(state), state, Vector.getCPtr(values), values);
  }

  /**
   * Get the value of a state variable derivative computed by this Component.<br>
   * <br>
   * @param state   the State for which to get the derivative value<br>
   * @param name    the name (string) of the state variable of interest<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getStateVariableDerivativeValue(State state, String name) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getStateVariableDerivativeValue(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Get the value of a discrete variable allocated by this Component by name.<br>
   * <br>
   * @param state   the State from which to get the value<br>
   * @param name    the name of the state variable<br>
   * @return value  the discrete variable value<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public double getDiscreteVariableValue(State state, String name) {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDiscreteVariableValue(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * %Set the value of a discrete variable allocated by this Component by name.<br>
   * <br>
   * @param state  the State for which to set the value<br>
   * @param name   the name of the discrete variable<br>
   * @param value  the value to set<br>
   * @throws ComponentHasNoSystem if this Component has not been added to a<br>
   *         System (i.e., if initSystem has not been called)
   */
  public void setDiscreteVariableValue(State state, String name, double value) {
    opensimSimulationJNI.ReferencePtrCoordinate_setDiscreteVariableValue(swigCPtr, this, State.getCPtr(state), state, name, value);
  }

  /**
   * Get the index of a Component's cache variable in the Subsystem for allocations.<br>
   * <br>
   * <br>
   * @param name<br>
   *   Name of the cache variable, as provided to Component::addCacheVariable<br>
   * @return <br>
   *   A valid SimTK::CacheEntryIndex, which callers can use with simbody methods<br>
   *   (e.g. markCacheValueRealized)
   */
  public SWIGTYPE_p_SimTK__CacheEntryIndex getCacheVariableIndex(String name) {
    return new SWIGTYPE_p_SimTK__CacheEntryIndex(opensimSimulationJNI.ReferencePtrCoordinate_getCacheVariableIndex(swigCPtr, this, name), true);
  }

  /**
   * Returns true if the cache variable, identified by `name`, is valid.<br>
   * <br>
   * This method enables callers to monitor the validity of the cache variable,<br>
   * which enables the caller to decide whether to update the cache variable's<br>
   * value (or not). When computing an update is costly, use this method to check<br>
   * whether computing the value is necessary.<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @return bool<br>
   *     whether the cache variable's value is valid or not<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public boolean isCacheVariableValid(State state, String name) {
    return opensimSimulationJNI.ReferencePtrCoordinate_isCacheVariableValid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Marks the value of a cache variable, identified by `name`, as valid.<br>
   * <br>
   * Upon marking a cache variable's value as valid, the cache variable will remain<br>
   * valid until either:<br>
   * <br>
   * - the realization stage falls below the minimum realization stage set<br>
   *   when the cache variable was initialized with `Component::addCacheVariable`<br>
   * <br>
   * - the cache variable is explicitly invalidated by calling<br>
   *   `Component::markCacheVariableInvalid`<br>
   * <br>
   * This method causes `Component::isCacheVariableValid` to return true.<br>
   * `Component::isCacheVariableValid` is commonly used by value-getting<br>
   * methods to decide on whether to return the value as-is or recompute the<br>
   * value. Therefore, if a cache variable is not marked as valid then the<br>
   * cache variable's value may be recomputed more than necessary, which may<br>
   * be costly.<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public void markCacheVariableValid(State state, String name) {
    opensimSimulationJNI.ReferencePtrCoordinate_markCacheVariableValid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   * Marks the value of a cache variable, identified by `name`, as invalid.<br>
   * <br>
   * Upon marking a cache variable's value as invalid, it will remain invalid<br>
   * until `Component::markCacheVariableValid` is called (or a method which<br>
   * uses that, such as `Component::setCacheVariableValue`, is called).<br>
   * <br>
   * - Cache variables are automatically marked as invalid when the realization stage<br>
   *   falls below the minimum realization stage set when the cache variable was<br>
   *   initialized with `Component::addCacheVariable`.<br>
   * <br>
   * - Cache variables *may* be indirectly marked as invalid by other methods. For<br>
   *   example, a component-added state variable may invalidate a cache variable at<br>
   *   a lower stage. Concretely:<br>
   * <br>
   *   - A (hypothetical) component has a `length` state variable<br>
   *   - There are cache variables that are computed from `length` (e.g.<br>
   *   `strain`)<br>
   *   - So changing the `length` may invalidate the `strain` indirectly<br>
   *     (depending on how the state variable is handled)<br>
   * <br>
   * @param state<br>
   *     the State in which the cache variable's value resides<br>
   * @param name<br>
   *     the name of the cache variable<br>
   * @throws ComponentHasNoSystem<br>
   *     if this Component has not been added to a System (i.e., if initSystem has not been called)
   */
  public void markCacheVariableInvalid(State state, String name) {
    opensimSimulationJNI.ReferencePtrCoordinate_markCacheVariableInvalid(swigCPtr, this, State.getCPtr(state), state, name);
  }

  /**
   *  List all subcomponents by name and recurse into these components to<br>
   *     list their subcomponents, and so on.                                      
   */
  public void printSubcomponentInfo() {
    opensimSimulationJNI.ReferencePtrCoordinate_printSubcomponentInfo(swigCPtr, this);
  }

  /**
   *  List all the Sockets of this component and whether or not they are<br>
   *     connected. Also list the connectee paths for sockets that are connected. 
   */
  public void printSocketInfo() {
    opensimSimulationJNI.ReferencePtrCoordinate_printSocketInfo(swigCPtr, this);
  }

  /**
   *  List all the inputs of this component and whether or not they are<br>
   *     connected. Also list the (desired) connectee paths for the inputs.       
   */
  public void printInputInfo() {
    opensimSimulationJNI.ReferencePtrCoordinate_printInputInfo(swigCPtr, this);
  }

  /**
   *  Print outputs of this component and optionally, those of all<br>
   *     subcomponents.                                                            
   */
  public void printOutputInfo(boolean includeDescendants) {
    opensimSimulationJNI.ReferencePtrCoordinate_printOutputInfo__SWIG_0(swigCPtr, this, includeDescendants);
  }

  /**
   *  Print outputs of this component and optionally, those of all<br>
   *     subcomponents.                                                            
   */
  public void printOutputInfo() {
    opensimSimulationJNI.ReferencePtrCoordinate_printOutputInfo__SWIG_1(swigCPtr, this);
  }

  /**
   *  Access the owner of this Component.<br>
   * An exception is thrown if the %Component has no owner; in this case, the<br>
   * component is the root component, or is orphaned.<br>
   * @see hasOwner() 
   */
  public Component getOwner() {
    return new Component(opensimSimulationJNI.ReferencePtrCoordinate_getOwner(swigCPtr, this), false);
  }

  /**
   *  (For advanced users) Check if this %Component has an owner.<br>
   * A component may not have an owner if it:<br>
   * (1) is the root component, or<br>
   * (2) has not been added to another component 
   */
  public boolean hasOwner() {
    return opensimSimulationJNI.ReferencePtrCoordinate_hasOwner(swigCPtr, this);
  }

  /**
   *  Obtain the root %Component, which is this component if it is orphaned.
   */
  public Component getRoot() {
    return new Component(opensimSimulationJNI.ReferencePtrCoordinate_getRoot(swigCPtr, this), false);
  }

  /**
   *  Find a Component to which this Component is an ancestor---in other<br>
   *     words, a Component that is directly owned by this Component or is owned<br>
   *     by one of its sub-components, sub-sub-components, etc. The Component can<br>
   *     be found by type (by specifying a template argument) and either path or<br>
   *     name.<br>
   * <br>
   *     Here is an example of searching for a component of any type with the name<br>
   *     'elbow_flexion':<br>
   *     {@code 
      if (const Component* found =
              model.findComponent(ComponentPath("elbow_flexion"))) {
          std::cout << found.getName() << std::endl;
      }
      }<br>
   * <br>
   *     Here, we require that 'elbow_flexion' is of type Coordinate.<br>
   *     {@code 
      if (const Coordinate* found =
              model.findComponent<Coordinate>(ComponentPath("elbow_flexion"))) {
          std::cout << "Coordinate " << found.getName() << std::endl;
      }
      }<br>
   * <br>
   *     The search can be sped up considerably if the path or even partial path<br>
   *     name is known. For example, "forearm/elbow/elbow_flexion" will find<br>
   *     the Coordinate component of the elbow joint that connects the forearm body<br>
   *     in linear time (linear search for name at each component level). Whereas<br>
   *     supplying "elbow_flexion" requires a tree search. Returns nullptr (None in<br>
   *     Python, empty array in Matlab) if Component of that specified name cannot<br>
   *     be found.<br>
   * <br>
   *     NOTE: If the component name is ambiguous, an exception is thrown. To<br>
   *     disambiguate, more information must be provided, such as the template<br>
   *     argument to specify the type and/or a path rather than just the name. 
   */
  public Component findComponent(ComponentPath pathToFind) {
    long cPtr = opensimSimulationJNI.ReferencePtrCoordinate_findComponent__SWIG_2(swigCPtr, this, ComponentPath.getCPtr(pathToFind), pathToFind);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   *  Same as findComponent(const ComponentPath&amp;), but accepting a string (a<br>
   *     path or just a name) as input. 
   */
  public Component findComponent(String pathToFind) {
    long cPtr = opensimSimulationJNI.ReferencePtrCoordinate_findComponent__SWIG_3(swigCPtr, this, pathToFind);
    return (cPtr == 0) ? null : new Component(cPtr, false);
  }

  /**
   * Get an iterator through the underlying subcomponents that this component is<br>
   * composed of. The hierarchy of Components/subComponents forms a tree.<br>
   * The order of the Components is that of tree preorder traversal so that a<br>
   * component is traversed before its subcomponents.<br>
   * <br>
   * {@code 
  for (const auto& muscle : model.getComponentList<Muscle>()) {
      muscle.get_max_isometric_force();
  }
  }<br>
   * <br>
   * The returned ComponentList does not permit modifying any components; if<br>
   * you want to modify the components, see updComponentList().<br>
   * <br>
   * 
   */
  public ComponentsList getComponentsList() {
    return new ComponentsList(opensimSimulationJNI.ReferencePtrCoordinate_getComponentsList(swigCPtr, this), true);
  }

  /**
   *  End of conditional comment.<br>
   * Equality operator wrapper for use from languages not supporting operator<br>
   * overloading.
   */
  public boolean isEqualTo(OpenSimObject aObject) {
    return opensimSimulationJNI.ReferencePtrCoordinate_isEqualTo(swigCPtr, this, OpenSimObject.getCPtr(aObject), aObject);
  }

  /**
   *  Get the name of this Object. 
   */
  public String getName() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getName(swigCPtr, this);
  }

  /**
   *  Get description, a one-liner summary. 
   */
  public String getDescription() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDescription(swigCPtr, this);
  }

  /**
   *  Get Authors of this Object 
   */
  public String getAuthors() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getAuthors(swigCPtr, this);
  }

  /**
   *  Get references or publications to cite if using this object. 
   */
  public String getReferences() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getReferences(swigCPtr, this);
  }

  /**
   * * Determine how many properties are stored with this %Object. These<br>
   *     are numbered 0..n-1 in the order they were created. *
   */
  public int getNumProperties() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getNumProperties(swigCPtr, this);
  }

  /**
   *  Get a const reference to a property by its index number, returned as<br>
   *     an AbstractProperty. *
   */
  public AbstractProperty getPropertyByIndex(int propertyIndex) {
    return new AbstractProperty(opensimSimulationJNI.ReferencePtrCoordinate_getPropertyByIndex(swigCPtr, this, propertyIndex), false);
  }

  /**
   *  Return true if this %Object has a property of any type with the <br>
   *     given <i>name</i>, which must not be empty. *
   */
  public boolean hasProperty(String name) {
    return opensimSimulationJNI.ReferencePtrCoordinate_hasProperty(swigCPtr, this, name);
  }

  /**
   *  Get a const reference to a property by its name, returned as<br>
   *     an AbstractProperty. An exception is thrown if no property by this name<br>
   *     is present in this %Object. *
   */
  public AbstractProperty getPropertyByName(String name) {
    return new AbstractProperty(opensimSimulationJNI.ReferencePtrCoordinate_getPropertyByName(swigCPtr, this, name), false);
  }

  /**
   *  Returns <code>true</code> if no property's value has changed since the last time<br>
   *     setObjectIsUpToDateWithProperties() was called. *
   */
  public boolean isObjectUpToDateWithProperties() {
    return opensimSimulationJNI.ReferencePtrCoordinate_isObjectUpToDateWithProperties(swigCPtr, this);
  }

  /**
   *  Serialize this object into the XML node that represents it.   <br>
   *     @param parent <br>
   *         Parent XML node of this object. Sending in a parent node allows an XML <br>
   *         node to be generated for this object if it doesn't already have one. If <br>
   *         no parent node is supplied and this object doesn't already have an XML <br>
   *         node, this object will become the root node for a new XML document. If <br>
   *         this object already has an XML node associated with it, no new nodes <br>
   *         are ever generated and the parent node is not used.<br>
   *     @param prop (optional)<br>
   *         The pointer to the property that contains this object. If it is<br>
   *         present, check if the property is unnamed and if NOT, use the property<br>
   *         name as its name when updating the XML node. *
   */
  public void updateXMLNode(SWIGTYPE_p_SimTK__Xml__Element parent, AbstractProperty prop) {
    opensimSimulationJNI.ReferencePtrCoordinate_updateXMLNode__SWIG_0(swigCPtr, this, SWIGTYPE_p_SimTK__Xml__Element.getCPtr(parent), AbstractProperty.getCPtr(prop), prop);
  }

  /**
   *  Serialize this object into the XML node that represents it.   <br>
   *     @param parent <br>
   *         Parent XML node of this object. Sending in a parent node allows an XML <br>
   *         node to be generated for this object if it doesn't already have one. If <br>
   *         no parent node is supplied and this object doesn't already have an XML <br>
   *         node, this object will become the root node for a new XML document. If <br>
   *         this object already has an XML node associated with it, no new nodes <br>
   *         are ever generated and the parent node is not used.<br>
   *     
   */
  public void updateXMLNode(SWIGTYPE_p_SimTK__Xml__Element parent) {
    opensimSimulationJNI.ReferencePtrCoordinate_updateXMLNode__SWIG_1(swigCPtr, this, SWIGTYPE_p_SimTK__Xml__Element.getCPtr(parent));
  }

  /**
   *  Inlined means an in-memory Object that is not associated with<br>
   *     an XMLDocument. *
   */
  public boolean getInlined() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getInlined(swigCPtr, this);
  }

  /**
   *  If there is a document associated with this object then return the<br>
   *     file name maintained by the document. Otherwise return an empty string. *
   */
  public String getDocumentFileName() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDocumentFileName(swigCPtr, this);
  }

  /**
   *  If there is a document associated with this object then return its<br>
   *         version number. For example this is 30000 for OpenSim 3.x documents <br>
   *         and is 305xx for OpenSim 4.0 beta and above. If there is no document<br>
   *         associated with the object, the method returns -1.
   */
  public int getDocumentFileVersion() {
    return opensimSimulationJNI.ReferencePtrCoordinate_getDocumentFileVersion(swigCPtr, this);
  }

  /**
   *  Write this %Object into an XML file of the given name; conventionally<br>
   *     the suffix to use is ".osim". This is useful for writing out a Model that<br>
   *     has been created programmatically, and also very useful for testing and<br>
   *     debugging. If object has invalid connections, then printing is aborted.<br>
   *     You can override this behavior by setting the debug level to at least 1 <br>
   *     (e.g., Object::setDebugLevel(1)) prior to printing. *
   */
  public boolean print(String fileName) {
    return opensimSimulationJNI.ReferencePtrCoordinate_print(swigCPtr, this, fileName);
  }

  /**
   *  dump the XML representation of this %Object into an std::string and return it.<br>
   *     Mainly intended for debugging and for use by the XML browser in the GUI. *
   */
  public String dump() {
    return opensimSimulationJNI.ReferencePtrCoordinate_dump(swigCPtr, this);
  }

  /**
   *  The default implementation returns true only if the supplied string<br>
   *     is "Object"; each %Object-derived class overrides this to match its own<br>
   *     class name. *
   */
  public boolean isA(String type) {
    return opensimSimulationJNI.ReferencePtrCoordinate_isA(swigCPtr, this, type);
  }

  /**
   *  Wrapper to be used on Java side to display objects in tree; this returns<br>
   *     just the object's name. *
   */
  public String toString() {
    return opensimSimulationJNI.ReferencePtrCoordinate_toString(swigCPtr, this);
  }

}
