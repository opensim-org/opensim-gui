/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.1
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.opensim.modeling;

/**
 *  This class, along with its sister class CoordinateDirection, provides <br>
 * convenient manipulation of the three coordinate axes via the definition of <br>
 * three constants XAxis, YAxis, and ZAxis each with a unique subtype and implicit <br>
 * conversion to the integers 0, 1, and 2 whenever necessary.\ Methods are <br>
 * provided to allow code to be written once that can be used to work with the<br>
 * axes in any order.<br>
 * <br>
 * There are also three CoordinateDirection constants NegXAxis, NegYAxis, and<br>
 * NegZAxis, also with unique types permitting efficient compile time <br>
 * manipulation. These do not correspond to integers, however. Instead, they are<br>
 * objects containing one of the CoordinateAxis objects combined with an integer<br>
 * that is 1 or -1 to indicate the direction along that axis. The unary negation<br>
 * operator is overloaded so that -XAxis is NegXAxis and -NegZAxis is ZAxis.<br>
 * There are implicit conversions to UnitVec3 for any CoordinateAxis or <br>
 * CoordinateDirection object, yielding the equivalent (normalized) unit vector<br>
 * corresponding to any of the six directions, without doing any computation<br>
 * (and in particular, without normalizing).<br>
 * @see CoordinateDirection *
 */
public class CoordinateAxis {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  public CoordinateAxis(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  public static long getCPtr(CoordinateAxis obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  public static long swigRelease(CoordinateAxis obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }

  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        opensimSimbodyJNI.delete_CoordinateAxis(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  /**
   *  Explicit construction of a CoordinateAxis from a calculated integer<br>
   *     that must be 0, 1, or 2 representing XAxis, YAxis, or ZAxis. *
   */
  public CoordinateAxis(int i) {
    this(opensimSimbodyJNI.new_CoordinateAxis(i), true);
  }

  /**
   *  Return the "next" coordinate axis after this one:<br>
   *         - XAxis.getNextAxis()  returns YAxis <br>
   *         - YAxis.getNextAxis()  returns ZAxis <br>
   *         - ZAxis.getNextAxis()  returns XAxis *
   */
  public CoordinateAxis getNextAxis() {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateAxis_getNextAxis(swigCPtr, this), true);
  }

  /**
   *  Return the "previous" coordinate axis before this one:<br>
   *         - XAxis.getPreviousAxis()  returns ZAxis <br>
   *         - YAxis.getPreviousAxis()  returns XAxis<br>
   *         - ZAxis.getPreviousAxis()  returns YAxis *
   */
  public CoordinateAxis getPreviousAxis() {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateAxis_getPreviousAxis(swigCPtr, this), true);
  }

  /**
   *  Given this coordinate axis and one other, return the missing one:<br>
   *         - XAxis.getThirdAxis(YAxis) returns ZAxis (and vice versa)<br>
   *         - XAxis.getThirdAxis(ZAxis) returns YAxis (and vice versa)<br>
   *         - YAxis.getThirdAxis(ZAxis) returns XAxis (and vice versa)<br>
   *     @param axis2    A coordinate axis that must be distinct from the<br>
   *         current one; it is a fatal error to provide the same axis.<br>
   *     @return The unmentioned third axis. *
   */
  public CoordinateAxis getThirdAxis(CoordinateAxis axis2) {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateAxis_getThirdAxis(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2), true);
  }

  /**
   *  Return true if this is the X axis. *
   */
  public boolean isXAxis() {
    return opensimSimbodyJNI.CoordinateAxis_isXAxis(swigCPtr, this);
  }

  /**
   *  Return true if this is the Y axis. *
   */
  public boolean isYAxis() {
    return opensimSimbodyJNI.CoordinateAxis_isYAxis(swigCPtr, this);
  }

  /**
   *  Return true if this is the Z axis. *
   */
  public boolean isZAxis() {
    return opensimSimbodyJNI.CoordinateAxis_isZAxis(swigCPtr, this);
  }

  /**
   *  Return true if the given <i>axis2</i> is the one following this one as<br>
   *     would be reported by getNextAxis(). *
   */
  public boolean isNextAxis(CoordinateAxis axis2) {
    return opensimSimbodyJNI.CoordinateAxis_isNextAxis(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2);
  }

  /**
   *  Return true if the given <i>axis2</i> is the one preceding this one as<br>
   *     would be reported by getPreviousAxis(). *
   */
  public boolean isPreviousAxis(CoordinateAxis axis2) {
    return opensimSimbodyJNI.CoordinateAxis_isPreviousAxis(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2);
  }

  /**
   *  Return true if the given <i>axis2</i> is the same as this one.\ You<br>
   *     can use operator==() to perform the same comparison. *
   */
  public boolean isSameAxis(CoordinateAxis axis2) {
    return opensimSimbodyJNI.CoordinateAxis_isSameAxis(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2);
  }

  /**
   *  Return true if both <i>axis2</i> and <i>axis3</i> are the same as this one. *
   */
  public boolean areAllSameAxes(CoordinateAxis axis2, CoordinateAxis axis3) {
    return opensimSimbodyJNI.CoordinateAxis_areAllSameAxes(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2, CoordinateAxis.getCPtr(axis3), axis3);
  }

  /**
   *  Return true if the given <i>axis2</i> is not the same one as this <br>
   *     one.\ You can use operator!=() to perform the same comparison.  *
   */
  public boolean isDifferentAxis(CoordinateAxis axis2) {
    return opensimSimbodyJNI.CoordinateAxis_isDifferentAxis(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2);
  }

  /**
   *  Return true if neither <i>axis2</i> nor <i>axis3</i> is the same as this<br>
   *     axis nor each other; that is, (this,axis2,axis3) together cover all three<br>
   *     axes. *
   */
  public boolean areAllDifferentAxes(CoordinateAxis axis2, CoordinateAxis axis3) {
    return opensimSimbodyJNI.CoordinateAxis_areAllDifferentAxes(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2, CoordinateAxis.getCPtr(axis3), axis3);
  }

  /**
   *  Return true if the given <i>axis2</i> is the one following this one in a<br>
   *     forward cyclical direction, that is, if <i>axis2</i> is the one that would be<br>
   *     reported by getNextAxis(). *
   */
  public boolean isForwardCyclical(CoordinateAxis axis2) {
    return opensimSimbodyJNI.CoordinateAxis_isForwardCyclical(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2);
  }

  /**
   *  Return true if the given <i>axis2</i> is the one following this one in a<br>
   *     reverse cyclical direction, that is, if <i>axis2</i> is the one that would be<br>
   *     reported by getPreviousAxis(). *
   */
  public boolean isReverseCyclical(CoordinateAxis axis2) {
    return opensimSimbodyJNI.CoordinateAxis_isReverseCyclical(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2);
  }

  /**
   *  Perform a specialized dot product between this axis and <i>axis2;</i> <br>
   *     returning one if they are the same axis and zero otherwise, without<br>
   *     performing any floating point operations. *
   */
  public int dotProduct(CoordinateAxis axis2) {
    return opensimSimbodyJNI.CoordinateAxis_dotProduct(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2);
  }

  /**
   *  Return the sign that would result from a cross product between this <br>
   *     axis and <i>axis2</i>: zero if <i>axis2</i> is the same as this axis; one if the <br>
   *     result would be in the positive direction along the third axis; -1 if it <br>
   *     would be in the negative direction. No floating point computations are<br>
   *     performed. @see crossProductAxis() *
   */
  public int crossProductSign(CoordinateAxis axis2) {
    return opensimSimbodyJNI.CoordinateAxis_crossProductSign(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2);
  }

  /**
   *  Return the coordinate axis along which the cross product of this axis <br>
   *     and <i>axis2</i> would lie: same as this if <i>axis2</i> is the same as this axis<br>
   *     (doesn't matter because the sign would be zero); otherwise, the third<br>
   *     axis that is neither this one nor <i>axis2</i>. But note that the actual<br>
   *     result may be along that axis or in the negative direction along that<br>
   *     axis.  No floating point computations are performed. <br>
   *     @see crossProductSign(). *
   */
  public CoordinateAxis crossProductAxis(CoordinateAxis axis2) {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateAxis_crossProductAxis(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2), true);
  }

  /**
   *  Return the axis and sign along that axis that would result from a<br>
   *     cross product between this axis and <i>axis2;</i> this combines the functions<br>
   *     of both crossProductAxis() and crossProductSign(). Note that if <i>axis2</i> is<br>
   *     the same as this axis we'll just return this as the axis but the sign is <br>
   *     zero since the magnitude of the result would be zero. No floating point <br>
   *     calculations are performed. <br>
   *     @see crossProductSign(), crossProductAxis() *
   */
  public CoordinateAxis crossProduct(CoordinateAxis axis2, SWIGTYPE_p_int sign) {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateAxis_crossProduct(swigCPtr, this, CoordinateAxis.getCPtr(axis2), axis2, SWIGTYPE_p_int.getCPtr(sign)), true);
  }

  /**
   *  Return a reference to the CoordinateAxis constant XAxis, YAxis, or<br>
   *     ZAxis corresponding to the given integer index which must be 0, 1, or 2. *
   */
  public static CoordinateAxis getCoordinateAxis(int i) {
    return new CoordinateAxis(opensimSimbodyJNI.CoordinateAxis_getCoordinateAxis(i), false);
  }

  /**
   *  Return true if the given integer is suitable as a coordinate axis, <br>
   *     meaning it is one of 0, 1, or 2 designating XAxis, YAxis, or ZAxis, <br>
   *     respectively. *
   */
  public static boolean isIndexInRange(int i) {
    return opensimSimbodyJNI.CoordinateAxis_isIndexInRange(i);
  }

}
